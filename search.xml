<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件测试——测试用例03</title>
      <link href="/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B03/"/>
      <url>/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B03/</url>
      
        <content type="html"><![CDATA[<h1 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h1><a id="more"></a><p>在一个程序中，<strong>如果输入输出比较多，输入之间和输出之间相互制约的条件比较多，在这种情况下应用决策表很合适</strong>，它可以很清楚地表达它们之间的各种复杂关系。</p><p>决策表法简述：<br>       决策表是把作为条件的所有输入的各种组合值以及对应输出值都罗列出来而形成的表格。它能够将复杂的问题按照各种可能的情况全部列举出来，简明并可避免遗漏。因此，利用决策表能够设计出完整的测试用例集合。</p><blockquote><p>决策表通常由以下4部分组成：</p><p>1.条件桩—列出问题的所有条件</p><p>2.条件项—针对条件桩给出的条件列出所有可能取值</p><p>3.动作桩—列出问题规定的可能采取的操作</p><p>4.动作项—指出在条件项的各组取值情况下应采取的动作 </p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote><p>打印机是否能打印出来正确的内容有多个因素影响，包括驱动程序、纸张、墨粉等。（为了简化问题，不考虑中途断电、卡纸等因素的影响）</p><p>假定：优先警告缺纸，然后警告没有墨粉，最后警告驱动程序不对。</p><p>1)列出条件桩和动作桩</p><p>条件桩:  a)驱动程序是否正确   b)是否有纸张   c)是否有墨粉</p><p>动作桩:  a) 打印内容       b)提示驱动程序不对   </p><p>​              c)提示没有纸张      d)提示没有墨粉</p></blockquote><h2 id="决策表的构造及化简"><a href="#决策表的构造及化简" class="headerlink" title="决策表的构造及化简"></a>决策表的构造及化简</h2><blockquote><p>1.列出所有的条件桩和动作桩。</p><p>2.确定规则的个数。</p><p>3.填入条件项。</p><p>4.填入动作项，得到初始决策表。</p><p>5.简化决策表，合并相似规则。</p></blockquote><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="得到初始判定表"><a href="#得到初始判定表" class="headerlink" title="得到初始判定表"></a>得到初始判定表</h3><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>条件：   功率大于50马力？   维修记录不全？   运行超过10年？</td><td>Y   Y   Y</td><td>Y   Y   N</td><td>Y   N   Y</td><td>Y   N   N</td><td>N   Y   Y</td><td>N   Y   N</td><td>N   N   Y</td><td>N   N   N</td></tr><tr><td>动作：   进行优先处理   做其他处理</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="简化判定表，合并相似规则"><a href="#简化判定表，合并相似规则" class="headerlink" title="简化判定表，合并相似规则"></a>简化判定表，合并相似规则</h3><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>条件：   功率大于50马力？   维修记录不全？   运行超过10年？</td><td>Y   Y   -</td><td>Y   N   Y</td><td>Y   N   N</td><td>N   -   Y</td><td>N   -  N</td><td></td><td>N   N   Y</td><td>N   N   N</td></tr><tr><td>动作：   进行优先处理   做其他处理</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例02</title>
      <link href="/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B02/"/>
      <url>/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B02/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h1><blockquote><p>1.等价类法</p><p>2.边界值法</p></blockquote><a id="more"></a><h2 id="等价类法"><a href="#等价类法" class="headerlink" title="等价类法"></a>等价类法</h2><p>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这个过程，直至所有的有效等价类均被测试用例所覆盖；</p><p>设计一个新的测试用例，使其仅覆盖一个无效等价类，重复这个过程，直至所有的无效等价类均被测试用例所覆盖。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote><p>某城市电话号码由三部分组成，分别是</p><p>地区码：空白或是3位数字</p><p>前缀：非‘0’且非‘1’开头的三位数字</p><p>后缀：4位数字</p><p>假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的电话号码</p></blockquote><table><thead><tr><th><strong>条件</strong></th><th><strong>有效等价类</strong></th><th><strong>编号</strong></th><th><strong>无效等价类</strong></th><th style="text-align:center"><strong>编号</strong></th></tr></thead><tbody><tr><td>地区码</td><td>空白</td><td>1</td><td>非数字</td><td style="text-align:center">5</td></tr><tr><td>三位数字</td><td>2</td><td>小于三位</td><td>6</td><td style="text-align:center"></td></tr><tr><td>前缀</td><td>大于三位</td><td>7</td><td></td><td style="text-align:center"></td></tr><tr><td>非0且非1开头的三位数字</td><td>3</td><td>空值</td><td>8</td><td style="text-align:center"></td></tr><tr><td></td><td>0开头的三位数字</td><td>9</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>1开头的三位数字</td><td>10</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>非0且非1 开头的长度小于三位的数字</td><td>11</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>非0且非1 开头的长度大于三位的数字</td><td>12</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>非数字</td><td>13</td><td></td><td style="text-align:center"></td></tr><tr><td>后缀</td><td>四位数字</td><td>4</td><td>空值</td><td style="text-align:center">14</td></tr><tr><td></td><td>非数字</td><td>15</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>小于四位</td><td>16</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>大于四位</td><td>17</td><td></td></tr></tbody></table><blockquote><p>1.Step1、分析需求中包含多少个独立功能</p><p>判断独立功能的标准：功能名是一个动词、不可继续往下分割、包含三要素：输入、处理、输出</p><p>2.Step2、分别针对每个独立功能开展需求分析</p><p>分析界面可见输入参数，罗列参数个数及名称、  分析界面不可见输入参数：网络、浏览器/系统、权限、数据库服务、系统本身服务</p><p>3.Step3、分析界面可见输入参数的特点及其关系</p><p>输入参数需要用户输入数据，并且存在有效/无效规则校验—— 则用等价类法设计测试用例</p><p>4.Step4、分别罗列每个界面可见输入参数的有效无效规则，形成等价类表</p><p>测试文本框类型应考虑的几个维度：长度、类型、组成规则、是否为空、是否重复、是否区分大小写、是否去前中后空格</p><p>构造无效规则时要注意：只能同时违背一条规则</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><blockquote><p>用户注册页面需求</p><p>-USER NAME  长度为  3-19：以字母开头</p><p>-姓名：非空</p><p>-密码： 非空</p><p>-确认密码： 值和密码相同</p><p>-出生月份： 年—–四位数字</p><p>-                    月——1-12</p><p>​             日——-1-31</p></blockquote><table><thead><tr><th><strong>输入项</strong></th><th><strong>有效等价类</strong></th><th><strong>无效等价类</strong></th></tr></thead><tbody><tr><td>username</td><td>长3—19（1）      以字母开头   （4）</td><td>长度<3 (2) 长度>19      (3)   非字母开头（5）</3></td></tr><tr><td>姓名</td><td>非空    （6）</td><td>为空      （7）</td></tr><tr><td>密码</td><td>非空    （8）</td><td>为空    （9）</td></tr><tr><td>确认密码</td><td>值和密码值相同   （10）</td><td>值和密码值不同   （11）</td></tr><tr><td>出生年份</td><td>年  —-    四位（12）   年    —-   数字  （14）      年    —-     合理范围（16）</td><td>&lt;4(13)  &gt;4(18)   年数中他非数字符号(19)   空（15）   年数在不合理范围（17）</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="边界值"><a href="#边界值" class="headerlink" title="边界值"></a>边界值</h2><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法</p><p>长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部（从开发角度可以发现）。因此针对各种边界情况设计测试用例，可以查出更多的错误。</p><p>使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1565956632576.png" alt="1565956632576"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p>例如，如果程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取？</p><p>9.99，10，10.01，49.99,50，50.01。</p><p>练习：</p><p>   [100   200]</p><p>   [100   200）</p><p>   (100   200)</p></blockquote><p>结合等价类划分法，设计测试数据！</p><p>移动公司话费赠送方案如下：</p><table><thead><tr><th><strong>话费累计</strong></th><th><strong>赠送</strong></th></tr></thead><tbody><tr><td>[0,200)</td><td>0</td></tr><tr><td>[200,500)</td><td>20</td></tr><tr><td>[500,800)</td><td>30</td></tr><tr><td>&gt;=800</td><td>50</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>等价类用例设计要点</p><p>  1 操作步骤 </p><pre><code>1 一个新用例尽量覆盖有效规则2 一个新用例只能覆盖一条无效规则</code></pre><p>  2 测试过程中需要考虑要点</p><p>边界值用例设计要点</p><p>  1 上点</p><p>  2 离点</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例01</title>
      <link href="/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B01/"/>
      <url>/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B01/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例概述"><a href="#测试用例概述" class="headerlink" title="测试用例概述"></a>测试用例概述</h1><blockquote><p>1.测试用例的定义</p><p>2.测试用例的特性</p><p>3.测试用例的编制要素</p><p>4.测试用例的设计原则</p></blockquote><a id="more"></a><h2 id="测试用例的定义"><a href="#测试用例的定义" class="headerlink" title="测试用例的定义"></a>测试用例的定义</h2><p>​    测试用例(Test Case)是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试某个程序路径或核实是否满足某个特定需求。</p><p>​    通过大量的测试用例来检验软件的运行效果，它是指导测试工作进行的依据。</p><p>​    输入数据        执行条件和执行步骤         预期结果</p><p>测试用例（TestCase）是为了高效率地发现软件缺陷而精心设计的少量测试数据。实际测试中，由于无法达到穷举测试，所以要从大量输入数据中精选有代表性或特殊性的数据来作为测试数据。好的测试用例应该能发现尚未发现的软件缺陷</p><h2 id="测试用例的特性"><a href="#测试用例的特性" class="headerlink" title="测试用例的特性"></a>测试用例的特性</h2><blockquote><p>1.有效性：测试用例的能够被使用，且被不同人员使用测试结果一致。</p><p>2.可复用性：良好的测试用例具有重复使用的功能</p><p>3.易组织性：好的测试用例会分门别类地提供给测试人员参考和使用。</p><p>4.可评估性：从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。</p><p>5.可管理性：测试用例可以作为检验测试人员进度、工作量以及跟踪/管理测试人员工作效率的因素。</p></blockquote><h2 id="测试用例的编制要素"><a href="#测试用例的编制要素" class="headerlink" title="测试用例的编制要素"></a>测试用例的编制要素</h2><p>软件测试用例的基本要素包括用例编号、测试模块、用例标题、用例级别、测试环境、测试输入、执行操作、预期结果。</p><blockquote><p>1.用例编号：每个测试用例都有唯一的标识号，用以区别其他测试用例。</p><p>例：系统测试用例的编号这样定义规则：PROJECT1-ST-001，命名规则是项目名称＋测试阶段类型（系统测试阶段）＋编号。</p><p>2.测试标题：对测试用例的描述，测试用例标题应该清楚表达测试用例的用途。</p><p>例： “测试用户登录时输入错误密码时，软件的响应情况 ” 。</p><p>3.测试模块：指明并简单描述本测试用例是用来测试哪些项目、子项目或软件特性的。</p><p>例： 购物模块</p><p>4.用例级别：定义测试用例的优先级别，可以粗略地分为“ 高 ” 和 “ 低 ” 两个级别，</p><p>例： 核心功能 —高        界面风格 —低</p><p>5.测试环境：描述执行测试用例所需要的具体测试环境，包括硬件环境和软件环境。</p><p>例： 硬件  ： 计算机的具体配置，见测试计划       软件   ：  操作系统    linux                      数据库       mysql                      中间件       weblogic</p><p>6.测试输入：用来执行测试用例的输入要求。这些输入可能是数据、文件或具体操作。</p><p>例如： 数据  ：  12           文件  ：   c：\a.c  件couture           动作  ：  单击鼠标，在键盘做按键处理）。</p><p>7.执行操作：执行本测试用例所需的每一步操作。</p><p>例： 求和运算         输入加数12          输入被加数 24          点击“加法按钮”</p><p>8.预期结果：描述被测项目或被测特性所希望或要求达到的输出或指标。</p><p>例：  加法器    12+24           预期结果：  36</p></blockquote><h2 id="测试用例的设计原则"><a href="#测试用例的设计原则" class="headerlink" title="测试用例的设计原则"></a>测试用例的设计原则</h2><ol><li>保证测试用例的明确性</li></ol><p>测试人员要尽量避免测试用例存在含糊的因素，在测试过程中，测试用例的测试结果是唯一的。</p><p>明确清晰的描述  如：即通过、没通过或未进行测试。</p><p>不确定的描述    例如，测试用例这样描述：  </p><p>用户正确操作，系统正常运行；</p><p>用户进行非法操作，系统不能正常运行。</p><ol start="2"><li>保证测试用例的代表性</li></ol><p>尽量将具有相似功能的测试用例抽象合并。</p><p>如： 以后我们要学习的等价类测试   </p><p>​        测试1 —-100之间的两个整数的和   </p><p>​       用例  1+2=3</p><p>​               2+4 =6  </p><p>功能相似的用例要合并</p><ol start="3"><li>保证测试用例的简洁性</li></ol><p>测试用例简洁，可读性良好，测试过程目的明确，测试结果唯一。</p><p>例： 测试用例要用陈述性语句  一句话直指问题的核心</p><p>​          加法器输入框输入是非数字时，应弹出提示“请输入数字”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论05</title>
      <link href="/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA05/"/>
      <url>/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA05/</url>
      
        <content type="html"><![CDATA[<h1 id="svn的使用"><a href="#svn的使用" class="headerlink" title="svn的使用"></a>svn的使用</h1><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（1）电脑发生故障，文件没有备份而丢失了</span><br><span class="line">由于人员离职，导致某些资料丢失了</span><br><span class="line">（2）我怎么知道手头的公共资料是不是最新版呢？</span><br><span class="line">（3）想要追溯几个月前的某个状态，却发现那个版本的文件已经被当作垃圾删除了</span><br><span class="line">（4）每天要花费很多时间来向别人提供需要共享的资料</span><br><span class="line">（5）相似的应用系统，每次都重复开发，难以复用</span><br><span class="line">（6）一个软件被用于多个项目，发现其中存在一个BUG，所有这些项目都要进行修复</span><br><span class="line">（7）人员分布在两地开发，版本如何同步</span><br><span class="line">甲乙两人为不同目的修改了同一份文件，乙的提交在甲提交之后，导致甲修改的内容丢失了</span><br></pre></td></tr></table></figure><h2 id="1、svn的简介"><a href="#1、svn的简介" class="headerlink" title="1、svn的简介"></a>1、svn的简介</h2><ul><li>一个开源的版本管理软件</li><li>可架设在Apache上，最常用的客户端为TortoiseSVN（简称TSVN）</li></ul><h2 id="2、应用环境"><a href="#2、应用环境" class="headerlink" title="2、应用环境"></a>2、应用环境</h2><ul><li>服务器端：CollabNet的SVN服务器端安装包（内含Apache2.2）</li><li>推荐使用TortoiseSVN（以下简称TSVN）</li><li>可通过TSVN进行读、写操作</li><li>可通过IE浏览器进行读操作</li><li>可通过各种插件与开发工具集成</li></ul><h2 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装文件：</span><br><span class="line">TSVN客户端：</span><br><span class="line">TortoiseSVN-1.6.8.19260-win32-svn-1.6.11.msi</span><br><span class="line">TSVN中文语言包：</span><br><span class="line">LanguagePack_1.6.8.19260-win32-zh_CN.msi</span><br><span class="line">全部选择默认安装，安装完成后重启电脑</span><br><span class="line">TSVN通过右键菜单与Windows资源管理器集成，没有自己的窗口界面</span><br></pre></td></tr></table></figure><h2 id="svn的使用-创建版本库"><a href="#svn的使用-创建版本库" class="headerlink" title="svn的使用-创建版本库"></a>svn的使用-创建版本库</h2><ul><li>在SVN服务器端操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在相应文件夹内新建一个文件夹，用于存储数据</span><br><span class="line">在新建文件夹上点右键，选择“TortoiseSVN－在此创建版本库”，TSVN会在此文件夹内建立若干控制文件。如图</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/111.png" alt="img"></p><h2 id="svn使用-检出"><a href="#svn使用-检出" class="headerlink" title="svn使用-检出"></a>svn使用-检出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“检出”用于客户端第一次从SVN服务器上下载版本库数据</span><br><span class="line">在客户端新建一个文件夹用于存放下载的数据</span><br><span class="line">在新建文件夹上点右键，选择“SVN检出…”</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/112.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在弹出窗口的“版本库URL”处填入版本库的访问地址，如：http://10.50.22.35:8080/svn/XXX部门/XXXX项目/</span><br><span class="line">点“确定”开始从SVN服务器下载数据</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/113.png" alt="img"></p><h2 id="svn使用-更新"><a href="#svn使用-更新" class="headerlink" title="svn使用-更新"></a>svn使用-更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“更新”用于客户端从SVN服务器下载最新版本</span><br><span class="line">在受SVN控制的某层文件夹上（或文件夹内空白处）点右键，选择“SVN更新”，TSVN自动比较该文件夹客户端与服务器的版本差异，并下载最新版本到客户端</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/114.png" alt="img"></p><h2 id="svn使用-提交"><a href="#svn使用-提交" class="headerlink" title="svn使用-提交"></a>svn使用-提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“提交”用于将客户端的改动上传到SVN服务器</span><br><span class="line">在受SVN控制的某层文件夹上（或文件夹内空白处，或某文件上）点右键，选择“SVN提交…”</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/115.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TSVN自动检查该文件夹客户端的改动，并将其列在弹出窗口的“变更列表”栏</span><br><span class="line">在弹出窗口的“信息”栏写上对此次提交的注释，以便将来追溯</span><br><span class="line">点击“确定”将客户端的改动上传到服务器</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/116.png" alt="img"></p><h2 id="svn使用-增加"><a href="#svn使用-增加" class="headerlink" title="svn使用-增加"></a>svn使用-增加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“增加”用于将新文件或文件夹纳入SVN的控制之下</span><br><span class="line">在受SVN控制的某层文件夹上（或文件夹内空白处，或新增的某文件上）点右键，选择“TortoiseSVN－增加”</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/117.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接在受svn控制的文件夹中添加想要上传的文件，然后右键选择“提交”即可；</span><br></pre></td></tr></table></figure><h2 id="svn使用-删除"><a href="#svn使用-删除" class="headerlink" title="svn使用-删除"></a>svn使用-删除</h2><ul><li>“删除”仅是对客户端的文件进行操作，并不改变服务器上的内容，需要执行“提交”操作才会将删除操作上传到服务器</li><li>将“删除”操作“提交”到服务器后，仅是从服务器的最新版本中删除了此文件或文件夹，在历史版本中仍可找回此文件或文件夹</li></ul><h2 id="svn使用-改名"><a href="#svn使用-改名" class="headerlink" title="svn使用-改名"></a>svn使用-改名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“改名”用于在受SVN控制的状态下，对文件或文件夹改名</span><br><span class="line">在受SVN控制的某层文件夹或文件上点右键，选择“TortoiseSVN－改名”</span><br></pre></td></tr></table></figure><ul><li>“改名”仅是对客户端的文件进行操作，并不改变服务器上的内容，需要执行“提交”操作才会将改名操作上传到服务器</li><li>不要用Windows“重命名”来实现改名，因为这个操作不受SVN控制，SVN会将其理解为删除原文件、增加一个新文件，从而导致文件改名后不能跟踪到改名前的状态</li></ul><h2 id="svn使用-移动"><a href="#svn使用-移动" class="headerlink" title="svn使用-移动"></a>svn使用-移动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“移动”用于在受SVN控制的状态下，移动文件或文件夹的位置</span><br><span class="line">在受SVN控制的某层文件夹或文件上点右键，选择“TortoiseSVN－版本库浏览器”</span><br><span class="line">在弹出窗口拖动文件夹或文件到需要的位置</span><br><span class="line">由于是对服务器版本库直接操作，移动后将自动执行一次“提交”操作</span><br><span class="line">移动完成后需要在客户端执行一次“更新”，以下载最新状态</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/118.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要用Windows的拖动操作或“剪切”、“粘贴”来实现移动，因为这些操作不受SVN控制，SVN会将其理解为在原位置删除文件、在新位置增加文件，从而导致文件移动后不能跟踪到移动前的状态</span><br></pre></td></tr></table></figure><h2 id="7、缺陷管理"><a href="#7、缺陷管理" class="headerlink" title="7、缺陷管理"></a>7、缺陷管理</h2><ul><li>管理员可通过修改服务器上的权限文件，实现对权限的控制</li><li>权限分为三种：无权限、只读权限和读写权限</li><li>权限的控制以文件夹为最小单位</li><li>可对单个用户的权限进行控制，也可以对用户组的权限进行控制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论04</title>
      <link href="/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA04/"/>
      <url>/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.软件缺陷</p><p>2.缺陷管理</p></blockquote><a id="more"></a><h1 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h1><h2 id="软件缺陷-1"><a href="#软件缺陷-1" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><h4 id="软件缺陷的定义"><a href="#软件缺陷的定义" class="headerlink" title="软件缺陷的定义"></a>软件缺陷的定义</h4><ul><li><p>IEEE 1983 of IEEE Standard 729中对软件缺陷作了一个标准的定义：</p><p>从产品内部看，软件缺陷是软件产品开发或维护过程中所存在的错误、毛病等各种问题； 从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。</p></li></ul><p>因此软件缺陷就是软件产品中所存在的问题，最终表现为用户所需要的功能没有完全实现，没有满足用户的需求。</p><ul><li><p>软件缺陷是指存在于软件（程序、数据、文档）中的那些不符合用户需求的问题。</p><ol><li><p>软件未达到需求规格说明书表明的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算器说明书一般声称该计算器将准确无误地进行加、减、乘、除运算。</span><br><span class="line">如果测试人员或用户选定了两个数值后，随意按下了“+”号键，结果没有任何反应。</span><br></pre></td></tr></table></figure></li><li><p>软件出现了需求规格说明书指明不会出现的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若在进行测试时，发现除了规定的加、减、乘、除功能之外，还能够进行求平方根的运算，</span><br><span class="line">而这一功能并没有在说明书的功能中规定。</span><br></pre></td></tr></table></figure></li><li><p>软件的功能超出了需求规格说明书指明的范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若在测试过程中发现，因为电池没电而导致了计算不正确，</span><br><span class="line">但软件需求规格说明书未能指出在此情况下应如何进行处理。</span><br></pre></td></tr></table></figure></li><li><p>软件未达到需求规格说明书虽未指明而应该达到的目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假如计算器说明书指明计算器不会出现崩溃、死锁或者停止反应，而在用户随意按、敲键盘后，</span><br><span class="line">计算器停止接受输入或没有了反应。</span><br></pre></td></tr></table></figure></li><li><p>软件测试人员认为软件难以理解、不易使用、运行速度慢、或者最终用户认为不好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试人员或最终用户发现计算器某些地方不好用，比如，按键太小、显示屏在亮光下无法看清等。</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="软件缺陷的表现形式"><a href="#软件缺陷的表现形式" class="headerlink" title="软件缺陷的表现形式"></a>软件缺陷的表现形式</h4><ul><li>功能、特性没有实现或部分实现。</li><li>设计不合理，功能特性不明确，逻辑不清楚或存在矛盾。</li><li>产品实际结果和所期望的结果不一致。</li><li>没有达到需求规格说明书所规定的性能指标等。</li><li>运行出错，包括运行中断、系统崩溃、界面混乱等。</li><li>数据不正确、精度不够、不完整或格式不统一。</li><li>用户不能接受的其他问题，如存取时间过长、界面不美观。</li><li>硬件或系统软件上存在的其他问题</li></ul><h4 id="软件缺陷产生的原因"><a href="#软件缺陷产生的原因" class="headerlink" title="软件缺陷产生的原因"></a>软件缺陷产生的原因</h4><p>软件缺陷产生是不可避免的，造成软件缺陷产生的原因主要归纳如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">需求解释或者记录错误  </span><br><span class="line">用户需求定义错误  </span><br><span class="line">设计说明存在错误  </span><br><span class="line">编码说明、程序代码有误  </span><br><span class="line">硬件或者软件系统上存在错误  </span><br><span class="line">其他，如文档错误、内容不正确或拼写错误</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/56.png" alt="img"></p><h4 id="软件缺陷产生的根源"><a href="#软件缺陷产生的根源" class="headerlink" title="软件缺陷产生的根源"></a>软件缺陷产生的根源</h4><ul><li><p>交流不充分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户与开发人员、开发人员与测试人员等</span><br></pre></td></tr></table></figure></li><li><p>软件的复杂性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能复杂、开发复杂、测试复杂</span><br></pre></td></tr></table></figure></li><li><p>开发人员的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对需求的理解、开发压力、能力与经验</span><br></pre></td></tr></table></figure></li><li><p>需求的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求说明书、设计文档、程序的变更</span><br></pre></td></tr></table></figure></li><li><p>进度压力</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目周期比较紧</span><br></pre></td></tr></table></figure></li><li><p>软件缺陷修复的费用</p></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/57.png" alt="img"></p><h2 id="软件缺陷的信息"><a href="#软件缺陷的信息" class="headerlink" title="软件缺陷的信息"></a>软件缺陷的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了便于缺陷的定位、跟踪和修改，要对所发现的缺陷，按照缺陷的严重程度、优先级、发现阶段、</span><br><span class="line">修复阶段、缺陷的性质、所属功能模块、系统环境等方面进行分类和统计。</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/59.png" alt="img"></p><ul><li>缺陷的状态</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/58.png" alt="img"></p><ul><li>缺陷的分类</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/60.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/61.png" alt="img"></p><ul><li>缺陷的严重程度</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/62.png" alt="img"></p><ul><li>缺陷的优先级</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/63.png" alt="img"></p><h2 id="软件缺陷修复相关"><a href="#软件缺陷修复相关" class="headerlink" title="软件缺陷修复相关"></a>软件缺陷修复相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并不是所有的缺陷，开发人员都会进行修复</span><br></pre></td></tr></table></figure><ul><li><p>开发人员拒绝修改的缺陷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序员无法重现或者现象难以捕捉  </span><br><span class="line">没有明确的报告以说明重现缺陷的步骤  </span><br><span class="line">程序员无法读懂的缺陷报告  </span><br><span class="line">用户很少使用或者不符合用户使用习惯的操作出错  </span><br><span class="line">由不受信任的测试人员提出</span><br></pre></td></tr></table></figure></li><li><p>不是所有缺陷都会修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">市场的压力使得产品最终发行有时间限制</span><br><span class="line">测试人员错误理解或者不正确操作引出的缺陷(FAQ)</span><br><span class="line">错误的修改影响的模块较多，带来的风险较大(遗留)</span><br><span class="line">修改性价比太低</span><br><span class="line">缺陷报告中提出的问题很难重现</span><br></pre></td></tr></table></figure></li></ul><h1 id="缺陷管理"><a href="#缺陷管理" class="headerlink" title="缺陷管理"></a>缺陷管理</h1><h3 id="1、-缺陷报告的重要性"><a href="#1、-缺陷报告的重要性" class="headerlink" title="1、 缺陷报告的重要性"></a>1、 缺陷报告的重要性</h3><ul><li>软件缺陷的描述是软件缺陷报告的基础部分，需要使用简单、准确、专业的术语来描述缺陷。否则，它就会含糊不清，可能会误导开发人员，影响开发人员的效率，也会影响测试人员自身的声誉，准确报告缺陷是非常重要的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">清晰准确的软件缺陷描述可以减少开发人员退回来的缺陷数量，可以节省开发人员和测试人员的时间。</span><br><span class="line">提高软件缺陷修复的速度，使项目组能够有效地工作。</span><br><span class="line">提高测试人员的可信任程度，可以得到开发人员对有效缺陷的及时响应。</span><br><span class="line">加强开发人员、测试人员和管理人员的协同工作，让他们更好的工作</span><br></pre></td></tr></table></figure><h3 id="2、-缺陷报告的注意事项"><a href="#2、-缺陷报告的注意事项" class="headerlink" title="2、 缺陷报告的注意事项"></a>2、 缺陷报告的注意事项</h3><ul><li><p>尽量确保缺陷可以重现</p><blockquote><p>如果提交的缺陷无法重现，会影响开发人员的工作效率。</p></blockquote></li><li><p>简洁、准确、完整</p><blockquote><p>测试人员在提交缺陷报告时，要站在开发人员的角度上思考问题，要确保开发人员能迅速定位问题，而不会产生理解上的歧义。</p></blockquote></li><li><p>一个缺陷一个报告</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　有的测试人员喜欢在一个缺陷报告里提交多个缺陷，这种习惯不提倡，原因有以下两点：</span><br><span class="line">不便于分配。</span><br><span class="line">　　比如缺陷报告有2个缺陷，分别属于不同的开发人员，到底该分配给谁呢？</span><br><span class="line">不便于验证。</span><br><span class="line">　　比如一个缺陷报告里面有2个缺陷，缺陷1已经解决，缺陷2还没有解决，那么这个缺陷报告该不该关闭呢？</span><br></pre></td></tr></table></figure><h3 id="3、-缺陷书写规范"><a href="#3、-缺陷书写规范" class="headerlink" title="3、 缺陷书写规范"></a>3、 缺陷书写规范</h3><ul><li>标题：应保持简短、准确，提供缺陷的本质信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尽量按缺陷发生的原因与结果的方式书写；</span><br><span class="line">避免使用模糊不清的词语，例如：“功能中断，功能不正确，行为不起作用”等。应该使用具体文字说明缺陷的症状；</span><br><span class="line">为了便于他人理解，避免使用俚语或过分具体的测试细节。</span><br></pre></td></tr></table></figure><ul><li>复现步骤：应包含如何使别人能够很容易的复现该缺陷的完整步骤。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了达到这个要求，复现步骤的信息必须是完整的、准确的、简明的、可复现的。常见问题：</span><br><span class="line">包含了过多的多余步骤，且句子结构混乱，可读性差，难以理解；</span><br><span class="line">包含的信息过少，丢失了操作的必要步骤；</span><br></pre></td></tr></table></figure><ul><li>复现步骤的正确书写方式:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">提供测试的环境信息；</span><br><span class="line">简单地一步步引导复现该缺陷，一个步骤包含的操作不要多；</span><br><span class="line">每个步骤前使用数字对步骤编号；</span><br><span class="line">尽量使用短语或短句，避免复杂句型句式；</span><br><span class="line">复现的步骤要完整、准确、简短；</span><br><span class="line">将常见步骤合并为较少步骤；</span><br><span class="line">按实际需要决定是否包含步骤执行后的结果。</span><br></pre></td></tr></table></figure><ul><li>实际结果: 是执行复现步骤后软件的现象和产生的行为。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际结果的描述应向标题信息那样，要列出具体的缺陷症状，而不是简单地指出“不正确”或“不起作用”。</span><br></pre></td></tr></table></figure><ul><li>期望结果:描述应与实际结果的描述方式相同。通常需要列出期望的结果是什么。</li><li>附件：对缺陷描述的补充说明，可以是以下一些类型：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缺陷症状的截图；</span><br><span class="line">测试使用的数据文件;</span><br></pre></td></tr></table></figure><ul><li>其他：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择合适的缺陷严重性属性；</span><br><span class="line">按相应的规定，填写相应的字段信息</span><br></pre></td></tr></table></figure><h4 id="3、1-避免常见错误"><a href="#3、1-避免常见错误" class="headerlink" title="3、1 避免常见错误"></a>3、1 避免常见错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">避免使用我、你等人称代词，可以直接使用动词或必要时使用“用户”代替</span><br><span class="line">避免使用情绪化的语言和强调符号；</span><br><span class="line">避免使用诸如“似乎”、“看上去可能”等含义模糊的词汇，而需要报告确定的缺陷结果；</span><br><span class="line">避免使用自认为比较幽默的语句，只需客观地描述缺陷的信息；</span><br><span class="line">避免提交不确定的测试问题，自己至少需要重现一次再提交。</span><br><span class="line">反面的示例：</span><br><span class="line">上海人：哪能查询到的结果和查询条件不搭噶的。</span><br><span class="line">北京人：哥们好不容易输入一堆个人详细信息后，点击保存后全瞎了</span><br></pre></td></tr></table></figure><h4 id="3、2-缺陷报告"><a href="#3、2-缺陷报告" class="headerlink" title="3、2 缺陷报告"></a>3、2 缺陷报告</h4><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/106.png" alt="img"></p><h4 id="3、3-缺陷处理流程"><a href="#3、3-缺陷处理流程" class="headerlink" title="3、3 缺陷处理流程"></a>3、3 缺陷处理流程</h4><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/107.png" alt="img"></p><h4 id="3、4-缺陷跟踪"><a href="#3、4-缺陷跟踪" class="headerlink" title="3、4 缺陷跟踪"></a>3、4 缺陷跟踪</h4><ul><li>新提交的缺陷为新建状态，确认有效后为打开状态，经开发人员修改后，缺陷变为已修复（待验证）状态。此时就需要测试人员对缺陷进行回归测试，验证问题是否修复。</li><li>如果问题仍然存在，则测试人员将该缺陷的状态修改为重新打开；</li><li>如果问题已经修复，则测试人员将该缺陷的状态置为关闭状态（验证通过），同时添加回测说明如“该缺陷已解决”。</li><li>还有一种情况：开发人员认为缺陷在当前版本可以暂不修改，而考虑在后续版本中再做修正，缺陷的对应状态为延期。</li><li>对于这种情况，项目负责人应召集开发人员、测试人员和其他项目相关人员进行讨论，如果讨论结果为同意则延期，如果不同意，则重新打开缺陷。</li></ul><h4 id="3、5-缺陷统计"><a href="#3、5-缺陷统计" class="headerlink" title="3、5 缺陷统计"></a>3、5 缺陷统计</h4><ul><li><p>缺陷按活动分布 <img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/108.png" alt="img"></p></li><li><p>缺陷按严重程度分布</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/109.png" alt="img"></p></li><li><p>缺陷按引入源分布</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/110.png" alt="img"></p></li></ul><h4 id="3、6-缺陷数据分析"><a href="#3、6-缺陷数据分析" class="headerlink" title="3、6 缺陷数据分析"></a>3、6 缺陷数据分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）缺陷数据分析关注的问题</span><br><span class="line">2）缺陷数据分析的重要性</span><br><span class="line">3）缺陷数据分析的数据指标</span><br></pre></td></tr></table></figure><h4 id="3、7-缺陷数据分析关注的问题"><a href="#3、7-缺陷数据分析关注的问题" class="headerlink" title="3、7 缺陷数据分析关注的问题"></a>3、7 缺陷数据分析关注的问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正在测试的软件哪个模块的问题最多</span><br><span class="line">测试人员中谁报告的软件缺陷最多</span><br><span class="line">各类缺陷所占的数量百分比分别是多少</span><br><span class="line">开发人员能及时修复软件缺陷吗</span><br><span class="line">开发人员一次正确修复缺陷的百分比是多少</span><br><span class="line">正在开发的软件能否在计划的时间内正常发布</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论03</title>
      <link href="/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA03/"/>
      <url>/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA03/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h1><blockquote><p>1.场景法</p><p>2.流程图法</p><p>3.错误推测法</p><p>4.测试评审</p></blockquote><a id="more"></a><h1 id="测试用例设计方法—场景法"><a href="#测试用例设计方法—场景法" class="headerlink" title="测试用例设计方法—场景法"></a>测试用例设计方法—场景法</h1><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>场景法就是模拟用户操作软件时的场景，主要用于测试系统的业务流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当拿到一个测试任务时，我们并不是先关注某个控件的边界值、等价类是否满足要求，</span><br><span class="line">而是先要关注它的主要功能和业务流程是否正确实现，这就需要使用场景法来完成测试。</span><br><span class="line"></span><br><span class="line">当业务流程测试没有问题，也就是该软件的主要功能没有问题时，我们再重点从边界值、等价类等方面对控件进行测试</span><br></pre></td></tr></table></figure><p>在冒烟测试时也主要采用场景法进行测试</p><ul><li>为什么引入场景法</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/37.png" alt="img"></p><ul><li><p>场景法的定义</p><p>场景法中两个重要的概念</p><p>基本流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按照正确的业务流程来实现的一条操作路径（模拟正确的操作流程）</span><br></pre></td></tr></table></figure><p>备选流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导致程序出现错误的操作流程（模拟错误的操作流程）</span><br><span class="line">用例场景是用来描述流经用例路径的过程，这个过程从开始到结束遍历用例中所有基本流和备选流。</span><br></pre></td></tr></table></figure></li><li><p>场景法相关概念</p></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/38.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/39.png" alt="img"></p><ul><li>场景法测试用例</li></ul><h2 id="场景法案例"><a href="#场景法案例" class="headerlink" title="场景法案例"></a>场景法案例</h2><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/41.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/42.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/43.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/44.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/45.png" alt="img"></p><h1 id="测试用例设计方法—流程图法"><a href="#测试用例设计方法—流程图法" class="headerlink" title="测试用例设计方法—流程图法"></a>测试用例设计方法—流程图法</h1><h2 id="流程图法"><a href="#流程图法" class="headerlink" title="流程图法"></a>流程图法</h2><p>流程分析法主要是针对测试场景类型属于流程测试场景的测试项下的测试子项进行设计。</p><ul><li>步骤</li></ul><p>第一步：详细了解需求；</p><p>第二步：根据需求说明或界面原型，找出业务流程的各个页面以及各页面之间的流转关系；</p><p><em>第三步：画出业务流程（产品经理使用Axure软件制作）</em>；</p><p>第四步：写用例，覆盖所有的路径分支。</p><h2 id="案例—使用ATM机取款"><a href="#案例—使用ATM机取款" class="headerlink" title="案例—使用ATM机取款"></a>案例—使用ATM机取款</h2><p>一、详细了解需求；</p><p>二、找出业务流程的各个页面以及各页面之间的流转关系；‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、用户向ATM取款机中插入银行卡……</span><br><span class="line">2、用户输入银行卡密码……</span><br><span class="line">3、用户输入取款金额……</span><br><span class="line">4、系统同步银行主机，点钞票，输出给用户并减去用户卡中相应数目的存款金额……</span><br><span class="line">5、用户取款，银行卡退卡……</span><br><span class="line">6、……</span><br></pre></td></tr></table></figure><p>三、画图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ATM机取款正常流程</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/46.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作流程</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/47.png" alt="img"></p><h1 id="测试用例设计方法—错误推测法"><a href="#测试用例设计方法—错误推测法" class="headerlink" title="测试用例设计方法—错误推测法"></a>测试用例设计方法—错误推测法</h1><h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>错误推测法是指利用直觉和经验猜测出出错的可能类型，有针对性列举出程序中所有可能的错误和容易发生错误的情况，它是测试经验丰富的测试人员喜欢使用的一种测试用例设计方法。</p><ul><li><p>基本思想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本思想是列举出可能犯的错误或错误易发生的清单，然后根据清单编写测试用例；  </span><br><span class="line">这种方法很大程度上是凭经验进行的，</span><br><span class="line">即凭人们对过去所作测试结果的分析，对所揭示缺陷的规律性作直觉的推测来发现缺陷。</span><br></pre></td></tr></table></figure></li><li><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">项目紧任务急、时间不够，这时就不要按部就班的测试了，</span><br><span class="line">根据之前项目的经验，找到之前出错过的类似模块进行重点测试；</span><br><span class="line">  </span><br><span class="line">所有正常测试结束后，通过错误推断法再测试一些之前出过问题的模块。</span><br></pre></td></tr></table></figure></li></ul><p>要素共有三点，分别为：经验、知识、直觉。关于如何使用的问题，我们提炼出两点：</p><p>　　1. 列举出程序中所有可能有的错误和容易发生错误的特殊情况； 　　2. 根据他们选择测试用例。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li><p>针对删除操作</p><p>1.选择需要删除的数据字段。有时候系统会根据ID来删除，有时候系统会根据名称来删除，测试的时候应该多注意，一般要求按照ID来删除，因为根据名称来删除，名称可能会存在重名问题</p><p>2.应该限制重复删除。具体操作：利用网络传输以及服务器的延迟，多次单击“删除”按钮，经常在数据库中发现重复提交的数据</p><p>3.当删除的数据还有文件时，需要去验证存在数据库中的数据，以及硬盘下的文件是否都被同时删除</p><p>4.当数据被删除成功或者失败后，要有响应的信息提示</p></li><li><p>针对页面操作</p><p>1.页面链接检查：每一个链接是否都有对应的页面，并且页面之间切换正确</p><p>2.相关性检查：删除/增加一项会不会对其他项产生影响，如果产生影响，这些影响是否都正确</p><p>3.检查按钮的功能是否正确：如增、删、改、查等功能是否正确</p><p>4.重复提交表单：一条已经成功提交的记录，用IE回退后再提交，看看系统是否做了处理</p><p>5.多次IE回退：检查多次使用IE回退的情况，在有回退的地方，回退，回到原来页面，再回退，重复多次，看是否出错</p><p>6.快捷键检查：是否支持常用快捷键，如Ctrl+C、Ctrl+V、Backspace等，对一些不允许输入信息的字段，如选人、选日期对快捷方式是否也做了限制</p><p>7.回车键检查：在输入结束后直接回车键，看系统处理如何，能否报错</p><p>8.上传下载文件检查：上传下载文件的功能是否实现，上传文件是否能打开，对上传文件的格式有何规定，系统是否有解释信息，并检查系统是否能否做到</p><p>9.其他验证：在页面上图片的大小不宜太大，需要第三方软件支持时，应该给出必要的信息，比如需要jre的支持，但用户机器还没有安装jre，那么此时在页面上应该有显著的标志来提醒用户进行安装</p></li></ul><h1 id="测试用例设计方法-小结"><a href="#测试用例设计方法-小结" class="headerlink" title="测试用例设计方法-小结"></a>测试用例设计方法-小结</h1><h2 id="通常在确定测试方法时，有以下几条参考原则："><a href="#通常在确定测试方法时，有以下几条参考原则：" class="headerlink" title="通常在确定测试方法时，有以下几条参考原则："></a>通常在确定测试方法时，有以下几条参考原则：</h2><p>（1）拿到一个测试任务时，先关注它的主要功能和业务流程、业务逻辑是否正确实现，考虑使用场景法。</p><p>（2）需要输入数据的地方，考虑采用等价类划分法，包括输入条件和输出条件的等价划分，将无限测试变成有限测试。</p><p>（3）在任何情况下都必须采用边界值分析法。这种方法设计出的测试用例发现程序错误的能力最强。</p><p>（4）如果程序的功能说明中含有输入条件的组合情况，则一开始就应考虑选用因果图和判定表法。</p><p>（5）对于参数配置类的软件，需要考虑参数之间的组合情况，考虑使用正交排列法选择较少的组合方式（最少的测试用例获得最大的的测试覆盖率）。</p><p>（6）对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度。如果没有达到要求的覆盖标准，则应当再补充更多的测试用例。</p><p>（7）采用错误推断法再追加测试用例——依靠测试工程师的经验和智慧。</p><h2 id="测试用例的评审"><a href="#测试用例的评审" class="headerlink" title="测试用例的评审"></a>测试用例的评审</h2><ul><li>同行评审</li></ul><p>测试用例的检查方式有很多，同行评审是其中最敏捷的一种。 “个体和交互比过程和工具更有价值”，这强调了测试用例设计者之间的思想碰撞，通过探讨、协作来完成测试用例的设计。</p><ul><li>用户评审</li></ul><p>“顾客的协作比合同谈判更有价值”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果测试是对产品的批判，则顾客应该指最终用户或顾客代表（在内部可以是市场调查人员或相关领域专家）；</span><br><span class="line">如果测试被定义为对开发提供帮助和支持，那么顾客就是程序员。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论02</title>
      <link href="/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA02/"/>
      <url>/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA02/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h1><blockquote><p>1.等价类划分法</p><p>2.边界值法</p><p>3.判定表法</p><p>4.因果图法</p></blockquote><a id="more"></a><h2 id="用例的设计方法"><a href="#用例的设计方法" class="headerlink" title="用例的设计方法"></a>用例的设计方法</h2><p>我们做为测试人员最核心的基本的工作就是根据业务来书写测试用例完成测试。</p><p>但是测试用例的书写是有相应的设计方法的( 有套路 )</p><p>常用的用例设计方法：划分等价类法 、边界值法、判定表法、正交实验法，还有因果图法、场景法、状态迁移法、错误推断法………</p><ul><li>案例</li></ul><p>需求：一个加法计算器，允许输入的数值范围为[1,100]。</p><p>如何测试？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算两个1---100之间整数的和:</span><br><span class="line">穷举测试：</span><br><span class="line">1+2=3  1+3=4  1+4=5  1+5=6  ······  1+100=101</span><br><span class="line">100+1=101  100+2=102   100+3=103  ······   100+100=200</span><br></pre></td></tr></table></figure><h2 id="1、-等价类划分法"><a href="#1、-等价类划分法" class="headerlink" title="1、 等价类划分法"></a>1、 等价类划分法</h2><ul><li>等价类划分是一种典型的黑盒测试设计方法，使用该方法主要对测试项进行测试规格分析，得到用例，而不用对系统内部处理进行深入了解，它也是目前测试用例设计过程中使用最普遍的一种方法，采用等价类划分，是将系统的输入内容划分为若干部分，然后对每个部分选取少数代表性数据进行测试，这样可以避免穷举法产生的大量用例</li><li>定义:等价类是指某个输入内容的所有数据的集合，将所有数据集合理划分为若干等价类，在每个等价类中取一个数据作为测试的输入数据。这样就可以用少量具有代表性的测试数据取得较好的测试效果</li><li>等价类划分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、有效等价类:是指对于系统的规格说明来说是合理的，有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能或者性能要求</span><br><span class="line">2、无效等价类:是指对于系统的规格说明来说是不合理或者无意义的输入数据所构成的集合</span><br><span class="line">注意：设计测试用例时，要同时考虑这两种等价类，因为软件不仅要能接收合理的数据，也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性</span><br></pre></td></tr></table></figure><ul><li><p>案例</p></li><li><p>计算两个1-100之间整数的和</p><h3 id="专业分析设计步骤："><a href="#专业分析设计步骤：" class="headerlink" title="专业分析设计步骤："></a>专业分析设计步骤：</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.明确需求----&gt;如果是文字描述，先将文字描述转为图形</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/119.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.确定界面包含多少个功能</span><br><span class="line">3.针对每个功能确定有多少个输入</span><br><span class="line">4.确定每个输入的规则:</span><br><span class="line">    类型---&gt;数字</span><br><span class="line">    长度----&gt;无</span><br><span class="line">    取值范围---&gt;[1-100]</span><br><span class="line">    是否为空---&gt;否</span><br><span class="line">    是否重复---&gt;是</span><br><span class="line">    组成规则----&gt;无</span><br><span class="line">5.针对每个输入规则构造测试数据,形成等价类数据表</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/120.png" alt="img"></p><h3 id="2、等价类操作步骤"><a href="#2、等价类操作步骤" class="headerlink" title="2、等价类操作步骤"></a>2、等价类操作步骤</h3><ul><li>1、明确需求（如果是文字，转化为图形）</li><li>2、明确界面包含功能个数</li><li>3、针对每一个功能，明确输入的个数</li><li>4、确定每个输入的规则（类型、长度、取值范围、是否可以为空、是否可以重复、组成规则）</li><li>5、针对每一个输入规则构造测试数据</li><li><p>6、编写测试用例</p></li><li><p>需求练习1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQ账号： 6---10位自然数</span><br></pre></td></tr></table></figure></li><li><p>需求练习2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现有一个档案管理系统，容许用户通过输入年月对档案文件进行检索，系统对查询条件年月的输入限定为1990年1月~2049年12月，并规定：</span><br><span class="line">  日期由6位数字字符组成，前四位表示年，后两位表示月。</span><br><span class="line">现用等价类划分法设计测试用例，来测试程序的“日期检查功能”。</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、等价类划分总结"><a href="#3、等价类划分总结" class="headerlink" title="3、等价类划分总结"></a>3、等价类划分总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">规则：</span><br><span class="line">1.一个有效数据的测试用例尽可能包含最多有效等价类</span><br><span class="line">2.一个无效数据的测试数据只能包含一个无效等价类</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">    1.简单、高效</span><br><span class="line">    2.快速评估测试用例的数量（有效测试用例数+无效测试用例数）</span><br><span class="line">    3不用熟悉业务可快速设计测试用例</span><br><span class="line">缺点：</span><br><span class="line">    1.只考虑了独立输入的有效和无效，没有考虑输入之间的组合</span><br><span class="line">    2.数据随机选取，不一定发现Bug</span><br><span class="line"></span><br><span class="line">适用范围：只要存在输入的功能</span><br></pre></td></tr></table></figure><h1 id="测试用例设计方法—边界值法"><a href="#测试用例设计方法—边界值法" class="headerlink" title="测试用例设计方法—边界值法"></a>测试用例设计方法—边界值法</h1><h3 id="1-什么是边界值分析法"><a href="#1-什么是边界值分析法" class="headerlink" title="1.什么是边界值分析法"></a>1.什么是边界值分析法</h3><ul><li>边界值分析也是一种黑盒测试方法，是对等价类划分法的一种补充，由长期的测试工作经验得知，大量的错误是发生在输入或者输出的边界上。因此针对各种边界情况设计测试用例，可以查出更多的错误。</li><li>边界分析方法的理论基础，是假定大多数的错误是发生在各种输入条件的边界上，如果在边界附件的取值不会导致程序出错，那么其他的取值导致程序错误的可能性也很小</li><li>边界值分析使用的条件： 输入内容明确了取值范围、或者规定了值得个数</li></ul><p>思考：输入一个大于0小于100的整数，边界值在哪里？</p><ul><li><p>边值点定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、上点：边界上的点，如果域的边界是封闭的，上点就在域范围内，如果域的边界是开放的，上点在域范围外。</span><br><span class="line">2、离点：就是离上点最近的一个点，如果域的边界是封闭的，离点就在域范围外，如果域的边界是开放的，离点就在域范围内</span><br><span class="line">3、内点：顾名思义，就是在域范围内的任意一个点</span><br></pre></td></tr></table></figure></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/122.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上点、离点的确定和这个域的边界是开放还是封闭有关，不论边界是开放还是封闭，上点和离点总有一个在域内，另外一个在域外</span><br><span class="line">假设a是整数，a的边界描述是a大于0，是开放的，那么上点是0，离点是1，如果边界描述的是a&gt;=0，是封闭的，上点仍然是0，离点是-1</span><br></pre></td></tr></table></figure><ul><li>案例</li><li>计算两个1-100之间整数的和</li></ul><h3 id="2-专业分析设计步骤："><a href="#2-专业分析设计步骤：" class="headerlink" title="2.专业分析设计步骤："></a>2.专业分析设计步骤：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.明确需求----&gt;如果是文字描述，先将文字描述转为图形</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/119.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.确定界面包含多少个功能</span><br><span class="line">3.针对每个功能确定有多少个输入</span><br><span class="line">4.确定每个输入的规则:</span><br><span class="line">    类型---&gt;数字</span><br><span class="line">    长度----&gt;无</span><br><span class="line">    取值范围---&gt;[1-100]</span><br><span class="line">    是否为空---&gt;否</span><br><span class="line">    是否重复---&gt;是</span><br><span class="line">    组成规则----&gt;无</span><br><span class="line">5.针对每个输入规则构造测试数据,形成等价类数据表,追加边界数据（上点、离点）</span><br></pre></td></tr></table></figure><ul><li><p>需求练习1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQ账号： 6---10位自然数</span><br></pre></td></tr></table></figure></li><li><p>需求练习2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现有一个档案管理系统，容许用户通过输入年月对档案文件进行检索，系统对查询条件年月的输入限定为1990年1月~2049年12月，并规定：</span><br><span class="line">  日期由6位数字字符组成，前四位表示年，后两位表示月。</span><br><span class="line">现用等价类划分法设计测试用例，来测试程序的“日期检查功能”。</span><br></pre></td></tr></table></figure></li><li><p>需求练习3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对下图的用户名和密码写出所有的边界值</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/123.png" alt="img"></p></li></ul><h3 id="3-边界值法总结"><a href="#3-边界值法总结" class="headerlink" title="3.边界值法总结"></a>3.边界值法总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">1.边界上的缺陷更容易被发现</span><br><span class="line">2.不用熟悉业务可快速设计测试用例</span><br><span class="line">缺点：</span><br><span class="line">1.存在边界时才能使用</span><br><span class="line">使用范围：</span><br><span class="line">1.有输入参数，且输入类型或范围长度有边界时</span><br><span class="line">2.和等价类一起使用</span><br></pre></td></tr></table></figure><h1 id="测试用例设计方法—判定表法"><a href="#测试用例设计方法—判定表法" class="headerlink" title="测试用例设计方法—判定表法"></a>测试用例设计方法—判定表法</h1><h3 id="1-什么是判定表法"><a href="#1-什么是判定表法" class="headerlink" title="1.什么是判定表法"></a>1.什么是判定表法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">判定表示分析和表达多种输入条件下系统执行不同动作的工具。</span><br><span class="line">在程序设计发展初期，判定表就已经被当做编写程序的辅助工具了，它可以把</span><br><span class="line">复杂的逻辑关系和多种条件组合的情况表达的既具体又明确</span><br><span class="line"></span><br><span class="line">判断表通常由四个部分组成，如下图：</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/124.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.条件桩：列出了系统的所有输入，列出的输入次序无关紧要</span><br><span class="line">2.动作桩：列出了系统可能采取的操作，这些操作的排列顺序没有约束</span><br><span class="line">3.条件项：列出针对它左列输入的取值，在所有可能情况下的真假值</span><br><span class="line">4.动作项：列出在输入项的各种取值情况下应该采取的动作</span><br><span class="line">5.动作项和条件项一起，指出了在条件项的各种取值情况下应该采取的动作，在判定表中贯穿条件项和动作项的一列就是</span><br><span class="line">  一条规则，可以针对每个合法输入组合的规则设计用例进行测试</span><br><span class="line"></span><br><span class="line">对于判定表可以进行化简操作，化简工作是以合并相似规则为目标的。如果表中有两条或者多条规则具有相同的动作，</span><br><span class="line">并且其条件项之间存在极为相似的关系（只有一个不同时，说明不管该输入取任何值，输出都是一样的），我们可以</span><br><span class="line">将其合并，如下图</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/126.png" alt="img"></p><p><img src="../assets/126.png" alt="img"></p><ul><li><p>案例</p><ul><li>举例：若用户欠费或者停机，则不允许主被叫，表示为判定表如下：</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/127.png" alt="img"></p></li></ul><p>针对该判定表可以化简，第1列数据和第2列数据的动作完全相同，条件桩中只有条件2的取值不同，因此 可将第1/2列数据合并起来，化简后结果如下，每列数据就是一条测试用例，这样一共是3条测试用例</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/128.png" alt="img"></p><h3 id="2-判定表法设计步骤"><a href="#2-判定表法设计步骤" class="headerlink" title="2.判定表法设计步骤"></a>2.判定表法设计步骤</h3><ul><li>1、明确条件桩</li><li>2、明确动作桩</li><li>3、对条件桩进行全组合</li><li>4、明确每个组合对应的动作桩</li><li><p>5、设计测试用例，每列数据对应一条测试用例</p></li><li><p>需求练习1:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">订购单的检查，如果金额大于500元，又未过期，则发出批准单和提货单；</span><br><span class="line">如果金额大于500元，但过期了，则不发批准单；如果金额小于等于500元</span><br><span class="line">则不论是否过期都发出批准单和提货单，在过期的情况下还需要发出通知单。</span><br><span class="line"></span><br><span class="line">    请用判定表的方法对测试用例 进行设计</span><br></pre></td></tr></table></figure><ul><li>需求练习2:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果想对文件进行修改，输入的第一列字符必须是A/B,第二例字符必须是一个数字，如果</span><br><span class="line">第一列字符不正确，则给出信息L，如果第二列字符不正确，则给出信息M</span><br></pre></td></tr></table></figure><h3 id="3-判定表法总结："><a href="#3-判定表法总结：" class="headerlink" title="3.判定表法总结："></a>3.判定表法总结：</h3><p>\<figure class="highlight plain"><figcaption><span>1.充分考虑了输入条件间的组合，对组合情况覆盖充分</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>缺点：<br>1.条件过多时，造成判定表的规模庞大</p><p>适用范围：<br>1.输入之间有逻辑关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 测试用例设计方法---因果图法法</span><br><span class="line"></span><br><span class="line">### 1.什么是因果图法</span><br></pre></td></tr></table></figure></p><p>因果图用于描述系统的输入输出、以及输入和输出之间的因果关系、输入和输入之间的约束关系。<br>因果图和判定表两种方法在实际使用中结合紧密，往往同时使用，对于一些简单的系统或者输入<br>与输出已经非常明确的系统，判定表可以单独使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 因果关系</span><br></pre></td></tr></table></figure></p><pre><code>拿破仑说：“  失一个钉子，坏了一只蹄铁；   坏了一只蹄铁，折了一匹战马；   折了一匹战马，伤了一位骑士；  伤了一位骑士，输了一场战斗；  输了一场战斗，亡了一个帝国。””</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  **这就是因果关系**</span><br><span class="line"></span><br><span class="line">- 实际测试工作中因果关系是描述的以下关系</span><br><span class="line"></span><br><span class="line">  1. 输入与输出之间的因果关系---&gt;因果图的表示中输入与输出间的因果关系有四种</span><br><span class="line"></span><br><span class="line">     1) 恒等关系：当输入内容时，会产生对应输出，当不输入或者输入不发生时，不会有输出</span><br><span class="line"></span><br><span class="line">     2）非关系：与恒等关系相反</span><br><span class="line"></span><br><span class="line">     3）或者关系：输入的内容有多个时，只要一个输入发生，就会有输出</span><br><span class="line"></span><br><span class="line">     4）与关系：输入的内容有多个时，只有所有输入都发生时，才会有对应输出</span><br><span class="line"></span><br><span class="line">     用图形表示以上四种关系如下：</span><br><span class="line"></span><br><span class="line">  ![img](file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/129.png)</span><br><span class="line"></span><br><span class="line">  1. 输入与输入之间的约束关系-----&gt;因果图的表示中输入与输入之间的约束关系也有四种</span><br><span class="line"></span><br><span class="line">     1）异：所有输入中最多一个输入发生</span><br><span class="line"></span><br><span class="line">     2）或：所有输入中至少一个输入发生</span><br><span class="line"></span><br><span class="line">     3）唯一：所有输入中有且只有一个输入条件发生</span><br><span class="line"></span><br><span class="line">     4）要求：所有输入中只要有一个输入发生，则其他输入也会发生</span><br><span class="line"></span><br><span class="line">     用图形表示以上四种关系如下：</span><br><span class="line"></span><br><span class="line">  ![img](file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/130.png)</span><br><span class="line"></span><br><span class="line">### 2.使用因果图法设计测试用例</span><br><span class="line"></span><br><span class="line">- 步骤1：标识输入和输出</span><br></pre></td></tr></table></figure><pre><code>分析测试内容，找出其中的输入和输出并标识出来，其中要注意以下几点：    1）输入只涉及2种取值的，可以只作为一个标识出来，如果输入项涉及多种取值的，每个取值需要作为一个输入标识出来    2）标识可以自己确定，但是输入和输出需要独立的标识</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 步骤2：画出因果图</span><br></pre></td></tr></table></figure><pre><code>分析输入和输出之间的因果关系，输入和输入之间的约束关系，根据这些关系，画出因果图</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 步骤3：将因果图转换为判定表</span><br></pre></td></tr></table></figure><pre><code>1.将输入和输出分别写入条件桩和动作桩，并在条件项中填写输入的组合2.根据因果图中的输入条件约束关系，对不可能出现的输入组合，在动作项上作出删除标记3.根据因果图中的输入与输出的因果关系，在动作项上标出对应的动作结果</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 步骤4：生产测试用例</span><br><span class="line"></span><br><span class="line">### 3.因果图设计用例案例</span><br></pre></td></tr></table></figure><p>根据上面的测试基本步骤，对下面的例子进行因果图测试<br>        如想对文件进行修改，输入的第一列字符必须是A或者B，第二列字符必须是一个数字，如果 第一列字符不正确<br>        则给出信息L，如果第二列字符不正确，则给出信息M<br><code>`</code></p><ul><li>使用因果图对该题分析步骤：</li></ul><p>第一步：标识输入和输出—–&gt;分析以上需求后，可以明确的把原因和结果分开（或者说输入和输出） 原因： 结果 1.第一列字符为A 21.修改文件 2.第一列字符为B 22.给出信息L 3.第二列字符为一个数字 23.给出信息M</p><p>第二步：画因果图—-&gt;需求中很明确的给出原因和结果之间的对应关系，将原因和结果根据他们之间的对应关系用逻辑符号连接起来，如下图所示,左边表示原因，右边表示结果，编号11的节点是导出结果的进一步原因</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/131.png" alt="img"></p><p>第三步：考虑到输入1和输入2不可能同时为Y（即第一列不能同时为A和B），我们在图上需要对其添加E约束，这样就有了具有约束的因果图，如下图所示</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/132.png" alt="img"></p><p>第四步：把因果图转换成判定表如下：</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/133.png" alt="img">由于原因1和原因2不可能同时为Y，故第1、2属于不可能发生的组合，所以编写测试用例时可以不用考虑</p><p>第五步：编写测试用例即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论01</title>
      <link href="/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA01/"/>
      <url>/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.软件测试的基础理论</p><p>2.软件质量</p><p>3.常见软件架构</p><p>4.软件开发过程模型</p><p>5.测试模型</p><p>6.软件测试分类</p><p>7.测试用例</p></blockquote><a id="more"></a><h1 id="软件测试的基础理论"><a href="#软件测试的基础理论" class="headerlink" title="软件测试的基础理论"></a>软件测试的基础理论</h1><h2 id="软件测试的目的："><a href="#软件测试的目的：" class="headerlink" title="软件测试的目的："></a>软件测试的目的：</h2><p>是想以最少的人力，物力和时间找出软件中潜在的各种错误与缺陷，通过修正各种错误和缺陷提高软件质量， 回避软件发布后由于潜在的软件缺陷和错误造成的隐患以及带来的商业风险。</p><p>简单的说，软件测试是为了找到软件中隐藏起来的bug，修复之后避免商业风险。</p><h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>使用人工和自动手段来运行或测试某个系统的过程，其目的在于</p><p><strong>检验它是否满足规定的需求</strong>或<strong>弄清楚预期结果与实际结果之间的差别</strong>。</p><h2 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h2><h4 id="软件测试的原则："><a href="#软件测试的原则：" class="headerlink" title="软件测试的原则："></a>软件测试的原则：</h4><ol><li>测试证明软件存在缺陷：我们的测试工作只能证明当前软件是有缺陷而不能证明它没有缺陷</li><li>不能执行穷尽测试：具体的测试操作不可能将所有的情况都一一逻列出来，所以测试工作肯定有终止的时候</li><li>测试应当尽早介入：一般不要在开发完成之后才执行测试，这样不利于缺陷的尽早发现</li><li>缺陷存在群集现象：对于一款软件来说核心的功能只占20%，所以在测试的时候我们会花更多的时间去专门测试这些功能，因此它里面缺陷暴露的可能就会更大一些，我们就称之为缺陷群集</li><li>测试操作依赖于某于测试环境</li><li>杀虫剂现象：不要过多使用同一条测试案例来对软件进行问题查找 ，因为软件会产生“抗 性”</li><li>不存在缺陷的谬论：任何的软件不可能是完美的。</li></ol><h2 id="软件测试的基本流程"><a href="#软件测试的基本流程" class="headerlink" title="软件测试的基本流程"></a>软件测试的基本流程</h2><h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h4><ul><li>这个步骤的核心就是理清楚我们需要测试的点是什么。</li><li>需求的来源：需求规格说明书 、同类产品分析、API文档、个人经验</li></ul><h4 id="2-设计用例"><a href="#2-设计用例" class="headerlink" title="2. 设计用例"></a>2. 设计用例</h4><ul><li>用例：具体的我们就可以理解为是用户对于软件使用的一个完整操作流程，里面会包括测试什么 和 怎么样去测 （ …… ）</li></ul><h4 id="3-评审用例-将我们设计好的用例进行适当的删除或者增。"><a href="#3-评审用例-将我们设计好的用例进行适当的删除或者增。" class="headerlink" title="3. 评审用例: 将我们设计好的用例进行适当的删除或者增。"></a>3. 评审用例: 将我们设计好的用例进行适当的删除或者增。</h4><h4 id="4-配置环境"><a href="#4-配置环境" class="headerlink" title="4. 配置环境"></a>4. 配置环境</h4><ul><li>所谓的环境指的就是软件运行需要依赖的环境。要求测试人员都需要具备配环境的能力。</li><li>这里的环境我们一般包括四个方法：操作系统 数据库 服务器软件 当前软件底层代码执行所需要的环境( python java c php js html……【对于环境配置来说网上有N种一键式集成开发环境包】 )</li></ul><h4 id="5-执行用例："><a href="#5-执行用例：" class="headerlink" title="5. 执行用例："></a>5. 执行用例：</h4><ul><li>在执行用例之初我们会做一个冒烟测试。所谓的冒烟测试指的就是在最快的时间内对软件的最基本功能和整体流程进行验证。</li><li>如果冒烟测试通过验让那么我们才会具体详细的展示全面测试，如果不通过那么就会直接返给开发重新等待提交下一个版本。</li></ul><h4 id="6-缺陷跟踪和回归测试"><a href="#6-缺陷跟踪和回归测试" class="headerlink" title="6. 缺陷跟踪和回归测试"></a>6. 缺陷跟踪和回归测试</h4><ul><li>当我们通过测试操作发现一个缺陷之后我们将它交给相应的人员进行处理，此后我们需要对它进行跟踪，当修复完成之后我们还需要对这个结果行验证测试，称之为回归测试</li></ul><h4 id="7-输出测试报告"><a href="#7-输出测试报告" class="headerlink" title="7. 输出测试报告"></a>7. 输出测试报告</h4><ul><li>将整个测试过程当中产生的相关数据通过可视化的格式输出方便别人查看</li></ul><h4 id="8-测试结束"><a href="#8-测试结束" class="headerlink" title="8. 测试结束"></a>8. 测试结束</h4><ul><li>将整个测试流程中产生的文档或者数据进行整理和保存</li></ul><h1 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h1><h4 id="所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由-ISO-国际标准化组织-标准制定组织规定了一套质量标准，其中有六大特性"><a href="#所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由-ISO-国际标准化组织-标准制定组织规定了一套质量标准，其中有六大特性" class="headerlink" title="所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由 ISO(国际标准化组织) 标准制定组织规定了一套质量标准，其中有六大特性"></a>所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由 ISO(国际标准化组织) 标准制定组织规定了一套质量标准，其中有六大特性</h4><ul><li>功能性：软件具有满足用户显示或者隐式功能的能力。</li><li>可靠性：软件实现了自已规定的功能</li><li>易用性：软件在使用上容易上手 易于学习 吸引用户的能力</li><li>效率性：类似于软件的性能考虑</li><li>可维护性：在规定条件和规定时间内使用规定的工具修改规定功能的能力。</li><li>可移植性：要求软件具有可以从一个平台移动到另外一个平台上使用的能力</li></ul><h1 id="常见软件架构"><a href="#常见软件架构" class="headerlink" title="常见软件架构"></a>常见软件架构</h1><h4 id="当前市面上流行的二种架构分别是-B-S-C-S-【-browser-clientsr-server-】"><a href="#当前市面上流行的二种架构分别是-B-S-C-S-【-browser-clientsr-server-】" class="headerlink" title="当前市面上流行的二种架构分别是 B/S C/S 【 browser clientsr server 】"></a>当前市面上流行的二种架构分别是 B/S C/S 【 browser clientsr server 】</h4><ul><li>Bs:就是浏览器—服务器模型 cs: 就是客户端—服务器模型</li></ul><h4 id="bs-和-cs-比较"><a href="#bs-和-cs-比较" class="headerlink" title="bs 和 cs 比较"></a>bs 和 cs 比较</h4><ul><li>标准：对于 BS架构来说无论是浏览器还是服务器都是现成的软件供我们去使用，而CS架构中的客户端一般都由开发者自定义生成，所以相对来说 BS开发要标准一些。</li><li>效率：因为BS架构当中所有的数据处理操作都发生服务器端而CS 的客户端是可以来分担一些服务器数据存放的，因此相对来说 CS 的处理效率会高一些</li><li>升级：BS架构只需要将服务器进行更新那么前台页面会自动的刷新而CS架构如果想要升级就必须将二端都重新制定，下载安装才可以使用。</li><li>安全性：相对于CS架构来说 BS 的安全性会低一些。</li><li>开发成本：因为浏览器不需要我们开发，所以我们认为 CS的开发成本相对较高。</li></ul><p>注：常见主流浏览器有火狐Firefox、谷歌Chrome、IE浏览器、Safari浏览器、opera欧朋浏览器</p><h1 id="软件开发过程模型"><a href="#软件开发过程模型" class="headerlink" title="软件开发过程模型"></a>软件开发过程模型</h1><h2 id="什么是开发过程模型"><a href="#什么是开发过程模型" class="headerlink" title="什么是开发过程模型"></a>什么是开发过程模型</h2><ul><li>在软件开发的几十年实践中，人们总结了很多软件开发模型用来描述和表示一个复杂的开发过程，如：瀑布模型、快速原型模型等</li><li>软件测试与软件的开发模式有着紧密的联系，作为一名测试人员，应该充分理解软件的开发模式，一遍找准自己在其中的位置，从而发挥自身的价值。</li></ul><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)、是线性模型的一种，在所有模型中占有重要地位，是所有其他模型的一个基础</span><br><span class="line"></span><br><span class="line">(2)、每一个阶段执行一次，按线性顺序进行软件开发。</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/2.png" alt="img"></p><ul><li>注意: 测试的切入点：</li><li>测试阶段处于软件实现后，必须在代码完成后留出足够的时间给测试活动，否则将导致测试不充分，很多问题到项目后期才暴露。</li></ul><h4 id="瀑布模型的优缺点"><a href="#瀑布模型的优缺点" class="headerlink" title="瀑布模型的优缺点"></a>瀑布模型的优缺点</h4><p>瀑布模式<strong>所有一切都有完整细致的说明</strong>。当软件提交到测试小组时，所有细节都已确定并有文档记录，而且实现在软件之中。由此，测试小组得以制定精确的计划和进度。 然而，这个优点也带来一个巨大的缺点。因为<strong>测试仅在最后进行</strong>，所以一些根本性问题可能出现在早期，但是直到准备发布产品时才可能发现。</p><ul><li><p>简单的总结下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">(1)、开发的各个阶段比较清晰。</span><br><span class="line">(2)、当前一阶段完成后，只需关注后续阶段。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缺点：</span><br><span class="line">(1) 依赖于早期的需求调查，不适应需求的变化。</span><br><span class="line">(2) 风险往往延至后期才显露，失去及早纠正的机会。</span><br><span class="line">(3) 前面未发现的错误会传递并扩散到后面的阶段，可能导致项目失败。</span><br></pre></td></tr></table></figure><p>采用瀑布模式的项目从最初的构思到最终产品要经过一系列步骤。每一个步骤结束时，项目小组组织审查，并决定是否进入下一步。如果项目未准备好进入下一步，就停滞下来直到准备好。 关于瀑布模式有三点需要强调：</p><p>瀑布模式非常【强调产品的定义】。注意，开发或者代码编制阶段只是其中单独的一块。 瀑布模式【各步骤是分立的、没有交叉】。 瀑布模式【无法回溯】。一旦进入某一步骤，就要完成该步骤的任务，然后才能向下继续—无法回溯。</p></li></ul><h2 id="快速原型模型-了解"><a href="#快速原型模型-了解" class="headerlink" title="快速原型模型(了解)"></a>快速原型模型(了解)</h2><ul><li><p>在开发真实系统之前，构造一个原型，在该原型的基础上，逐渐完成整个系统的开发工作。</p></li><li><p>第一步是建造一个快速原型，实现用户与系统的交互，用户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足用户的要求，开发人员可以确定用户的真正需求是什么。</p></li><li><p>第二步是在第一步的基础上开发出用户满意的软件产品。</p></li><li><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/3.png" alt="img"></p><p>例如，客户需要一个ATM机软件，可以先设计一个仅包含刷卡、密码检测、数据输入和账单打印的原型软件提供给客户，此时还不包括网络处理与数据库存取以及数据应急、故障处理等服务。</p></li></ul><h4 id="快速原型模型的优缺点"><a href="#快速原型模型的优缺点" class="headerlink" title="快速原型模型的优缺点"></a>快速原型模型的优缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">(1)克服瀑布模型的缺点，更好地满足用户的需求并减少由于软件需求不明确带来的项目开发风险。</span><br><span class="line">缺点:</span><br><span class="line">(1)不适合大型系统的开发(适合开发小型的、灵活性高的系统)。</span><br><span class="line">(2)前提要有一个展示型的产品原型，因此在一定程度上可能会限制开发人员的创新。</span><br></pre></td></tr></table></figure><h1 id="软件测试-amp-软件工程"><a href="#软件测试-amp-软件工程" class="headerlink" title="软件测试&amp;软件工程"></a>软件测试&amp;软件工程</h1><p>软件测试与软件工程息息相关，软件测试是软件工程组成中不可或缺的一部分。</p><p>在软件工程、项目管理、质量管理得到规范化应用的企业，软件测试也会进行得比较顺利，软件测试发挥的价值也会更大。</p><p>要关注软件工程、质量管理以及配置管理与软件测试的关系；在不同的开发模式下，如何进行软件测试。</p><h2 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h2><h2 id="什么是测试模型"><a href="#什么是测试模型" class="headerlink" title="什么是测试模型"></a>什么是测试模型</h2><ul><li>随着测试过程的管理和发展，测试人员通过大量的实践，从而总结出了不少测试模型，如常见的V模型，W模型，H模型等。这些模型与开发紧密结合，对测试活动进行了抽象，成为了测试过程管理的重要参考依据。</li></ul><h2 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h2><p>V模型是最具有代表意义的测试模型，最早是由Paul Rook在20世纪80年代后期提出，由英国国家计算机中心文献中发布，旨在改进软件开发的效率和效果；</p><p>V模型推出之前，人们通常把测试过程作为在需求分析、概要设计、详细设计、编码全部完成之后的一个阶段，V模型在这个时候推出，就是为了改变之前行业的普遍认识。</p><p>V模型本身是软件开发中瀑布模型的变种，它反映了测试活动与分析和设计的关系。</p><p>V模型标明了测试过程中本身存在的不同阶段，从左到右，描述了开发过程和测试过程间的阶段对应关系。</p><ul><li>V模型示意图： <img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/5.png" alt="img"></li></ul><h4 id="V模型每个阶段含义"><a href="#V模型每个阶段含义" class="headerlink" title="V模型每个阶段含义"></a>V模型每个阶段含义</h4><ul><li>需求分析：用户需求、业务需求、需求规格说明书</li><li>概要设计：系统架构、模块划分、模块与模块之间的接口。</li><li>详细设计：模块内部实现的逻辑和方法</li><li>编码：实现上面的设计</li><li>单元测试：检测代码的开发是否符合详细设计的要求。</li><li>集成测试：检测此前测试过的各组成部分是否能完好地结合到一起。</li><li>系统测试：拿到产品后，检测一下最基本的功能和业务流程是否能走通，检测产品的安全性和性能等方面的测试</li><li>验收测试：检测产品是否符合最终用户的需求</li></ul><h3 id="V模型的优缺点"><a href="#V模型的优缺点" class="headerlink" title="V模型的优缺点"></a>V模型的优缺点</h3><p>优点:</p><p>(1)测试V模型即包含了底层测试又包含了高层测试；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">底层测试：检验源代码质量的测试，如：单元测试；</span><br><span class="line">高层测试：检验整个系统的需要，如：系统测试；</span><br></pre></td></tr></table></figure><p>(2)V模型清楚地标识出了软件开发的阶段。</p><p>(3)它采用自顶向下逐步求精的方式把整个开发过程分成不同的阶段，每个阶段的工作都很明确，因此便于控制开发过程。</p><p>缺点:</p><p>(1)V模型一大缺点正是它自身的顺序性所导致的。到了测试阶段，程序已经完成，错误已经产生，很多前期的错误一直到测试阶段才发现，甚至无法发现，往往无从修改了。 (2)同时实际的开发过程中，在需求阶段很难把用户的需求完全明确下来，因此，当需求变更时将会导致阶段反复，而且都要重复需求、设计、编码、测试等过程，返工量非常大，模型灵活性比较低。</p><h2 id="认识W模型"><a href="#认识W模型" class="headerlink" title="认识W模型"></a>认识W模型</h2><ul><li>IEEE std1012-1998《软件验证和确认（V&amp;V）》的原则中提出了在软件的需求和设计阶段也应有测试活动，并且提出了相应的原则；</li><li>W模型由Evolutif公司提出：开发一个V，测试一个V，组合的W模型；</li><li>测试伴随着整个软件开发周期，并且测试的对象不仅仅是程序，需求和设计同样要测试。</li><li>W模型示意图 <img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/6.png" alt="img"></li></ul><h3 id="W模型的优缺点"><a href="#W模型的优缺点" class="headerlink" title="W模型的优缺点"></a>W模型的优缺点</h3><p>优点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)开发强调测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求和概要设计同样要测试；</span><br><span class="line">(2)更早地接入测试，可以发现开发初期的缺陷，那么可以用更加低的成本进行缺陷修复。</span><br><span class="line">(3)同样是分阶段的工作，便于控制项目过程。</span><br></pre></td></tr></table></figure><p>缺点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)对于当前很多项目，在执行的过程中根本不产生文档，那么W模型基本无法适用；</span><br><span class="line">(2)使用起来技术复杂度很高，对于需求和设计的测试要求很高，实践起来困难。</span><br></pre></td></tr></table></figure><h2 id="认识H模型（了解）"><a href="#认识H模型（了解）" class="headerlink" title="认识H模型（了解）"></a>认识H模型（了解）</h2><ul><li>H模型诞生背景</li></ul><p>人们发现虽然软件开发中需求、设计、编码等活动被分阶段执行、但是实践中，他们并不是完全串行的，它们之间更多时候是交叉进行的，更多的是迭代执行。 为了解决上面的问题，有专家专门提出了H模型，它将测试活动完全独立出来，形成一个完全独立的流程，同时将测试准备和测试执行也清晰表现出来。</p><h3 id="H模型测试流程"><a href="#H模型测试流程" class="headerlink" title="H模型测试流程"></a>H模型测试流程</h3><p>(1)测试准备:所有测试执行活动的准备；判断是否到测试就绪点； (2)测试就绪点:测试准入准则，即是否可以开始执行测试的条件； (3)测试执行:具体的执行测试的程序。</p><ul><li><p>其他流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体开发中的流程,如：设计流程</span><br></pre></td></tr></table></figure></li><li><p>H模型示意图</p></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/7.png" alt="img"></p><h3 id="H模型优缺点"><a href="#H模型优缺点" class="headerlink" title="H模型优缺点"></a>H模型优缺点</h3><p>优点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)开发的H模型揭示了软件测试除测试执行外，还有很多工作；</span><br><span class="line"></span><br><span class="line">(2)软件测试完全独立，贯穿整个生命周期，且与其他流程并发进行；</span><br><span class="line"></span><br><span class="line">(3)软件测试活动可以尽早准备、尽早执行，具有很强的灵活性；</span><br><span class="line"></span><br><span class="line">(4)软件测试可以根据被测物的不同而分层次、分阶段、分次序的执行，同时也是可以被迭代的。</span><br></pre></td></tr></table></figure><p>缺点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)管理型要求高：由于模型很灵活，必须要定义清晰的规则和管理制度，否则测试过程将非常难以管理和控制；</span><br><span class="line"></span><br><span class="line">(2)技能要求高：H模型要求能够很好的定义每个迭代的规模，不能太大也不能太小；</span><br><span class="line"></span><br><span class="line">(3)测试就绪点分析困难：测试很多时候，你并不知道测试准备到什么时候是合适的，</span><br><span class="line">    就绪点在哪里，就绪点的标准是什么，这就对后续的测试执行的启动带来很大困难；</span><br><span class="line"></span><br><span class="line">(4)对于整个项目组的人员要求非常高：在很好的规范制度下，大家都能高效的工作，否则容易混乱。</span><br><span class="line">    例如：你分了一个小的迭代，但是因为人员技能不足，使得无法有效完成，那么整个项目就会受到很大的干扰。</span><br></pre></td></tr></table></figure><h1 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h1><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/8.png" alt="img"></p><h2 id="按测试阶段分类"><a href="#按测试阶段分类" class="headerlink" title="按测试阶段分类"></a>按测试阶段分类</h2><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>又称模块测试，针对软件设计中的最小单位-程序模块，进行正确性检查的测试工作。单元测试需要从程序内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</li><li>单元定义:C中指一个函数，Java中指一个类，在图形化的软件中，单元一般指一个窗口，1个菜单。</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/9.png" alt="img"></p><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p>又叫组装测试，通常在单元测试的基础上，将所有程序模块进行有序的、递增的测试。重点测试不同模块的接口部分。</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/10.png" alt="img"></p><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul><li>指的是将整个软件系统看为一个整体进行测试，包括对功能、性能、以及软件所运行的软硬件环境进行测试。</li><li>系统测试在系统集成完毕后进行测试，前期主要测试系统的功能是否满足需求，后期主要测试系统运行的性能是否满足需求，以及系统在不同的软硬件环境中的兼容性等。</li></ul><h2 id="按是否查看源代码"><a href="#按是否查看源代码" class="headerlink" title="按是否查看源代码"></a>按是否查看源代码</h2><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><ul><li>又称数据驱动测试，完全不考虑程序内部结构和内部特性，注重于测试软件的功能需求，只关心软件的输入数据和输出数据。</li><li><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/11.png" alt="img"></li></ul><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>指的是把盒子打开，去研究里面的源代码和程序结构。</p><ul><li><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/12.png" alt="img"></li></ul><h4 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h4><p>灰盒测试，是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p><h2 id="详细了解黑盒测试"><a href="#详细了解黑盒测试" class="headerlink" title="详细了解黑盒测试"></a>详细了解黑盒测试</h2><h4 id="黑盒测试的分类"><a href="#黑盒测试的分类" class="headerlink" title="黑盒测试的分类"></a>黑盒测试的分类</h4><ul><li>功能测试</li></ul><blockquote><p>是黑盒测试的一方面，它检查实际软件的功能是否符合用户的需求。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">逻辑功能测试</span><br><span class="line">界面测试</span><br><span class="line">易用性测试</span><br><span class="line">安装测试</span><br><span class="line">兼容性测试</span><br></pre></td></tr></table></figure><ul><li>性能测试</li></ul><blockquote><p>是软件测试的高端领域，性能测试工程师的待遇和白盒测试工程师不相上下，通常我们所说的高级软件测试工程师一般就是指性能测试或是白盒测试工程师。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间性能（事务响应时间等）</span><br><span class="line">空间性能（系统资源消耗）</span><br><span class="line">一般性能测试</span><br><span class="line">稳定性测试</span><br><span class="line">负载测试：通过负载测试来确定在各种工作负载下，系统各项性能指标的变化情况。</span><br><span class="line">压力测试：通过确定一个系统的瓶颈或者刚好不能接受的性能点，来获得系统能够提供的最大服务级别。</span><br></pre></td></tr></table></figure><ul><li>黑盒测试能发现以下几类错误:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">功能不对或功能遗漏。</span><br><span class="line">界面错误。</span><br><span class="line">数据库访问或者处理错误。</span><br><span class="line">性能问题。</span><br><span class="line">黑盒测试的优点:</span><br><span class="line">简单高效</span><br><span class="line">适用于任何项目</span><br><span class="line">黑盒测试的缺点:</span><br><span class="line">介入时间晚</span><br></pre></td></tr></table></figure><h2 id="按是否运行分类"><a href="#按是否运行分类" class="headerlink" title="按是否运行分类"></a>按是否运行分类</h2><h4 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h4><ul><li>指不实际运行被测软件，而只是静态地检查程序代码、界面或文档中可能存在的错误过程。</li></ul><h4 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h4><ul><li>是指实际运行被测程序，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程。</li></ul><h2 id="验收测试（其他分类）"><a href="#验收测试（其他分类）" class="headerlink" title="验收测试（其他分类）"></a>验收测试（其他分类）</h2><ul><li>α测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alpha 是内测版本，即现在所说的CB，此版本表示该软件仅仅是一个初步完成品, </span><br><span class="line">通常只在软件开发者内部交流, 也有很少一部分发布给专业测试人员。</span><br><span class="line">一般而言, 该版本软件的bug 较多, 普通用户最好不要安装。</span><br></pre></td></tr></table></figure><ul><li>β测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Beta是公测版本，是对所有用户开放的测试版本。该版本相对于α 版已有了很大的改进,消除了严重的错误, 但还是存在着一些缺陷,需要经过大规模的发布测试来进一步消除。</span><br><span class="line">这一版本通常由软件公司免费发布, 用户可从相关的站点下载。</span><br><span class="line">通过一些专业爱好者的测试, 将结果反馈给开发者, 开发者们再进行有针对性的修改。该版本也不适合一般用户安装。</span><br></pre></td></tr></table></figure><ul><li>γ测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gamma版本，指的是软件版本正式发行的候选版。</span><br><span class="line">该版本已经相当成熟了, 与即将发行的正式版相差无几, 成为正式发布的候选版本。</span><br></pre></td></tr></table></figure><ul><li>软件正式版本推出之前的几个版本, 需要有人测试一下, 看看是不是有问题。在开发该软件的公司内部的由该公司内部人员测试的称为: Alpha 测试, Alpha 测试主要看有没有功能缺失或系统错误, Alpha 测试完后一般不会有大问题了。然后把软件拿给用户测试,称为: beta 测试, 主要是看用户对软件外观、使用方便等的反应。这么多的测试版一方面为了最终产品尽可能地满足用户的需要, 另一方面也尽量减少了软件中的bug。然后做过一些修改, 成为正式发布的候选版本时, 叫做gamma( 现在叫做RC - Release Candidate) 。</li><li>简单来说，阿尔法测试主要是测试人员在开发环境下的测试，贝塔测试是在实际环境中的测试，或者公司内部人员在模拟真实环境中的测试。</li></ul><h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h2><h4 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。</span><br></pre></td></tr></table></figure><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">软件回归：回归测试是指在发生修改之后重新测试先前的测试以保证修改的正确性</span><br><span class="line">缺陷回归：开发人员修复测试人员提交的缺陷之后测试人员进行回归测试，确认缺陷是否被成功修复</span><br></pre></td></tr></table></figure><h4 id="随机测试-探索性测试"><a href="#随机测试-探索性测试" class="headerlink" title="随机测试(探索性测试)"></a>随机测试(探索性测试)</h4><p>随机测试主要是对被测软件的一些重要功能进行复测，也包括测试那些当前的测试用例没有覆盖到的部分。另外，对于软件更新和新增加的功能要重点测试。重点对一些特殊点情况点、特殊的使用环境、并发性、进行检查。尤其对以前测试发现的重大Bug，进行再次测试，可以结合回归测试一起进行。</p><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><p>QQ我们经常在用，那么如果让我们来测试QQ的登录界面，如何去测试呢？</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/13.png" alt="img"></p><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><p>将软件测试的行为活动，作为一个科学化的组织规划。<br>为实施测试而向被测试系统提供的<strong>输入数据、操作或各种环境设置以及期望结果</strong>的一个特定的集合。<br>解决<strong>要测什么、怎么测和如何衡量</strong>的问题</p><p>元素： 用例编号、用例标题、预置条件、 优先级、详细步骤、输入数据、预期结果、实际结果等</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/14.png" alt="img"></p><h4 id="测试用例编号"><a href="#测试用例编号" class="headerlink" title="测试用例编号"></a>测试用例编号</h4><p>字符和数字组合成的字符串，用例编号应具有唯一性、易识别 没有统一的命名规则，每家企业会有所不同 可以用A-B-C-D的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A：项目名称</span><br><span class="line">B：功能名称</span><br><span class="line">C：测试类型</span><br><span class="line">D：编号</span><br></pre></td></tr></table></figure><p>例：QQ-登录-系统测试-001</p><h4 id="用例的元素"><a href="#用例的元素" class="headerlink" title="用例的元素"></a>用例的元素</h4><ul><li><p>必要元素</p><p>用例标题：说明该条用例测试哪个点，要测什么</p><p>优先级：用来标识当前的用例执行的优先级。</p><p>操作步骤：执行当前测试用例需要经过的操作步骤，需要明确的给出一个步骤的描述，测试用例执行人员可以根据该步骤完成测试用例执行。</p><p>预期结果：当前测试用例的预期输出结果，包括返回值内容，界面的响应结果，输出结果的规则符合度等。</p></li><li><p>非必要元素</p><p>预置条件：执行当前测试用例需要的前提条件，如果这些前提条件不满足，则后面测试步骤无法进行或无法得到预期结果。</p><p>实际结果：在用例设计阶段不写</p><p>设计者：设计测试用例的人</p><p>设计时间：设计的日期</p><p>执行状态：未执行、执行失败、执行通过、未执行完毕、无效的等</p></li></ul><h4 id="测试用例的优缺点"><a href="#测试用例的优缺点" class="headerlink" title="测试用例的优缺点"></a>测试用例的优缺点</h4><p>优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">组织性:避免盲目测试，提高测试效率</span><br><span class="line">功能覆盖：确保客户需要的功能不被遗漏</span><br><span class="line">重复性 ：不同版本软件重复使用 </span><br><span class="line">跟踪 ：统计测试用例，通过和失败的比例，跟踪缺陷多的模块</span><br><span class="line">测试确认 ：高风险程序，确认测试按照计划进行</span><br></pre></td></tr></table></figure><p>缺点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">没有清晰的和简明的规格，测试用例是很难设计的   </span><br><span class="line">测试人员容易被测试用例的规范步骤误导，思维受限  </span><br><span class="line">需求变更后用例难于及时更新，从而影响覆盖率，维护成本加大  </span><br><span class="line">为了能构建高规格的测试用例，太过醉心用例设计  </span><br><span class="line">用例需要不断维护，复用成本加大</span><br></pre></td></tr></table></figure><h4 id="用例的设计原则"><a href="#用例的设计原则" class="headerlink" title="用例的设计原则"></a>用例的设计原则</h4><p>唯一性：要求用例的描述明确目的唯一，任何人通过当前用例得到的结果应该是唯一的。</p><p>简洁性：用例的描述需要简洁明了不要使用模糊性话语。</p><p>单一性：一条用例只测一个点。</p><h2 id="用例案例：手机充电"><a href="#用例案例：手机充电" class="headerlink" title="用例案例：手机充电"></a>用例案例：手机充电</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不一定要拘泥于一种用例模板格式</span><br><span class="line">可以采用简单的数据表的格式来编写</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/16.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试基础02-1</title>
      <link href="/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8002-1/"/>
      <url>/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8002-1/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试基础——软件测试简介"><a href="#软件测试基础——软件测试简介" class="headerlink" title="软件测试基础——软件测试简介"></a>软件测试基础——软件测试简介</h1><blockquote><p>软件测试行业基本介绍、软件测试基本介绍、测试对象介绍、测试级别、系统测试分类、常见的系统测试方法、软件质量、软件测试流程、软件架构、浏览器基本介绍、常见的图片类型</p></blockquote><a id="more"></a><h2 id="软件测试行业基本介绍"><a href="#软件测试行业基本介绍" class="headerlink" title="软件测试行业基本介绍"></a>软件测试行业基本介绍</h2><p>一、为什么需要软件测试</p><ol><li><p>一款软件从无到有会经历很多的开发阶段由不同的人来参与开发，所以最终产出的软件功能可能会存在问题。因此为了保证软件的功能是可用的，我们必须要进行测试。</p></li><li><p>当前的软件件行业已经不在是功能为王了，用户不仅仅只盯着软件的功能是否满足需求，还会对软件是否容易上手，执行效率是否OK …..等一系列其它体验都有了更高的要求，所以这也需要我们对软件进行大量的测试。</p></li></ol><p>二、为什么选择软件测试</p><ol><li><p>国内的软件行业对于专业的软件测试人员需求是慢慢变大。</p></li><li><p>有些人喜欢创造世界所以他们做了开发，而我们就是希望这个世界变得更加美好所以做了测试。</p></li></ol><p>三、为什么不让开发自已做测试</p><ol><li><p>当前行业有许多的测试从业人员本身之前都是开发岗。</p></li><li><p>专业度：软件测试和软件开发分别属于软件行业当中二个不同的技术方向。所以让专人做专事对于质量更加有保证。</p></li><li><p>思维定式：在软件的开发周期中 对于程序员来说他们大多数的时间都是在思考如何实现具体的软件功能，而不会去从用户的角度考虑如何去”奇葩“的使用这些功能。</p></li><li><p>测试力度： 相对于开发来说，产器就相当于是他们的“孩子”。所以“下手”就不会那么狠。</p></li></ol><h2 id="软件测试基本介绍"><a href="#软件测试基本介绍" class="headerlink" title="软件测试基本介绍"></a>软件测试基本介绍</h2><p>一、软件测试定义</p><p>通过手工或者工具对 “被测对象”进行测试操作，从而验证实际结与预期结果之间是否存在差异。</p><p>二、软件测试的作用</p><ol><li><p>通过测试工作可以发现并修复软件当中存在的缺陷，从而提高用户对产品的使用信心。</p></li><li><p>测试可以记录软件运行过程中产生的一些数据，从而为决策提供数据支持。</p></li><li><p>测试可以降低同类型产品开发遇到问题的风险。</p></li></ol><p>三、测试原则：</p><p>所谓的测试原则指的就是我们在执行测试工作时必须要遵守的一些规则。</p><ol><li><p>测试证明软件存在缺陷：无论执行什么样的测试操作都保能证明当前软件是有缺陷的。</p></li><li><p>不能执行穷尽测试：有些功能是没有办法将所有的测试情况都逻列出来，所以任何的测试操作都有结束的时间。</p></li><li><p>缺陷存在群集现象：对于软件功能说，核心功能占20%，非核心是80%。在实际工作中我们会集中测试20%的核心功能，所以这个部分发现缺陷的几率就会高于80%。因此我们我们就会遇到缺陷都集中在 20% 功能模块里的现象。</p></li><li><p>某些测试需要依赖特殊的环境</p></li><li>测试应尽早介入：为了更多的发现和更好的解决软件中的缺陷，我们追求测试工作尽早的开展。</li><li><p>杀虫剂现象：同样的一个测试用例不能重的执行多次，因为软件会对它产生免疫。</p></li><li><p>不存在缺陷谬论：任何软件不可能是完美的。</p></li></ol><h2 id="测试对象介绍"><a href="#测试对象介绍" class="headerlink" title="测试对象介绍"></a>测试对象介绍</h2><p>对于当前的测试行业来说我们最经常测试的主体就是 软件( 主体功能 )，但是需要我们明白是一个软件也不仅仅只有功能需要测试。我们可以将软件分为三个部分组成：功能集合+使用说明书 + 配置数据。</p><p>对于一款软件来说从无到有需要不同的过程，我们可以将这个过程分为不同阶段，然后每个阶段都会相应有测试对象</p><ol><li><p>需求分析阶段：各种需求规格说明书。</p></li><li><p>软件架构设计：API接口文档( 接口测试 )</p></li><li><p>编码实现阶段：源代码（ 白盒测试、单元测试 ）</p></li><li><p>系统功能使用：软件功能主体（ 当前行业做的最多的一种测试 ）</p></li></ol><h2 id="测试级别"><a href="#测试级别" class="headerlink" title="测试级别"></a>测试级别</h2><p>软件的开发都会依据相应的<strong>开发模型</strong>，则测试级别指的就在这个模型当中我们人为定义的开发步骤。其中对于测试来说我们最常见的一种级别分类如下：</p><ol><li><p>单元测试[ UT unit test ]：在软件测试中单元指的就是组成软件最小的底层代码结构，一般就是类、函数、组件（ 当下的软件测试行业，不会刻意要求测试人员对源代码进行测试 ）。</p></li><li><p>集成测试( IT system ingertaion test ):将多个单元模块组合在一起，然后验证它们之间沟通的“桥梁”是否能正常工作( 接口测试 )</p></li><li><p>系统测试( ST system test ):这是当前行业做的最多的一种测试。由测试人员充当用户然后对软件的功能主体进行测试。</p></li><li><p>验收测试:</p></li></ol><p>(1)     α测试 —- 内测</p><p>(2)     β测试 —–公测</p><p>(3)     UAT( user acceptance test )测试—- 由客户派出对于业务非常精通的人员来使用该软件，从而对功能进行测试。</p><p>(4)     验收测试的核心就是让用户为当前软件 “买单”</p><h2 id="系统测试分类"><a href="#系统测试分类" class="headerlink" title="系统测试分类"></a>系统测试分类</h2><ol><li><p>功能测试：验证当前的软件主体功能是否可用。</p></li><li><p>兼容性测试：验证当前软件在不同的环境下是否还可以使用。</p></li><li><p>安全测试：验证软件是否只是能授权用户提供功能使用。</p></li><li><p>性能测试：相对于当前软件消耗的资源 它的产出能力。</p></li></ol><h2 id="常见的系统测试方法"><a href="#常见的系统测试方法" class="headerlink" title="常见的系统测试方法"></a>常见的系统测试方法</h2><p>一、按测试对象进行分类</p><ol><li><p>白盒测试：这种测试的主体就是软件的底层代码，不会在意外在的界面是否OK ，只要求底层功能实现，同时逻辑正确。</p></li><li><p>黑盒测试：这种测试就是指测试软件外在主体功能是否可用。</p></li><li><p>灰盒测试：介于二者之间（ 接口测试 ）</p></li><li><p>上述三种方法当中的 “盒” 指的就是被测对象。</p></li></ol><p>二、按测试对象是否执行分类</p><ol><li><p>静态测试：指的就是测试不执行。</p></li><li><p>动态测试：将软件运行在真实的使用环境中进行测试。</p></li></ol><p>三、按测试手段进行分类</p><ol><li><p>手工测试：由测试人员手动的对被测对象进行验证，优点就是可以灵活的改变测试操作及环境。</p></li><li><p>自动化测试：所谓自动化主要有二种形，一种是自已写测试脚本，另外一种就是通过第三方的工具对被测对象进行测试。优点就是可以高效率的去执行一些人工无法实现的操作。</p></li></ol><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>描述当前软件是否好用，在当前的软件行业里我们所采用的一套标准是基于 ISO 组织制定的。需要我们记忆的就是软件质量的六大特性：</p><ol><li><p>功能性：软件需要满足用户显式或者稳式的功能。</p></li><li><p>易用性：软件易于学习 和上手使用。</p></li><li><p>可靠性：指的就是软件必须实现需求当中指明的具体功能。</p></li><li><p>效率性：类似于软件的性能。</p></li><li><p>可维护性：要求软件具有将某个功能修复之后继续使用的能力。</p></li><li><p>可移植性：当前软件可以从一个平台移植到另一个平台上去使用的能力。</p></li></ol><p>【 功能靠用，效率可“以” 】</p><h2 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h2><ol><li>需求分析</li></ol><p>(1) 当前阶段的核心目的就是梳理清楚我们需要设计的点是什么。</p><p>(2) 需求的来源：需求规格说明书、API文档、竟品分析、个人经验</p><ol start="2"><li>设计用例：</li></ol><p>(1) 用例就是用户为了测试软件的某个功能而执行的操作过程。</p><p>(2) 设计用例是有方法的（ 等价类、边界值、判定表…… ）</p><ol start="3"><li><p>评审用例:对当前的用例进行添加或者删除。</p></li><li><p>配置环境</p></li></ol><p>(1) 环境：指的就是当前被测对象运行所需要的执行环境，做为测试人员需要具备配环境的能力。【 一般情况下都会使用一键安装的集成环境 】</p><p>(2) 环境分类：操作系统 +  服务器软件 +  数据库  +  软件底层代码的执行环境。</p><ol start="5"><li>执行用例</li></ol><p>(1) 一般在执行用例之前我们会做一个冒烟测试。这种测试的核心就是快速的对当前软件的核心功能或者主体执行流程进行验证。如果冒烟测试阶段有问题，则可以将此版本回退给开发。</p><p>(2) 如果冒烟测试通过那么才会开展示全面的测试。</p><ol start="6"><li>回归测试及缺陷跟踪</li></ol><p>(1) 回归测试指的就是当我们将某个缺陷提交给开发之后，由它们进行修复，修复完成之后需要测试认员再次对其进行测试【回归测试】</p><p>(2) 缺陷跟踪：指的就是当测试人员发现某个缺陷之后需要一直对其进行状态的跟踪。</p><ol start="7"><li>输出测试报告</li></ol><p>将当前的测试过程中产生的数据进行可视化的输出。方便其它人去查看。</p><ol start="8"><li>测试结束</li></ol><p>当将整个测试过程中产生的一些文档进行整理归档，方便后续版本使用。</p><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>所谓的软件架构我们可以理解为是用来指导我们软件开发的一种思想。目前来说最常见的二种架构模式就是 B/S  C/S</p><p>B—browser 浏览器</p><p>C—clent 客户端</p><p>S—server 服务端</p><p>一、二种架构的比较</p><ol><li><p>标准：相对于 CS 架构来说 BS架构的二端都是在使用现成的成熟产品。所以BS会显示的标准一些。</p></li><li><p>效率：相对于BS架构来说 CS中的客户端可以分担一些数据的处理，因此执行效率会高一些。</p></li><li><p>安全：B S架构当中的数据传输都是以 HTTP协议进行的输出，而 HTTP协议又是明文输出。可以被抓包，所以相对于 CS 架构来说 BS 就显得不那么安全【相对的】</p></li><li><p>升级：BS架构只需要在服务器端将数据进地更新，前台只需要刷新页面就可以完成升级，而CS架构当中必须要将二端都进行更新。</p></li><li><p>开发成本：相对于 BS架构来说 CS当中的客户端需要自已开发，所以相对于来说成本会高一些。</p></li></ol><h2 id="浏览器基本介绍"><a href="#浏览器基本介绍" class="headerlink" title="浏览器基本介绍"></a>浏览器基本介绍</h2><p>一、浏览器是什么</p><p>浏览器本质就是一款软件，安装在操作系统之上。一般给用户提供浏览网页的服务。目前来说我们会人为的将所有浏览器总结出一个所谓的五大生产厂商。【 对于浏览器来说最核心技术就是内核 】</p><p>二、五大浏览器生产厂商</p><ol><li><p>IE( 微软 )—–trident </p></li><li><p>Chrome ( 谷歌 )—-blink</p></li><li><p>Firefox( 火狐 )—–gecko</p></li><li><p>Safari( 苹果 )—–webkit</p></li><li><p>Opera( 欧朋 )—-presto【 现在已经放弃自已东西完全向 chrome 】</p></li></ol><h2 id="常见的图片类型"><a href="#常见的图片类型" class="headerlink" title="常见的图片类型"></a>常见的图片类型</h2><ol><li><p>Jpg(jpeg) :这是一种可以高度保留图片色彩信息的格式。</p></li><li><p>Png：该类型的图片可以实现透明。</p></li><li><p>Gif：图片所占体积小，可以实现动图</p></li><li><p>Psd：它是一种分层的图片。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试基础01-2</title>
      <link href="/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-2/"/>
      <url>/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础02"><a href="#计算机基础02" class="headerlink" title="计算机基础02"></a>计算机基础02</h1><blockquote><p>常见的数学进制、进制转换、编码、数据计量单位、编程语言、常见的DOS命令</p></blockquote><a id="more"></a><h2 id="常见的数学进制"><a href="#常见的数学进制" class="headerlink" title="常见的数学进制"></a>常见的数学进制</h2><p>1 二进制：基数就是0 1 ，逢二进1</p><p>2 八进制：基数就是0-7 ，逢八进1</p><p>3 十进制：基数就是0-9 ，逢十进1</p><p>4 十六进制：基本数就是0-9 A B C D E F, 逢十六进1</p><p>一、用二进制数数</p><p>0   1  10  11  100  101  110  111  1000</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><a href="http://tool.oschina.net/hexconvert/" target="_blank" rel="noopener">http://tool.oschina.net/hexconvert/</a> 【 在线的进制转换工具地址 】</p><p>一、其它进制转十进制：</p><p>1．先确定当前数字的位数，然后从右向左数，依次认为是低位到高位。</p><p>2．记下每位数字所在的位数N( N不是一个固定的数字，由当前所在位数决定 )</p><p>3．取出每一位上的数字 m ，然后用这个m 去乘以当前进制的N-1次方。( m也不是固定的，它就是当前位上所具有的数字 )</p><p>4．将每位上的相乘结果进行相加，最后的和就是该数值所对应的十进制值。</p><p>二、其它进制转二进制</p><p>1．十进制转二进制</p><p>（1）用这个十进制的数字除以2 ，得到商和余数。</p><p>（2）判断商是否为0，如果不是0则继续用这个商除去2</p><p>（3）直到某一次商为0时结束，将这个除法过程中产生的余数反向排列</p><p>（4）最终的排列结果就是当前这个十进制转成二进制后的数值</p><p>2．8进制/16进制转二进制</p><p>（1）将八进制或十六制中的所有“基数”都转成二进制。（需要注意的就是八进制转二进制要写成三位，而十六进制要写在四位）</p><p>（2）有了上述的二进制基数转换之后，当我们拿到一个具体的八进制或者十六进制数值之后我们只需要将其进行拼接就可以。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>一、编码是什么</p><p>所谓的编码指的就是将我们人类可以理解的语言编译成计算机可以执行的语言。</p><p>二、编码的思想</p><p>将我们人类中的自然语言人为的按照一种规则与一个二进制的数值做对应。当这种对应关系越来越多的时候，就会形成一张表，我们将这个表称之为叫编码表。</p><p>三、ascii 码表</p><p>1．它是全世界第一张通用单字节编码表。</p><p>2．它分成三个部分，一共有256个字符。</p><p>3．当我们没有使用正确的编码来处理汉字的时候在网页展示就会乱码。</p><p>4．对于中文汉字来说，我们目前使用最多的一种编码标准就是 UTF8 编码。</p><h2 id="数据计量单位"><a href="#数据计量单位" class="headerlink" title="数据计量单位"></a>数据计量单位</h2><p>一、为什么需要计量单位</p><p>计算机是用来处理数据的，当数据积累到一定的量级之后就会需要有相应的单位来对它们进行衡量。</p><p>二、最基本的计量单位</p><p>1．比特( bit/ 位 )：它被认为是计算机当中最小的一个单位。</p><p>2．字节( bytes ): 它比 位要大一些，人为规定 1字节=8位</p><p>三、常见的单位及转换关系</p><p>1．1B = 8b</p><p>2．1KB = 1024B  [文档和小图片]</p><p>3．1MB = 1024KB【 大图片，或者音乐 】</p><p>4．1GB = 1024MB【 高清的电影 】</p><p>5．1TB = 1024GB</p><p>6．1PB = 1024TB</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>由人类来设计的一种计算机可以理解的语言</p><p>一、编程语言发展历史</p><p>1．机器语言</p><p>机器语言就是纯二进制，将我们人类想让计算机完成的事情都直接用01 来表示。</p><p>2．汇编语言</p><p>汇编语言就是在机器语言的基础之上将一些常用的操作直接规定成人类的一些语句来表达，但是随着计算机要做的事情越来越多，同时生产计算要的厂商也越来越多，我们不能保证所有的硬件都能很好支持我们的二进制。</p><p>3．高级编程语言</p><p>它就是一种类似于人类的自然语言，人类很容易理解，同时又不用担心计算机如何识别。当前全世界大概有（600）多种编程语言</p><p>二、常见的编程语言</p><p>1．C语言： 我们认为c 是高级编程语言的鼻祖。</p><p>2．C++ ：它就是在 C语言的基础上做了减化。更利于我们学习，c 和 c++ 都是由 贝尔实验室 推出。</p><p>3．Java : 由 sun 公司在1995推出，最大的点是跨平台。( jvm 虚拟机 )</p><p>4．C# : 由微软推出的一个语言。</p><p>5．Python : 一种数学计算能力很强的语言。</p><p>6．Php ：这门语言在出生的时候最大的特点就是用来做web 网站。</p><p>7．Javascript：当前最流行的一种前端脚本语言</p><p>8．Nodejs ： 全栈型语言，前后端都可以写。</p><p>9．Go ： 由谷歌公推出的一门语言。</p><h2 id="常见的DOS命令"><a href="#常见的DOS命令" class="headerlink" title="常见的DOS命令"></a>常见的DOS命令</h2><p>一、DOS 是什么</p><p>DOS 是一个操作系统，属于windows ，和我们现在用的 win7 8 10 去比较其实差别就在于 ，我们现在用的是图形桌面系统，而DOS 是一个命令行执行的操作系统。</p><p>二、如何使用DOS </p><p>1．进入终端：win + r 调出运行面板</p><p>2．在运行中输入 cmd 进入终端</p><p>3．在终端面板中书写 DOS 命令 ，然后回执行。</p><p>三、常见的命令</p><p>1．Time 显示当前计算机的本地时间</p><p>2．Ctrl+ c 退出当前正在执行的命令</p><p>3．Shutdown /s /t 时间(秒) :设置在多少时间后自动关机【 中间有空格 】</p><p>4．Shutdown /a 取消之前设置的自动关机</p><p>5．Cls  清空当前正在编辑的屏幕</p><p>6．Ping 网址</p><p>（1）可以检查当前的网络是否是通的</p><p>（2）可以得到当前被访问网页的IP地址</p><p>7．Ipconfig -all </p><p>（1）可以将当前计算机当中的所有网卡信息都列出来。</p><p>（2）Ip 地址：这个地址一般是用来在网络上唯一标识计算机。（ 一台机器的IP地址可以变 ）</p><p>（3）Mac 地址：也叫物理地址，它是被写入 ROM 的。理论上每台计算机的mac地址是唯一的。</p><p>8．上下键 ：调用我们之前使用过的命令，上键就是往回找，下键就是往下找。</p><p>四、切换盘符</p><p>具体盘符名称:  </p><p>五、返回上一级或根目</p><p>Cd ..  返回上一级</p><p>Cd / 返回根目录</p><p>注意：</p><p>01 cd 就是change directory 的首字母缩写，表示切换目录的意思。</p><p>02 cd 命令不可以切换盘符</p><p>03 根目录指的就是某个盘符的一级目录</p><p>04 命令语句一定都是在英文输入法下面书写的，命令和参数之间往往都用空格隔开</p><p>六、列表示展示某个目录下的内容</p><p>Dir </p><p>七、目录及文件相关操作</p><p>1．新建目录： md 路径</p><p>2．新建文件： echo “内容”&gt;文件名称，通过这种方法间接得到一个文件</p><p>3．删除目录： rd 路径 【默认情况下只能删除空目录，如果想连带它里的文件一起删除则需要设置 /s 参数】</p><p>4．删除文件： del 文件名称 </p><p>注：</p><p>A. md 只能新建目录</p><p>B. Rd 默认只能删除空目录</p><p>C. 参与与命令之间一定要用空格</p><p>D. 如果del 后面直接写的不是文件，而是一个目录，那么它就会将这个目录下的所有文件都删除（ 前提是我们选择 Y  ）</p><p>八、文件复制和剪切命令</p><p>Copy 被复制文件路径  将这个文件复制到哪里</p><p>Copy aa/aa.txt c:\test\bb.txt [ 将目录aa下在的aa.txt 文件，复制到 c 盘test目录下，同时将名称修改为 bb ]</p><p>注：</p><p>01 复制操作语句，我们可以分为三段，第一段就是命令 copy ，第二段就是被复制文件的在地，第三段可以指明将当前文件复制到哪里，三段之间都要用空格隔开</p><p>02 第三段可以省略，省略之后的结果就是会将相应的文件直接复制到我们的当前所在位置。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"></p><p>Move 被剪切文件所在地 将这个文件剪切到哪里</p><p>注：</p><p>01 对于剪切操作来说 必须要进入到想要操作文件所在目录去执行命令</p><p>02 第三段用来指明目标所在地的部分不能省略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试基础01_1</title>
      <link href="/2019/08/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-1/"/>
      <url>/2019/08/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础01"><a href="#计算机基础01" class="headerlink" title="计算机基础01"></a>计算机基础01</h1><blockquote><p>“计算机”基本介绍、硬件系统、软件系统、二进制基本介绍</p></blockquote><a id="more"></a><h2 id="“计算机”基本介绍"><a href="#“计算机”基本介绍" class="headerlink" title="“计算机”基本介绍"></a>“计算机”基本介绍</h2><p>一、为什么需要计算机</p><p>对于现在的我们来说，每天要处理的信息量是巨大的，所以如果还是人工的来对这些数据进行处理，那么效率是很低的。此时计算机的出现就可以帮助我们的来提高处理数据的速度。</p><p>二、计算机是什么</p><p>计算机就是一台可以自动高效完成计算的电子设备，我们俗称叫 电脑( PC )</p><p>三、计算机的特点</p><p>1．计算机可以进行数学和逻辑运算。（ 逻辑运算可以实现在接收到不同操作指令的时候做出不同的响应 ）</p><p>2．计算机可以对数据进行记忆和存储。( 数据不仅仅只是数字，图片 文字 声音 视频…. )</p><p>3．计算机可以在程序的指令下自动高效的完成计算。</p><p>四、计算机组成</p><p>1．从大的系统分类上我们将计算机的组成分为：软件系统+硬件系统</p><p>2．硬件：我们就可以认为是组成计算机的那些物理设备（ 看得见 摸得着 ）</p><p>3．软件：所谓的软件就是安装在计算机上供用户使用的操作指令集合。</p><h2 id="硬件系统"><a href="#硬件系统" class="headerlink" title="硬件系统"></a>硬件系统</h2><p>一、为什么需要硬件</p><p>任何的计算操作，最终都需要通过相应的硬件来完成。</p><p>二、硬件的组成</p><p>1．现代的电子计算机我们依据 “冯诺依曼” 理论将它的硬件分成五个级成部分。</p><p>2．输入设备：核心作用就是给计算输入不同格式的数据。</p><p>3．输出设备：作用就是将计算机处理之后的数据以不同的形式展示给用户。</p><p>4．控制器+处理器：这二个部分合在一起就是我们所说的中央处理器( CPU )</p><p>5．存储设备:我们将计算机当中的存储器分为内存和外存二种，无论是哪一种，它的作用都是对数据进行存储。</p><p>三、内存与外存</p><p>1．内存：就是我平所说的内存条，它的大小一般在（ 4G-16G ）</p><p>2．外存：外存的表现形式很多，例如硬盘（ 128G-1T ）</p><p>四、内存与外存比较</p><p>1．内存的运算速度要快去外存</p><p>2．内存当中的数据断电之后会消失，而外存不会。</p><p>3．内存本身我们又分为只读内存( ROM )和随机内存( RAM )</p><h2 id="软件系统"><a href="#软件系统" class="headerlink" title="软件系统"></a>软件系统</h2><p>一、为什么需要软件</p><p>如果计算要没有软件系统那么它里面的硬件就不知道如何进行工作。</p><p>二、软件系统介绍</p><p>1．我们人为的将软件系统分为二类：系统软件 + 应用软件</p><p>2．系统分类( 操作系统软件 )：</p><p>（1）桌面操作系统：</p><p>Windows: 由微软推出，用户量很大。分很多系列</p><p>MacOs:苹果公司，本质其实也是一个 Linux 分支。</p><p>Linux:核心内容是由 李纳斯 编写，应用软件少。</p><p>（2）移动设备操作系统</p><p> IOS</p><p> Androids :底层就是一款小型的 Linux </p><p>（3）服务器操作系统 </p><p> Windows server ：由微软件推出，是收费的。</p><p> Linux：开源 稳定</p><p> 服务器：所谓的服务器我们就可以理解为是一台给用户提供相应的服务的机器。（文件上传下载服务，视频上传下载服务…..）只不过，这台机器的处理能力要远远大于我们的个人电脑。</p><p>服务器操作系统查询地址：<a href="https://toolbar.netcraft.com/site_report?url=http:/www.taobao.com" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url=http://www.taobao.com</a></p><p>3 应用软件：我们就将那些可以安装在操作系统之上的第三方软件。( 微信  QQ ….. )</p><h2 id="二进制基本介绍"><a href="#二进制基本介绍" class="headerlink" title="二进制基本介绍"></a>二进制基本介绍</h2><p>一、<strong>二进制是什么</strong></p><p>1．进制: 就是一种人为规定的计数规则。</p><p>2．二进制：它就是逢二进1 的一种计算规则。</p><p><strong>二、**</strong>二进制介绍**</p><p>1．在二进制里“基数”只有 0 和 1 </p><p>2．二进制当前被广泛的应用于计算机当中。( 计算机底层只能读懂0 和 1 )</p><p>三、<strong>计算机如何理解0</strong> <strong>和 1</strong> </p><p>现代的计算机都是通电进行工作，当电流走过设备的时候必然会产生电压。此时前辈们就人为的设定规则，取了一个电压值，比这个值大的叫高电位。用数字1 表示，比这个值小的叫低电位。用数字0 表示。基于这种原理，此时的计算机就可以认识0 和 1 了。刚好0 与1 又是二进制当中的基数。（ 计算机应用了二进制 ）</p><p>四、计算机采用二进制的好处</p><p>1．二进制技术实现简单，状态稳定。</p><p>2．二进制里只有0 和 1 二个基数，刚好与程序语言当中的 真和假对应。【全世界都人为的认为 1 可以代表程序语言中真，0 就可以代表程序语言中的假】</p><p>3．二进制数值可以很容易的转成十进制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的FileReader</title>
      <link href="/2019/08/09/HTML5%E7%9A%84FileReader/"/>
      <url>/2019/08/09/HTML5%E7%9A%84FileReader/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5的FileReader"><a href="#HTML5的FileReader" class="headerlink" title="HTML5的FileReader"></a>HTML5的FileReader</h1><a id="more"></a><h2 id="FileReader-读取文件内容"><a href="#FileReader-读取文件内容" class="headerlink" title="FileReader:读取文件内容"></a>FileReader:读取文件内容</h2><ol><li>readAsText():读取文本文件（可以使用Txt）打开的文件，返回文本字符串，默认编码是utf-8</li><li>readAsBinaryString():读取任意类型的文件。返回二进制字符串。这个方法不是用来读取文件给用户看，而是存储文件。例如:读取文件的内容，获取二进制数据，传递给后台，后台接收了数据之后，再将数据存储。</li><li>readAsDataURL():读取文件获取一段以data开头的字符串，这字符串的本质就是DataURL.dataURL是一种将文件(这个文件一般就是指图像或能嵌入到文档的文件格式）嵌入到文档的方案。DataURL是将资源转换为base64的字符串形式，并且将这些内容直接存储在url，优化网站的加载速度和执行效率。</li></ol><h2 id="img的src解析"><a href="#img的src解析" class="headerlink" title="img的src解析"></a>img的src解析</h2><ol><li>src：制定路径（资源定位–url):src请求的是外部文件，一般来说是服务器资源。意味着它需要向服务器发送请求，它占服务器资源</li></ol><h2 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h2><ol><li>abort()终端读取</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote><p>需求</p><p>即时预览</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"myFile"</span> <span class="attr">id</span>=<span class="string">"myFile"</span> <span class="attr">onchange</span>=<span class="string">"getFIleContent()"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span></span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFileContent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//1.创建文件读取对象</span></span><br><span class="line">    <span class="keyword">var</span> reader=<span class="keyword">new</span> FileReader();</span><br><span class="line">    <span class="comment">//2.读取文件，获取DataURL</span></span><br><span class="line">        <span class="comment">//2.1.说明没有任何的返回值：void:但是读取完文件之后，他会将读取的结果存储在文件读取对象的result。</span></span><br><span class="line">        <span class="comment">//2.2.需要传递一个参数binary large object：文件（图片或者其他可以嵌入到文档的类型）</span></span><br><span class="line">        <span class="comment">//2.3.文件存储在file表单元素的files属性，它是一个数组   </span></span><br><span class="line">        <span class="keyword">var</span> file = <span class="built_in">document</span>.querySelector(<span class="string">"#myFile"</span>).files;</span><br><span class="line">reader.readAsDataURL(file[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">/*获取数据*/</span></span><br><span class="line"><span class="comment">/*FileReader提供一个完整的时间模型，用来补货读取文件时的状态</span></span><br><span class="line"><span class="comment">onabort:读取文件中断片时触发</span></span><br><span class="line"><span class="comment">onerror:读取错误时触发</span></span><br><span class="line"><span class="comment">onload:文件读取成功完成时触发</span></span><br><span class="line"><span class="comment">onloadend:读取完成时触发，物流成功还是失败</span></span><br><span class="line"><span class="comment">onloadstart:开始读取时触发</span></span><br><span class="line"><span class="comment">onprogress:读取文件过程中持续触发</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reader.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"img"</span>).src=reader.result;</span><br><span class="line">    &#125;</span><br><span class="line">reader.onprogress=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> percent=e.loaded/e.total*<span class="number">100</span>+<span class="string">"%"</span>;</span><br><span class="line">        div.style.width=percent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5地理定位接口</title>
      <link href="/2019/08/09/HTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/08/09/HTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5地理定位接口"><a href="#HTML5地理定位接口" class="headerlink" title="HTML5地理定位接口"></a>HTML5地理定位接口</h1><a id="more"></a><ol><li><p>获取地理信息成功之后的回调</p></li><li><p>获取地理信息失败之后的回调</p></li><li><p>调整获取当前地理信息的方式</p></li><li><p>navigator.geolocation.getCurrentPosition(success,error,option)；</p></li><li><p>enableHighAccuracy:true/false:是否使用高精度</p></li><li><p>timeout:设置超时时间，单位ms</p></li><li><p>maxiumAge:可以设置浏览器重新获取地理信息的时间间隔，单位是ms</p></li><li><p>如果成功获取地理信息成功，会将获取到的地理信息传递给成功之后的回调</p><p>position.coords.latitude 维度</p><p>position.corrds.longitude 经度</p><p>position.corrds.accuracy 精度</p><p>position.corrds.altitude 海拔</p></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.de</span>&#123;</span></span><br><span class="line"><span class="undefined">            width: 300px;</span></span><br><span class="line"><span class="undefined">            height: 300px;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ddd</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"de"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var x=document.getElementById("demo");</span></span><br><span class="line"><span class="undefined">    function getLocation()</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        /*能力测试*/</span></span><br><span class="line"><span class="undefined">        if (navigator.geolocation)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">            /*1.获取地理信息成功之后的回调</span></span><br><span class="line"><span class="undefined">            * 2.获取地理信息失败之后的回调</span></span><br><span class="line"><span class="undefined">            * 3.调整获取当前地进信息的方式*/</span></span><br><span class="line"><span class="undefined">            //navigator.geolocation.getCurrentPosition(success,error,option);</span></span><br><span class="line"><span class="undefined">            /*option:可以设置获取数据的方式</span></span><br><span class="line"><span class="undefined">            * enableHighAccuracy:true/false:是否使用高精度</span></span><br><span class="line"><span class="undefined">            * timeout:设置超时时间，单位ms</span></span><br><span class="line"><span class="undefined">            * maximumAge:可以设置浏览器重新获取地理信息的时间间隔，单位是ms*/</span></span><br><span class="line"><span class="undefined">            navigator.geolocation.getCurrentPosition(showPosition,showError,&#123;</span></span><br><span class="line"><span class="undefined">                /*enableHighAccuracy:true,</span></span><br><span class="line"><span class="undefined">                timeout:3000*/</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        else&#123;</span></span><br><span class="line"><span class="undefined">            x.innerHTML="Geolocation is not supported by this browser.";</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    /*成功获取定位之后的回调*/</span></span><br><span class="line"><span class="undefined">    /*如果获取地理信息成功，会将获取到的地理信息传递给成功之后的回调*/</span></span><br><span class="line"><span class="undefined">    // position.coords.latitude 纬度</span></span><br><span class="line"><span class="undefined">    // position.coords.longitude 经度</span></span><br><span class="line"><span class="undefined">    // position.coords.accuracy 精度</span></span><br><span class="line"><span class="undefined">    // position.coords.altitude 海拔高度</span></span><br><span class="line"><span class="undefined">    function showPosition(position)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        x.innerHTML="Latitude: " + position.coords.latitude +</span></span><br><span class="line"><span class="xml">                "<span class="tag">&lt;<span class="name">br</span> /&gt;</span>Longitude: " + position.coords.longitude;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    /*获取定位失败之后的回调*/</span></span><br><span class="line"><span class="undefined">    function showError(error)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        switch(error.code)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">            case error.PERMISSION_DENIED:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="User denied the request for Geolocation."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">            case error.POSITION_UNAVAILABLE:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="Location information is unavailable."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">            case error.TIMEOUT:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="The request to get user location timed out."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">            case error.UNKNOWN_ERROR:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="An unknown error occurred."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    getLocation();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="百度地图的案例"><a href="#百度地图的案例" class="headerlink" title="百度地图的案例"></a>百度地图的案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>普通地图&amp;全景图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://api.map.baidu.com/api?v=2.0&amp;ak=DarF2LCCGzn6T16zgy8ZPkvYYE5CT6fu"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>, <span class="selector-tag">html</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">overflow</span>: hidden;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">font-family</span>:<span class="string">"微软雅黑"</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#panorama</span> &#123;<span class="attribute">height</span>: <span class="number">50%</span>;<span class="attribute">overflow</span>: hidden;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#normal_map</span> &#123;<span class="attribute">height</span>:<span class="number">50%</span>;<span class="attribute">overflow</span>: hidden;&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panorama"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"normal_map"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    //全景图展示</span></span><br><span class="line"><span class="undefined">    var panorama = new BMap.Panorama('panorama');</span></span><br><span class="line"><span class="undefined">    panorama.setPosition(new BMap.Point(116.404125,39.91405)); //根据经纬度坐标展示全景图</span></span><br><span class="line"><span class="undefined">    panorama.setPov(&#123;heading: -40, pitch: 6&#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    panorama.addEventListener('position_changed', function(e)&#123; //全景图位置改变后，普通地图中心点也随之改变</span></span><br><span class="line"><span class="undefined">        var pos = panorama.getPosition();</span></span><br><span class="line"><span class="undefined">        map.setCenter(new BMap.Point(pos.lng, pos.lat));</span></span><br><span class="line"><span class="undefined">        marker.setPosition(pos);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">    //普通地图展示</span></span><br><span class="line"><span class="undefined">    var mapOption = &#123;</span></span><br><span class="line"><span class="undefined">        mapType: BMAP_NORMAL_MAP,</span></span><br><span class="line"><span class="undefined">        maxZoom: 18,</span></span><br><span class="line"><span class="undefined">        drawMargin:0,</span></span><br><span class="line"><span class="undefined">        enableFulltimeSpotClick: true,</span></span><br><span class="line"><span class="undefined">        enableHighResolution:true</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    var map = new BMap.Map("normal_map", mapOption);</span></span><br><span class="line"><span class="undefined">    var testpoint = new BMap.Point(116.404125,39.91405);</span></span><br><span class="line"><span class="undefined">    map.centerAndZoom(testpoint, 18);</span></span><br><span class="line"><span class="undefined">    var marker=new BMap.Marker(testpoint);</span></span><br><span class="line"><span class="undefined">    marker.enableDragging();</span></span><br><span class="line"><span class="undefined">    map.addOverlay(marker);</span></span><br><span class="line"><span class="undefined">    map.enableScrollWheelZoom(true);</span></span><br><span class="line"><span class="undefined">    map.addControl(new BMap.MapTypeControl());</span></span><br><span class="line"><span class="undefined">    marker.addEventListener('dragend',function(e)&#123;</span></span><br><span class="line"><span class="undefined">        panorama.setPosition(e.point); //拖动marker后，全景图位置也随着改变</span></span><br><span class="line"><span class="undefined">        panorama.setPov(&#123;heading: -40, pitch: 6&#125;);&#125;</span></span><br><span class="line"><span class="undefined">    );</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的拖拽</title>
      <link href="/2019/08/09/HTML5%E7%9A%84%E6%8B%96%E6%8B%BD/"/>
      <url>/2019/08/09/HTML5%E7%9A%84%E6%8B%96%E6%8B%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5的拖拽"><a href="#HTML5的拖拽" class="headerlink" title="HTML5的拖拽"></a>HTML5的拖拽</h1><a id="more"></a><ol><li><p>学习拖拽，主要就是学习拖拽时间</p><blockquote><p>拖拽元素的事件</p><p>ondrag:应用于拖拽元素，整个拖拽过程都会调用</p><p>ondragstart：应用于拖拽元素，当拖拽开始时调用</p><p>ondragleave:应用于拖拽元素，当鼠标离开拖拽元素时调用</p><p>ondraend:应用于拖拽元素，拖拽结束调用</p></blockquote></li></ol><p>2.<strong>测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;div1&quot; id=&quot;div1&quot;&gt;</span><br><span class="line">&lt;p id=&quot;pe&quot; draggable=&quot;true&quot;&gt;test&lt;/p&gt;</span><br><span class="line">&lt;p id=&quot;pe1&quot; draggable=&quot;true&quot;&gt;test1&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid green;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>:orange;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">"#pe"</span>);</span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.querySelector(<span class="string">"#div2"</span>);</span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.querySelector(<span class="string">"#div1"</span>);</span><br><span class="line">p.ondragstart=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondragstart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">p.ondragend=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondragend"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">p.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"元素：ondragleave"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">p.ondrag=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondrag"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">div2.ondragenter=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondragenter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">div2.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*如果想要触发ondrop事件，就要在这里阻止浏览器的默认行为*/</span></span><br><span class="line">e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*浏览器默认会阻止ondrop事件：我们必须在ondragover阻止浏览器的默认行为*/</span></span><br><span class="line">div2.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondrop"</span>);</span><br><span class="line">        div2.appendChild(p);</span><br><span class="line">    &#125;</span><br><span class="line">div2.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"目标元素：ondragleave"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">div1.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">        <span class="comment">/*如果想要触发ondrop事件，那么就必须在这个位置阻止浏览器阻止拖拽的行为*/</span></span><br><span class="line">    &#125;</span><br><span class="line">div1.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">div1.appendChild(p);    </span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>应用于目标元素的事件</li></ol><blockquote><p>ondragenter：应用于目标元素，当拖拽元素到达时调用</p><p>ondragover: 应用于目标元素，当停留在目标元素时调用</p><p>ondrop:应用于目标元素，当在目标元素放下元素时调用</p><p>ondragleave:应用于目标元素，当鼠标离开目标元素时调用</p></blockquote><ol start="4"><li>若要将元素可以拖拽到多个div，而不是需要为每一个div都设置事件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="literal">null</span>;<span class="comment">//当前被拖拽的地元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragstart=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*通过事件捕获来获取当前被拖拽的子元素*/</span></span><br><span class="line">    e.target.style.opacity=<span class="number">0.5</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"5px"</span>;</span><br><span class="line">    obj= e.target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragend=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.target.style.opacity=<span class="number">1</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"1px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrag=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragenter=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*添加元素*/</span></span><br><span class="line">    <span class="comment">//e.target.appendChild(obj);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>datatransfer</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragstart=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.target.style.opacity=<span class="number">0.5</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"5px"</span>;</span><br><span class="line">    obj= e.target;</span><br><span class="line">    <span class="comment">/*通过dataTransfer来实现数据的存储与获取</span></span><br><span class="line"><span class="comment">    * setData(format,data):</span></span><br><span class="line"><span class="comment">    * format:数据的类型：text/html   text/uri-list</span></span><br><span class="line"><span class="comment">    * Data:数据:一般来说是字符串值*/</span></span><br><span class="line">    e.dataTransfer.setData(<span class="string">"text/html"</span>, e.target.id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragend=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.target.style.opacity=<span class="number">1</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"1px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrag=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragenter=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*添加元素*/</span></span><br><span class="line">    <span class="comment">//e.target.appendChild(obj);</span></span><br><span class="line">    <span class="comment">/*通过e.dataTransfer.setData存储的数据，只能在drop事件中获取*/</span></span><br><span class="line">    <span class="keyword">var</span> id=e.dataTransfer.getData(<span class="string">"text/html"</span>);</span><br><span class="line">    <span class="comment">/*console.log("id="+id);*/</span></span><br><span class="line">    e.target.appendChild(<span class="built_in">document</span>.getElementById(id));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS复习内容01</title>
      <link href="/2019/04/03/CSS%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B901/"/>
      <url>/2019/04/03/CSS%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B901/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS复习笔记01"><a href="#CSS复习笔记01" class="headerlink" title="CSS复习笔记01"></a>CSS复习笔记01</h3><a id="more"></a><h1 id="引入CSS样式表"><a href="#引入CSS样式表" class="headerlink" title="引入CSS样式表"></a>引入CSS样式表</h1><p>CSS可以写到那个位置？ 是不是一定写到html文件里面呢？</p><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/CSS"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。</p><p>type=”text/CSS”  在html5中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。</p><h2 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h2><p>内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span> <span class="attr">style</span>=<span class="string">"属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"</span>&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。</p><h2 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h2><p>链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"CSS文件的路径"</span>  <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：  link 是个单标签</p><p>该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</span><br><span class="line">type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。</span><br><span class="line">rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</span><br></pre></td></tr></table></figure><h2 id="三种样式表总结（位置）"><a href="#三种样式表总结（位置）" class="headerlink" title="三种样式表总结（位置）"></a>三种样式表总结（位置）</h2><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>没有实现样式和结构相分离</td><td>较少</td><td>控制一个标签（少）</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面（中）</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多，强烈推荐</td><td>控制整个站点（多）</td></tr></tbody></table><h1 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h1><p>使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。</span><br><span class="line">2.属性和属性值以“键值对”的形式出现。</span><br><span class="line">3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</span><br><span class="line">4.属性和属性值之间用英文“:”连接。</span><br><span class="line">5.多个“键值对”之间用英文“;”进行区分。</span><br><span class="line">可以用段落 和 表格的对齐的演示。</span><br></pre></td></tr></table></figure><h1 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h1><h2 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h2><p>标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;  或者</span><br><span class="line">元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。</p><p>标签选择器 可以把某一类标签全部选择出来  div  span  </p><h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签调用的时候用 class=“类名”  即可。</span><br></pre></td></tr></table></figure><p>类选择器最大的优势是可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 </p><p>小技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.长名称或词组可以使用中横线来为选择器命名。</span><br><span class="line">2.不建议使用“_”下划线来命名CSS选择器。</span><br></pre></td></tr></table></figure><p>​    输入的时候少按一个shift键;<br>　浏览器兼容问题 (比如使用<em>tips的选择器命名，在IE6是无效的)<br>　能良好区分JavaScript变量命名(JS变量命名是用“</em>”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.不要纯数字、中文等命名， 尽量使用英文字母来表示。</span><br></pre></td></tr></table></figure><h2 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h2><p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。</span><br><span class="line">2. 各个类名中间用空格隔开。</span><br></pre></td></tr></table></figure><p>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pink fontWeight font20"</span>&gt;</span>亚瑟<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font20"</span>&gt;</span>刘备<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font14 pink"</span>&gt;</span>安其拉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font14"</span>&gt;</span>貂蝉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。</p><p>用法基本和类选择器相同。</p><h2 id="id选择器和类选择器区别"><a href="#id选择器和类选择器区别" class="headerlink" title="id选择器和类选择器区别"></a>id选择器和类选择器区别</h2><p>W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。</p><p>类选择器（class） 好比人的名字，  是可以多次重复使用的， 比如  张伟  王伟  李伟  李娜</p><p>id选择器     好比人的身份证号码，  全中国是唯一的， 不得重复。 只能使用一次。</p><p><strong><em>id选择器和类选择器最大的不同在于 使用次数上。</em></strong></p><h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><p>通配符   选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;                    <span class="comment">/* 定义外边距*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;                   <span class="comment">/* 定义内边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>——转学习黑马过程中的笔记——</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6学习笔记2</title>
      <link href="/2019/03/23/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2019/03/23/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="es6学习笔记2"><a href="#es6学习笔记2" class="headerlink" title="es6学习笔记2"></a>es6学习笔记2</h1><a id="more"></a><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="字符串的Unicode码表示"><a href="#字符串的Unicode码表示" class="headerlink" title="字符串的Unicode码表示"></a>字符串的Unicode码表示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原本的JavaScript只能支持\u0000-\uffff的码点，超出这个范围就不能正确解析，在es6中只要将码点放到大括号就能正确解析</span><br></pre></td></tr></table></figure><h3 id="codePointAt-字符串编码"><a href="#codePointAt-字符串编码" class="headerlink" title="codePointAt()字符串编码"></a>codePointAt()字符串编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一般默认的字符是2个字节存储，对于多于\u0000-\uffff的字符，这个存储需要四个字节，因此JavaScript会将其理解为两个字符，这样的话chatAt()就无法读取正确的值，charCodeAt()读取到的也是2个字节的十进制码</span><br><span class="line">所以为了能够正确解读，便可以采用codePointAt()方法</span><br><span class="line">这个方法返回的是UTF-16的十进制码点，如果需要转化可以使用toString</span><br><span class="line">s.codePointAt().toString(16)</span><br></pre></td></tr></table></figure><h3 id="String-formCodePoint"><a href="#String-formCodePoint" class="headerlink" title="String.formCodePoint()"></a>String.formCodePoint()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaScript提供了一种方法formCharCode(),用于将码点转化成为字符串，但是无法转化UTF-16的字符，即不在\u0000-\uffff范围的字符串无法解析</span><br><span class="line">因此es6提供了一种forCharCode()方法，用于转换这些字符</span><br><span class="line">这个字符串可以有多个参数，返回的时候将这几个参数转化后形成字符串返回</span><br></pre></td></tr></table></figure><h3 id="字符串的遍历接口"><a href="#字符串的遍历接口" class="headerlink" title="字符串的遍历接口"></a>字符串的遍历接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在es6可以使用for of语句去遍历字符串</span><br><span class="line">for (let codePoint of &apos;foo&apos;) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line">// &quot;f&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line">但是用for语句就不能遍历UTF-16的编码字符，因为会误以为一个字符是两个字符</span><br></pre></td></tr></table></figure><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在JavaScript提供合成语调符号和字符的方法合成Ǒ（\u004F\u030C）</span><br><span class="line">但是这种方式无法让JavaScript识别，就是说Unicode本身提供的语调字符和合成之后的字符无法===</span><br><span class="line">但是如果使用了normalize就可以===</span><br><span class="line">&apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize()//true</span><br></pre></td></tr></table></figure><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">includes()：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line">startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line">endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br><span class="line"></span><br><span class="line">let s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;Hello&apos;) // true</span><br><span class="line">s.endsWith(&apos;!&apos;) // true</span><br><span class="line">s.includes(&apos;o&apos;) // true</span><br><span class="line"></span><br><span class="line">可以传参数，表示开始查找的位置</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat方法返回一个新字符串，表示将原字符串重复n次。</span><br><span class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</span><br><span class="line">&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;</span><br><span class="line">&apos;na&apos;.repeat(0) // &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd"></a>padStart()，padEnd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">padStart()用于头部补全，padEnd()用于尾部补全</span><br><span class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</span><br><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line"></span><br><span class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br><span class="line">如果第一个参数小于x的长度，则返回原字符串</span><br><span class="line">可用于补全字节</span><br></pre></td></tr></table></figure><h3 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matchAll方法返回一个正则表达式在当前字符串的所有匹配</span><br></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JavaScript的模板需要写的格式比较麻烦，一般用+ +来写</span><br><span class="line">eg:</span><br><span class="line">$(&apos;#result&apos;).append(</span><br><span class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</span><br><span class="line">  &apos;items in your basket, &apos; +</span><br><span class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</span><br><span class="line">  &apos;&lt;/em&gt; are on sale!&apos;</span><br><span class="line">);</span><br><span class="line">但是es6引入了模板字符串</span><br><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br><span class="line">主要使用``来写还有$&#123;&#125;来拼</span><br><span class="line">当在模板字符串需要使用``时则需要使用转义符</span><br><span class="line">如果$&#123;&#125;使用的变量没有定义的话就会报错的</span><br><span class="line">用模板字符串所写的模板空格会保留，如果想要去掉空格，需要使用trim()方法</span><br><span class="line">模板字符串还可以用来嵌套</span><br><span class="line">const tmpl = addrs =&gt; `</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">  $&#123;addrs.map(addr =&gt; `</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">  `).join(&apos;&apos;)&#125;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲5</title>
      <link href="/2019/03/22/angular%E7%B2%BE%E8%AE%B25/"/>
      <url>/2019/03/22/angular%E7%B2%BE%E8%AE%B25/</url>
      
        <content type="html"><![CDATA[<p>#Angular路由精讲5，主要讲的是服务的依赖注入</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">angular框架就是一个IOC容器(实现了控制反转的容器)</span><br></pre></td></tr></table></figure><h4 id="使用依赖注入的好处"><a href="#使用依赖注入的好处" class="headerlink" title="使用依赖注入的好处"></a>使用依赖注入的好处</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使得代码松耦合、提高代码的复用性(有点类似于在某处看过的服务啊，不知道是不是一个东西)补充：好像就是服务</span><br><span class="line">提高可测试</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1553221665384.png" alt="1553221665384"></p><h4 id="注入器"><a href="#注入器" class="headerlink" title="注入器"></a>注入器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个组件都有一个注入器，负责注入组件需要的对象，自动调用构造函数去实例化</span><br><span class="line">constructor(private productService:ProductService:ProductService)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="提供器"><a href="#提供器" class="headerlink" title="提供器"></a>提供器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//为了让注入器知道如何实例化</span><br><span class="line">providers:[ProductService]</span><br><span class="line">// 即providers:[&#123;provide:ProductService,useClass:ProductService&#125;]简写版</span><br><span class="line">//providers:[&#123;provider:ProductService,useClass:AnotherProductService&#125;]</span><br><span class="line">//providers:[&#123;provide:ProductService,useFactory:()=&gt;&#123;……&#125;&#125;]</span><br></pre></td></tr></table></figure><h3 id="写个程序吧"><a href="#写个程序吧" class="headerlink" title="写个程序吧"></a>写个程序吧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不用之前的项目了，我们新建一个项目吧</span><br><span class="line">ng new &quot;project&quot;</span><br><span class="line">然后建个组件</span><br><span class="line">ng g c product1</span><br><span class="line">然后来建一个服务，具体服务是什么我这步学习中没讲，不过之前看过另一个课程，有兴趣的可以去专门学习一下什么是服务</span><br><span class="line">ng g service shared/product//这是可以在多个组件中共享的东西，相当于封装函数</span><br><span class="line">现在建立了一个组件和一个服务，这个时候服务还没有注入</span><br></pre></td></tr></table></figure><p>找到product.service.ts</p><p>可以看到基本的服务结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular&apos;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class ProductService&#123;</span><br><span class="line">constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们使用这个服务是用来获取商品信息的，所以我们需要在服务中声明一个Product来封装产品信息的类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class Product&#123;</span><br><span class="line">    constructor(//用构造函数来声明字段</span><br><span class="line">    public id:number,</span><br><span class="line">    public title:string,</span><br><span class="line">    public price:number;</span><br><span class="line">    public desc:string;</span><br><span class="line">    )&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明类之后我们需要在ProductService类声明一个方法去返回刚刚建的对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getProduct():Product&#123;//这里就不查询数据库了，就直接new一个product</span><br><span class="line">   return new Product(0,&quot;iPhone7&quot;,5899,&quot;最新苹果手机&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>现在服务的版本就说完了</li></ol><p>然后需要模块的声明</p><p>找到app.module.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">providers:[ProductService],//一般会自动引</span><br></pre></td></tr></table></figure><ol start="4"><li>改造product.component.ts，这里涉及依赖注入</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在组件的类声明一个product：Product；用来接收从服务获取的数据</span><br><span class="line">然后在构造函数以依赖注入的方式，声明服务</span><br><span class="line">constructor(private productService:ProductService)&#123;&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.product=this.productService.getProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>写组件的模板,只需要展示商品信息即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;商品详情&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;名称：&#123;&#123;product.title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;价格：&#123;&#123;product.price&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;描述：&#123;&#123;product.desc&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样模板就写完了</p><ol start="6"><li>然后我们来写一下app.component.ts的模板，来使用刚刚写的组件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;基本的依赖注入&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;app-product1&gt;&lt;/app-product1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样就写完了，就是服务，借用商品组件的构造函数，注入到商品组件，然后使用服务的getProduct方法获取所有的值，然后赋值给组件的一个变量，然后在模板写变量数据</p><p>这个例子我们将服务声明在了模块当中，提供器也可以声明在组件</p><h4 id="我们建一个组件"><a href="#我们建一个组件" class="headerlink" title="我们建一个组件"></a>我们建一个组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng g c product2</span><br><span class="line">//建一个服务</span><br><span class="line">ng g service shared/anotherProduct</span><br></pre></td></tr></table></figure><ol><li>写服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">需要用这个服务来实现刚刚写的product的service</span><br><span class="line">import &#123;Injectable&#125; from &apos;@angular&apos;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class AnotherProductService implements ProductService&#123;</span><br><span class="line">getProduct():Product&#123;//实现就要继承刚刚的方法</span><br><span class="line">return new Product(1,&quot;iPhone8&quot;,6000,&quot;最新苹果手机&quot;)</span><br><span class="line">//这里也直接返回一个商品对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后写一下Product2.component.ts</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//控制器的代码和Product1的相似</span><br><span class="line">在组件的类声明一个product：Product；用来接收从服务获取的数据</span><br><span class="line">然后在构造函数以依赖注入的方式，声明服务</span><br><span class="line">constructor(private productService:ProductService)&#123;&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.product=this.productService.getProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分和Product1.component.ts的不同就是要在这里去依赖注入服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在@Component(&#123;&#125;)写</span><br><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,useClass:AnotherProductService</span><br><span class="line">&#125;]//这时就像刚刚讲的，你虽然是同一个实例名称，但已经是实例化的另外一个服务了，当然之前的那个实例也不会修改，ProductService称为token</span><br></pre></td></tr></table></figure><ol start="3"><li>然后直接将Product1的模板拿过来</li><li>修改app.component.html，使用新组件</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>当一个提供器声明正在模块时，所有组件都可见，虽然product1这个组件没有声明product1这个注入器，但是是可以使用模块所注入的服务的 </li><li>当一个提供器声明在组件中时，只对声明的组件及其子组件可见，其他组件不可以注入</li><li>当声明在模块中和组件中的提供器具有相同的token时，组件的提供器会覆盖模块的提供器，所以Product2的组件会使用AnotherProductService这个服务</li><li>一般情况下，优先声明咋模块，只有规定其他模块不可见时，才能声明在组件(不常用)</li><li>在Product.service.ts的类写了一个@Injectable()的装饰器，是说这个ProductService也可以构造函数注入其他服务，意思是，这个构造器可以把其他服务放到这个服务来，但是不能整到其他地方，这个服务能不能注到其他组件是由在模块是否声明来决定的，</li></ol><h4 id="服务之间如何相互注入"><a href="#服务之间如何相互注入" class="headerlink" title="服务之间如何相互注入"></a>服务之间如何相互注入</h4><p>新建一个服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ng g service share/logger</span><br><span class="line">在类写</span><br><span class="line">log(message:string)&#123;</span><br><span class="line">console.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Product.service的构造函数去注入刚刚的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular&apos;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class ProductService&#123;</span><br><span class="line">constructor(public logger:LoggerService)&#123;&#125;</span><br><span class="line">getProduct():Product&#123;</span><br><span class="line">this.logger.log(&quot;调用方法&quot;)；</span><br><span class="line">//现在运行肯定不能打印</span><br><span class="line">需要在模块中将这个服务声明一下</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法或值对象来声明提供器"><a href="#工厂方法或值对象来声明提供器" class="headerlink" title="工厂方法或值对象来声明提供器"></a>工厂方法或值对象来声明提供器</h3><h4 id="使用工厂函数来声明提供器"><a href="#使用工厂函数来声明提供器" class="headerlink" title="使用工厂函数来声明提供器"></a>使用工厂函数来声明提供器</h4><p>根据随机数来确定是实例化哪个服务</p><ol><li>先去掉product2.component.ts的providers声明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//现在product1.和product2都使用模块的provider提供器</span><br><span class="line">把模块的提供器声明改成这样</span><br><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,</span><br><span class="line">    useFactory:()=&gt;&#123;</span><br><span class="line">        let logger=new LoggerService();</span><br><span class="line">        let dev=Math.random()&gt;0.5;</span><br><span class="line">        if(dev)&#123;</span><br><span class="line">return new ProductService(logger);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return new AnotherProductService(logger)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;，loggerService],</span><br></pre></td></tr></table></figure><p>然后把anotherProduct.service.ts的构造器改一下</p><p>constructor(public logger:Logger){}//讲真这步还没整懂，哦，看懂了，上一步忘了写了而已</p><p>然后在刷新，显示的两个组件就有两个组件，但是两个组件都是相同的，所以工厂方法的对象都是同一个对象。</p><p>我们在方法手工实例化了一个LoggerService,这意味着我们的对象与LoggerService的耦合度很高，实际上我们已经声明了LoggerService的提供器，那如何在工厂方法使用声明过的提供器呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,</span><br><span class="line">    useFactory:(logger:LoggerService)=&gt;&#123;//这步改这里</span><br><span class="line">        let dev=Math.random()&gt;0.5;</span><br><span class="line">        if(dev)&#123;</span><br><span class="line">return new ProductService(logger);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return new AnotherProductService(logger)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deps:[LoggerService]</span><br><span class="line">&#125;，loggerService],</span><br></pre></td></tr></table></figure><ol start="2"><li>实例化哪个对象是由随机数决定的，开发的时候是不能这样写的，开发可能需要一个变量，那变量是否可以像服务一样注入呢？看代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">加一个提供器</span><br><span class="line">&#123;</span><br><span class="line">provide：&quot;IS_DEV_ENV&quot;,</span><br><span class="line">useValue:false;//要注入的东西就是一个值false</span><br><span class="line">&#125;</span><br><span class="line">//然后在useFactory那家另一个参数isDev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,</span><br><span class="line">    useFactory:(logger:LoggerService,isDev)=&gt;&#123;//这步改这里</span><br><span class="line">      </span><br><span class="line">        if(isdev)&#123;</span><br><span class="line">return new ProductService(logger);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return new AnotherProductService(logger)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deps:[LoggerService,IS_DEV_ENV]</span><br><span class="line">&#125;，loggerService],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//也可以改造变量注入</span><br><span class="line">&#123;</span><br><span class="line">provide：&quot;IS_DEV_ENV&quot;,</span><br><span class="line">useValue:&#123;isDev:false&#125;;//要注入的东西就是一个值false</span><br><span class="line">&#125;</span><br><span class="line">这样判断的时候就是isdev.isDev</span><br></pre></td></tr></table></figure><h3 id="注入器的层级关系"><a href="#注入器的层级关系" class="headerlink" title="注入器的层级关系"></a>注入器的层级关系</h3><p>项目启动，angular就会创建一个应用级注入器，将模块的提供器都注册到注入器，注册地提供器包含声明的和依赖的其他模块的提供器都会注册，然后angular会创建启动模块指着的主组件，也就是app.component,同时应用级注入器会为组件创建一个主组件注入器，然后将组件声明的提供器注册到这个注入器，然后在组件模板会引其他子组件，子组件创建时，也会为子组件创建一个注入器，然后将在子组件声明的提供器注册。</p><p><code>注入只在构造函数</code></p><h3 id="改造我们的竞拍商城"><a href="#改造我们的竞拍商城" class="headerlink" title="改造我们的竞拍商城"></a>改造我们的竞拍商城</h3><ol><li>编写ProductService包含三个方法：getProducts()，getProduct(id),getCommentForProduct(id)</li><li>修改路由配置，在从商品列表到达商品详情时不再传递商品名称，改为传递商品id</li><li>注入ProductService使用服务</li></ol><p><img src="C:\Users\28715\AppData\Local\Temp\1553246262003.png" alt="1553246262003"></p><p><img src="C:\Users\28715\AppData\Local\Temp\1553246273205.png" alt="1553246273205"></p><p><img src="C:\Users\28715\AppData\Local\Temp\1553246333057.png" alt="1553246333057"></p><p><img src="C:\Users\28715\AppData\Local\Temp\1553247208269.png" alt="1553247208269"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3学习笔记2</title>
      <link href="/2019/03/21/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2019/03/21/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<p>CSS3学习笔记02</p><a id="more"></a><h2 id="CSS3过渡"><a href="#CSS3过渡" class="headerlink" title="CSS3过渡"></a>CSS3过渡</h2><p>过渡是指元素从一种样式逐渐改变为另外一种样式</p><p>重点在于设置时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如给div设置一个：hover的width，height的样式，然后在div的样式哪里设置时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transition//过渡属性，简写</span><br><span class="line">transition-property//指CSS属性的名称</span><br><span class="line">transition-duration//过渡效果需要的时间</span><br><span class="line">transition-timing-function//liner匀速</span><br><span class="line">transition-delay//过渡效果延迟时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transition-property: width;</span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以选择简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transition: width 1s linear 2s;</span><br><span class="line">/* Firefox 4 */</span><br><span class="line">-moz-transition:width 1s linear 2s;</span><br><span class="line">/* Safari and Chrome */</span><br><span class="line">-webkit-transition:width 1s linear 2s;</span><br><span class="line">/* Opera */</span><br><span class="line">-o-transition:width 1s linear 2s;</span><br><span class="line">&#125;//顺便了解一下不同浏览器的方式</span><br></pre></td></tr></table></figure><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><ol><li>CSS动画需要创建@keyframe</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@keyframes test&#123;//指定动画名称</span><br><span class="line">from &#123;background: red;&#125;</span><br><span class="line">to &#123;background: yellow;&#125;</span><br><span class="line">//如果需要多个效果则可以使用</span><br><span class="line">//20%，40%，60%……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes test2&#123;</span><br><span class="line">0% &#123;background:red;left:0px;top:0px;&#125;</span><br><span class="line">25% &#123;background:yellow;left:200px;top:0px;&#125;</span><br><span class="line">50% &#123;background:blue;left:200px;top:200px;&#125;</span><br><span class="line">75% &#123;background:green;left:0px;top:200px;&#125;</span><br><span class="line">100% &#123;background:red;left:0px;top:0px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>将这个动画绑定到相关元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">animation:test 5s;//设置动画执行时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="CSS3动画属性"><a href="#CSS3动画属性" class="headerlink" title="CSS3动画属性"></a>CSS3动画属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">animation//设置动画属性的简写</span><br><span class="line">animation-name//设置动画名称</span><br><span class="line">animation-duration//设置动画执行时间</span><br><span class="line">animation-timing-function://设置动画的执行速率，liner为匀速，ease为匀加速</span><br><span class="line">animation-delay//设置动画的什么时候执行</span><br><span class="line">animation-iteration-count//设置动画执行次数</span><br><span class="line">animation-direction//设置动画的方向 normal，alternate</span><br><span class="line">animation-play-state//设置动画是否正在执行</span><br><span class="line">animation-fill-mode//设置动画时间之外forwards保持最后的属性，backwards返回开始属性</span><br></pre></td></tr></table></figure><h2 id="CSS3多列"><a href="#CSS3多列" class="headerlink" title="CSS3多列"></a>CSS3多列</h2><p>感觉像是将一个div当成三个div来用</p><h3 id="column-count用于设置列数"><a href="#column-count用于设置列数" class="headerlink" title="column-count用于设置列数"></a>column-count用于设置列数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">column-count:3;//将一个div分成了三个部分，如果是文字的话就会出现3列文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="column-gap用于设置列间隔"><a href="#column-gap用于设置列间隔" class="headerlink" title="column-gap用于设置列间隔"></a>column-gap用于设置列间隔</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">column-gap:40px;//用于规定列之间的间隔，间隔大的话，列就窄</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="column-rule用于设置列之间的宽度、样式和颜色"><a href="#column-rule用于设置列之间的宽度、样式和颜色" class="headerlink" title="column-rule用于设置列之间的宽度、样式和颜色"></a>column-rule用于设置列之间的宽度、样式和颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">column-rule:3px outset #ff0000;//就是在列之间加线的演示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多列属性"><a href="#多列属性" class="headerlink" title="多列属性"></a>多列属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">column-count:number|auto;//多少列|由属性例如column-width决定列数</span><br><span class="line">column-fill：balance|auto;//按照文字多少每列分配多少字符|按顺序分配字符</span><br><span class="line">column-gap:length|normal;//指定宽度|默认1em</span><br><span class="line">column-rule//设置样式，可单独设置column-rule-width</span><br><span class="line">column-span:1|all//设置元素横跨的列数</span><br><span class="line">column-width:auto|length;//由浏览器设置列宽|设置列的宽度</span><br><span class="line">column：column-width column-count;//简写</span><br></pre></td></tr></table></figure><h2 id="CSS3用户界面"><a href="#CSS3用户界面" class="headerlink" title="CSS3用户界面"></a>CSS3用户界面</h2><h3 id="CSS3-Resizing"><a href="#CSS3-Resizing" class="headerlink" title="CSS3 Resizing"></a>CSS3 Resizing</h3><p>用于规定元素是否可由用户调整大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">resize:both;</span><br><span class="line">overflow:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>用于设置以确切的方式设置某个区域的具体content</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    box-sizing:border-box;</span><br><span class="line">    width:50%;</span><br><span class="line">    float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing:content-box;//宽度和高度应用于内容框。在宽度和高度外设置编剧和边框</span><br><span class="line">box-sizing:border-box;//元素的高度宽度包含边距和边框</span><br></pre></td></tr></table></figure><h3 id="outline-offset"><a href="#outline-offset" class="headerlink" title="outline offset"></a>outline offset</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">border:2px solid black;</span><br><span class="line">outline:2px solid red;</span><br><span class="line">outline-offset:15px;</span><br><span class="line">&#125;//为元素设置外部轮廓</span><br></pre></td></tr></table></figure><h3 id="用户界面属性"><a href="#用户界面属性" class="headerlink" title="用户界面属性"></a>用户界面属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appearance:button|normal|icon|window|menu|field;</span><br><span class="line">  按钮样式|普通元素|图标|视窗|选项|字段</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲4</title>
      <link href="/2019/03/21/angular%E7%B2%BE%E8%AE%B24/"/>
      <url>/2019/03/21/angular%E7%B2%BE%E8%AE%B24/</url>
      
        <content type="html"><![CDATA[<h1 id="angular精讲4"><a href="#angular精讲4" class="headerlink" title="angular精讲4"></a>angular精讲4</h1><a id="more"></a><h3 id="接下来我们完善一下之前做的商品竞拍案例，添加路由"><a href="#接下来我们完善一下之前做的商品竞拍案例，添加路由" class="headerlink" title="接下来我们完善一下之前做的商品竞拍案例，添加路由"></a>接下来我们完善一下之前做的商品竞拍案例，添加路由</h3><p>当用户点击某个商品时，商品区域应该替换掉，显示商品的详情</p><ol><li>创建一个商品详情组件，显示商品的图片和标题</li><li>重构代码，把轮播图组件和商品列表组件封装到一个新的Home组件</li><li>配置路由，在导航到商品详情组件时传递商品的标题参数</li><li>修改APP组件，根据路由显示home组件或商品详情组件</li><li>修改商品的列表组件，给商品标题添加routeLink指令，从而指向路由</li></ol><ol><li><p>创建一个商品详情组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c product-detail</span><br></pre></td></tr></table></figure><p>因为商品标题是外部组件传过来的，所以需要声明一个标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">productTitle:string;</span><br><span class="line">//既然要接受外面穿过来的参数，则</span><br><span class="line">constructor(private routeInfo:ActivateRoute)&#123;&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productTitle=this.routeInfo.snapshot.params[&quot;prodTitle];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器写完啦</p><p>写商品详情组件模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;img src=&quot;http://placehold.it/820x230&quot;&gt;</span><br><span class="line">&lt;h4&gt;&lt;&#123;&#123;productTitle&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建home组件，封装轮播图以及商品商品组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ng g c home</span><br><span class="line">//然后在home组件的模板</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;//这片区域分成两个行</span><br><span class="line">&lt;app-carousel&gt;&lt;/app-carousel&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;app-product&gt;&lt;/app-product&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">将两个组件放到这一个组件即可</span><br><span class="line">相应的要把组件的css文件也要粘贴过来</span><br></pre></td></tr></table></figure></li><li><p>增加路由</p><p>在app.module.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const routeConfig:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component:&apos;HomeComponent&apos;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product/prodTitle&apos;,</span><br><span class="line">component:ProductDetailComponet</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">记得在import属性添加这个路由配置</span><br><span class="line">写上RouterMoudule.forRoot(routeConfig)</span><br><span class="line">//子模块路由需要写forChild</span><br></pre></td></tr></table></figure></li><li><p>在之前显示轮播图和商品组件的位置放置占位符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br></pre></td></tr></table></figure></li><li><p>增加路由链接</p><p>在商品组件的模板，给路由标题添加路由链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;&lt;a routerLink=[&apos;/product&apos;,product.title&gt;&#123;&#123;product.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;</span><br></pre></td></tr></table></figure><p>基本的改造就完成了</p></li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>angular自动处理对象的创建过程</p><p>每个angular程序都是组件、指令和依赖的类的集合，虽然每个组件都可以实例化依赖，但是angular提供了一种依赖注入模式去实例化</p><h3 id="依赖注入模式要解决的问题"><a href="#依赖注入模式要解决的问题" class="headerlink" title="依赖注入模式要解决的问题"></a>依赖注入模式要解决的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">依赖注入：DI,假设你写了一个方法，这个方法的参数是一个对象，当你调用这个对象时你需要实例化这个对象，而且将其传递给方法，也就是将参数注入给这个方法</span><br><span class="line"></span><br><span class="line">如果一个对象A要依赖一个类型为B的一个对象，那么A不需要明确的以new的方式去实例化B,B会由外部机制去注入，对象A只需要喊话：我需要一个B类型的对象，有没有人能给我一个。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制反转IOC</span><br><span class="line">这是一个经常与依赖注入同时出现的另外一个说法</span><br><span class="line">是指将依赖的控制权将从代码内部，转到外部</span><br><span class="line">例如</span><br><span class="line">var product = new Prouct()//这是内部决定，决定product依赖Product,如果想要依赖别的那我需要改掉这一行代码，而如果控制反转，则内部代码只需要喊话，我需要porduct，至于传过来的是Product还是别的实例化的，是由代码外部决定的。这时候依赖的控制权就转移到了外部。</span><br></pre></td></tr></table></figure><p>这两个说法表达的是一个思想，控制反转侧重于表达一个目的，即转移代码控制权</p><p>而依赖注入描述手段，即如何来实现控制反转，使用的手段叫做，依赖注入</p>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3学习笔记</title>
      <link href="/2019/03/20/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/20/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>css3学习笔记01</p><a id="more"></a><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="CSS3边框"><a href="#CSS3边框" class="headerlink" title="CSS3边框"></a>CSS3边框</h2><p>关键词</p><ul><li>border-radius//支持当前主流浏览器</li><li>box-shadow//支持当前主流浏览器</li><li>border-image//不支持ie</li></ul><h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键指令：border-radius</span><br></pre></td></tr></table></figure><h3 id="边框shadow"><a href="#边框shadow" class="headerlink" title="边框shadow"></a>边框shadow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键指令box-shadow</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">div&#123;</span><br><span class="line">box-shadow:10px 10px 5pa #888888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">border-image:url(border.png) 30 30 round;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3背景"><a href="#CSS3背景" class="headerlink" title="CSS3背景"></a>CSS3背景</h2><h3 id="background-size属性"><a href="#background-size属性" class="headerlink" title="background-size属性"></a>background-size属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前背景图片的大小都是根据图片实际尺寸决定的，CSS3中可规定</span><br></pre></td></tr></table></figure><h3 id="background-origin属性"><a href="#background-origin属性" class="headerlink" title="background-origin属性"></a>background-origin属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来规定背景图片的定位区域</span><br><span class="line">background-origin：content-box;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1553075366907.png" alt="1553075366907"></p><h3 id="CSS3多重背景图片"><a href="#CSS3多重背景图片" class="headerlink" title="CSS3多重背景图片"></a>CSS3多重背景图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">&#123; </span><br><span class="line">background-image:url(bg_flower.gif),url(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背景的绘制区域"><a href="#背景的绘制区域" class="headerlink" title="背景的绘制区域"></a>背景的绘制区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">background-color:yellow;//这个属性重在绘制</span><br><span class="line">background-clip:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3文本效果"><a href="#CSS3文本效果" class="headerlink" title="CSS3文本效果"></a>CSS3文本效果</h2><h3 id="Text-shadow"><a href="#Text-shadow" class="headerlink" title="Text-shadow"></a>Text-shadow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">    text-shadow:5px 5px 5px #FF0000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本换行"><a href="#文本换行" class="headerlink" title="文本换行"></a>文本换行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">word-wrap:break-word;//当单词长度超出div时自动拆分</span><br><span class="line">&#125;</span><br><span class="line">//normal使用浏览器默认换行规则</span><br><span class="line">//break-all允许在单词内换行</span><br><span class="line">//keep-all只能再半角空格或者字符串换行</span><br></pre></td></tr></table></figure><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//normal使用浏览器默认换行规则</span><br><span class="line">//break-all允许在单词内换行</span><br><span class="line">//keep-all只能再半角空格或者字符串换行</span><br></pre></td></tr></table></figure><h3 id="省略符号text-overflow属性"><a href="#省略符号text-overflow属性" class="headerlink" title="省略符号text-overflow属性"></a>省略符号text-overflow属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.test</span><br><span class="line">&#123;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">&#125;</span><br><span class="line">//当属性为clip时，直接修建文本</span><br><span class="line">//当属性为string时，使用字符串来代替修剪的文本</span><br></pre></td></tr></table></figure><h2 id="CSS3字体"><a href="#CSS3字体" class="headerlink" title="CSS3字体"></a>CSS3字体</h2><h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不仅使用自己电脑字体还可以使用喜欢的任何字体</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; </span><br><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">font-family: myFirstFont;</span><br><span class="line">src: url(&apos;Sansation_Light.ttf&apos;),</span><br><span class="line">     url(&apos;Sansation_Light.eot&apos;); /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">font-family:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>若需要字体改变例如bold</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">font-family: myFirstFont;</span><br><span class="line">src: url(&apos;Sansation_Bold.ttf&apos;),</span><br><span class="line">     url(&apos;Sansation_Bold.eot&apos;); /* IE9+ */</span><br><span class="line">font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">translate()</span><br><span class="line">rotate()</span><br><span class="line">scale()</span><br><span class="line">skew()</span><br><span class="line">matrix()</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">transform:rotate(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="translate-方法移动"><a href="#translate-方法移动" class="headerlink" title="translate()方法移动"></a>translate()方法移动</h3><p>用于元素的移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: translate(50px,100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotate旋转"><a href="#rotate旋转" class="headerlink" title="rotate旋转"></a>rotate旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//div顺时针旋转30度</span><br></pre></td></tr></table></figure><h3 id="scale转换元素大小"><a href="#scale转换元素大小" class="headerlink" title="scale转换元素大小"></a>scale转换元素大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户转换元素大小</span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: scale(2,4);</span><br><span class="line">&#125;</span><br><span class="line">值 scale(2,4) 把宽度转换为原始的 2 倍，把高度转换为原始高度的 4 倍。</span><br></pre></td></tr></table></figure><h3 id="Skew（3D旋转）"><a href="#Skew（3D旋转）" class="headerlink" title="Skew（3D旋转）"></a>Skew（3D旋转）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//按照水平X轴和垂直线Y轴去旋转元素</span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: skew(30deg,20deg);</span><br><span class="line">&#125;</span><br><span class="line">值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。</span><br><span class="line">//skweX(angle)</span><br><span class="line">//skweY(angle)</span><br></pre></td></tr></table></figure><h3 id="matrix-转化效果集成"><a href="#matrix-转化效果集成" class="headerlink" title="matrix()转化效果集成"></a>matrix()转化效果集成</h3><p>matrix() 方法把所有 2D 转换方法组合在一起。</p><p>matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p>//用于定位旋转的基点位置</p><h2 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h2><h3 id="rotateX-元素围绕x轴以度数去旋转"><a href="#rotateX-元素围绕x轴以度数去旋转" class="headerlink" title="rotateX()元素围绕x轴以度数去旋转"></a>rotateX()元素围绕x轴以度数去旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: rotateX(120deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotateY-元素围绕Y轴以度数去旋转"><a href="#rotateY-元素围绕Y轴以度数去旋转" class="headerlink" title="rotateY()元素围绕Y轴以度数去旋转"></a>rotateY()元素围绕Y轴以度数去旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: rotateY(120deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3D与2D"><a href="#3D与2D" class="headerlink" title="3D与2D"></a>3D与2D</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2D转换方法除了skew之外，加上X,Y就变成了3D</span><br><span class="line">不加的情况下，直接在方法后写3D就行了，eg:translate3D</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲3</title>
      <link href="/2019/03/20/angular%E7%B2%BE%E8%AE%B23/"/>
      <url>/2019/03/20/angular%E7%B2%BE%E8%AE%B23/</url>
      
        <content type="html"><![CDATA[<h1 id="angular精讲3"><a href="#angular精讲3" class="headerlink" title="angular精讲3"></a>angular精讲3</h1><a id="more"></a><h4 id="辅助路由"><a href="#辅助路由" class="headerlink" title="辅助路由"></a>辅助路由</h4><p>若要使用辅助路由，在模板位置除了需要声明普通占位符外，还需要别的声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br><span class="line">&lt;router-outlet name=&quot;aux&quot;&gt;&lt;/router-outlet&gt;//带有name属性的占位符</span><br></pre></td></tr></table></figure><p>在路由的配置时需要这样的路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:&apos;xxx&apos;,</span><br><span class="line">    component:XxxComponent,</span><br><span class="line">    outlet:&quot;aux&quot;</span><br><span class="line">&#125;//声明在名字为aux的占位符的位置可以显示声明组件</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">    path:&apos;yyy&apos;,</span><br><span class="line">    component:yyyComponent,</span><br><span class="line">    outlet:&quot;aux&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在路由调用时需要这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,&#123;outlets:&#123;ayx:&apos;xxx&apos;&#125;&#125;]&quot;&gt;xxx&lt;/a&gt;</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;,&#123;outlets:&#123;ayx:&apos;yyy&apos;&#125;&#125;]&quot;&gt;yyy&lt;/a&gt;</span><br><span class="line">//表示在点击链接显示一个大组件和另一个组件，二者相对独立</span><br></pre></td></tr></table></figure><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ol><li>在app组件模板写一个占位符来显示聊天面板</li><li>单独开发一个聊天室组件，只定义在新的占位符</li><li>以路由参数来控制是否使用聊天面板</li></ol><ol><li><p>首先在APP的模板添加一个辅助占位符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet name=&quot;aux&quot;&gt;&lt;/router-outlet&gt;</span><br></pre></td></tr></table></figure></li><li><p>新建聊天组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c chat</span><br></pre></td></tr></table></figure><p>写组件模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea placeholder=&quot;请输入聊天内容&quot; class=&quot;chat&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>写样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.chat&#123;</span><br><span class="line">    background:blue;</span><br><span class="line">    height:100px;</span><br><span class="line">    width:30%;</span><br><span class="line">    float:left；</span><br><span class="line">    box-sizing:border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要将之前的Product的模板样式也做调整，这个看自己的需要，和angular关系不大</p></li><li><p>增加路由配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:&apos;chat&apos;,</span><br><span class="line">    component:ChatComponent,</span><br><span class="line">    outlet:&apos;aux&apos;</span><br><span class="line">&#125;这个路由会显示在名字为aux的占位符</span><br></pre></td></tr></table></figure><p>然后在app.html文件新增两个链接用来指向聊天的路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:&apos;chat&apos;&#125;&#125;]&quot;&gt;开始聊天&lt;/a&gt;</span><br><span class="line">&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:null&#125;&#125;]&quot;&gt;结束聊天&lt;/a&gt;//这样组件就不显示了</span><br></pre></td></tr></table></figure></li></ol><p>如果希望当路由在点击开始聊天链接时跳到home路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&#123;outlets:&#123;primary:&apos;home&apos;,aux:&apos;chat&apos;&#125;&#125;]&quot;&gt;开始聊天&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><ol><li>当用户已登录或拥有某些权限的时候才能使用某些路由</li><li>一个由多个表单组件组成的向导，例如注册流程，用户只有在当前路由的组件填写了满足要求的信息才能指向下一个路由</li><li>当用户没有执行保存而试图离开路由时提醒路由</li></ol><p>angular路由提供了一些钩子，实现这样的功能，这又称为路由守卫</p><h5 id="包括三种"><a href="#包括三种" class="headerlink" title="包括三种"></a>包括三种</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CanActivate：处理导航到某路由的情况，当不能满足要求不能使用路由</span><br><span class="line">CanDeactivate：处理从当前路由离开的情况，如果不能满足本路由要求就不能离开或提升</span><br><span class="line">Resolve：在激活路由前获取路由数据，在到达路由时就将数据展示给用户</span><br></pre></td></tr></table></figure><h5 id="使用：只让登录用户能够查看产品信息路由"><a href="#使用：只让登录用户能够查看产品信息路由" class="headerlink" title="使用：只让登录用户能够查看产品信息路由"></a>使用：只让登录用户能够查看产品信息路由</h5><ol><li>首先在app建一个目录，称为guard(守卫)</li><li>在目录建一个ts文件，login.guard.ts</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export class LoginGuard implements CanActivate&#123;</span><br><span class="line">CanActivate()&#123;//一些参数目前还用不到</span><br><span class="line">//angular会根据这个方法返回的是true还是false去判断是否执行路由</span><br><span class="line">let loggedIn:boolean=Math.random()&lt;0.5;</span><br><span class="line">//在这里使用随机数是否大于0.5来模拟用户是否登录</span><br><span class="line">if(!loggedIn)&#123;</span><br><span class="line">            console.log(&quot;用户未登录&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return loggedIn；</span><br><span class="line">&#125;</span><br><span class="line">//CanActivate只有这一个方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个登录守卫</p><p>此时需要修改路由配置，将其加到路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加子路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">children:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;&apos;,</span><br><span class="line">                component:ProductDescComponent</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;seller/:id&apos;,</span><br><span class="line">                component:SellerInfoComponent</span><br><span class="line">            &#125;</span><br><span class="line">],canActivate:[LoginGuard]//可以在这里设置多个路由守卫，这些守卫会依次调用，如果一个为false那就不能使用路由</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们可以看到LoginGuard类没有实例化，那谁来实例化呢，可以使用依赖注入机制去实例化，详细稍后讲</span><br></pre></td></tr></table></figure><p>在@NgModule的provider:[]写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">providers:[LoginGuard]//这样就可以守卫商品信息路由了</span><br></pre></td></tr></table></figure><p>这样就写好了路由守卫</p><h5 id="写一个离开路由的守卫"><a href="#写一个离开路由的守卫" class="headerlink" title="写一个离开路由的守卫"></a>写一个离开路由的守卫</h5><p>在guard文件夹新建一个save.component.ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class save implements CanDeactivate&lt;ProductCompoent&gt;&#123;</span><br><span class="line">//写在括号的组件是指要保护的组件是这个组件</span><br><span class="line">CanDeactivate(component:ProductComponent&#125;)&#123;</span><br><span class="line">//根据组件的状态和属性去判断用户是否可以离开</span><br><span class="line">return window.confirm(&quot;你还没有保存，确定不保存吗&quot;);</span><br><span class="line">//用来模拟</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把守卫加到路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加子路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,</span><br><span class="line">component：ProductComponent,</span><br><span class="line">children:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;&apos;,</span><br><span class="line">                component:ProductDescComponent</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;seller/:id&apos;,</span><br><span class="line">                component:SellerInfoComponent</span><br><span class="line">            &#125;</span><br><span class="line">],</span><br><span class="line">canActivate:[LoginGuard],</span><br><span class="line">canDeactivate:[save]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在providers也记得加</p><h4 id="resolve守卫"><a href="#resolve守卫" class="headerlink" title="resolve守卫"></a>resolve守卫</h4><p>可用路由守卫传递数据，那就是使用resolve守卫</p><p>当想要到一个路由时，一般传统做法是，比如带着一个参数过去，但是在真正发送http请求时会有很大延迟，那你再页面获取的数据就会是空的，这样用户体验不好，resolve就是解决这个问题，</p><p>resolve是在到达路由之前就读取数据，之后带着数据到达路由，直接使用这些数据</p><p>在guard守卫文件夹再建一个product.resolve.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()//只有这个装饰器装饰了Router才能成功依赖注入，组件不用是因为组件已经集成了</span><br><span class="line">export class ProductResolve implements Resolve&lt;Product&gt;&#123;</span><br><span class="line">    //此处想要解析一个商品信息的数据集就传一个Product</span><br><span class="line">    constructor(private router:Router)</span><br><span class="line">    resolve(route：ActivatedRouteSnapshot,state:RouterStateSnapshot):Observable&lt;product&gt;|Promise&lt;Product&gt;|Product&#123;</span><br><span class="line">    let id:number=route.params[&quot;id&quot;];</span><br><span class="line">    if(productId==1)&#123;</span><br><span class="line">return new Product(1.&quot;iPhone7&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">this.router.navigate([&apos;/home&apos;])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//记得引包，需要Resolve和Product</span><br></pre></td></tr></table></figure><p>需要在product组件的ts文件去声明一个Product类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class Product&#123;</span><br><span class="line">constructor(public id:number,public name:string)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的路由建好之后要加到路由配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">    product:ProductResolve</span><br><span class="line">&#125;</span><br><span class="line">在providers也要加</span><br></pre></td></tr></table></figure><p>因为对象一个是id一个是name</p><p>商品属性只设置了id，所以要在商品的ts文件中再声明一个name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private productName:string;</span><br><span class="line">这时不是订阅params，而是订阅传递的数据，ngOnInit块写,</span><br><span class="line">this.routeInfo.data.subscribe（(data:&#123;product:Product&#125;)=&#123;</span><br><span class="line">   this.productId=data.product.id; </span><br><span class="line">   this.productName=data.product.name; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>记得在商品模板添加商品名称</p>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6学习笔记01</title>
      <link href="/2019/03/19/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/19/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="es6-阮一峰教程学习笔记"><a href="#es6-阮一峰教程学习笔记" class="headerlink" title="es6(阮一峰教程学习笔记)"></a>es6(阮一峰教程学习笔记)</h1><a id="more"></a><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><h3 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h3><h4 id="普通解构"><a href="#普通解构" class="headerlink" title="普通解构"></a>普通解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">普通解构</span><br><span class="line">//es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这称为结构</span><br><span class="line">let [a,b,c]=[1,2,3]//a,b,c分别等于1,2,3</span><br><span class="line">//这种方法本质属于模式匹配</span><br></pre></td></tr></table></figure><h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">嵌套解构</span><br><span class="line">let [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">此时可解构为</span><br><span class="line">foo=1;</span><br><span class="line">bar=2;</span><br><span class="line">baz=3;</span><br></pre></td></tr></table></figure><h4 id="非对称解构"><a href="#非对称解构" class="headerlink" title="非对称解构"></a>非对称解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">非对称结构</span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">third=baz;</span><br><span class="line"></span><br><span class="line">let [x, , y]=[1,2,3]</span><br><span class="line">x=1;</span><br><span class="line">y=3;</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head=1；</span><br><span class="line">tail=[2, 3, 4]；</span><br><span class="line">//按照我的理解，...tail本身就应该是属于代表一个数组</span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;];</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br><span class="line">//但是如果前面的数据比后面多，那变量值就是undefined</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果等式右边不是可遍历的结构那么报错</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解构赋值允许使用默认值</span><br><span class="line">let [foo=true]=[];</span><br><span class="line">foo=true;</span><br><span class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br><span class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br><span class="line"></span><br><span class="line">//注意：等式右边的权重更大一点，但是右边如果是undefined，那么就取默认值</span><br><span class="line"></span><br><span class="line">//除此之外，默认值还可以使用已经赋值的其他变量，但是变量必须已声明</span><br><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><h4 id="与数组的不同"><a href="#与数组的不同" class="headerlink" title="与数组的不同"></a>与数组的不同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//数组的取值关系是按照排列顺序位置决定的，但是对象是按照属性的名字决定的取值。</span><br><span class="line">//那么这种情况下，变量名如果和属性名不一样的处理方式是，先在等式左边将变量名赋予属性名。</span><br><span class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &apos;hello&apos;</span><br><span class="line">l // &apos;world</span><br><span class="line"></span><br><span class="line">//所以真正赋值的是与属性名同名的变量罢了</span><br></pre></td></tr></table></figure><h4 id="嵌套解构-1"><a href="#嵌套解构-1" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;p: [&apos;Hello&apos;,&#123; y: &apos;World&apos; &#125;]&#125;;</span><br><span class="line">let &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br><span class="line"></span><br><span class="line">//这时p是模式，不是变量如果p也需要赋值的话</span><br><span class="line">let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br><span class="line">p // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span><br><span class="line"></span><br><span class="line">eg2：</span><br><span class="line">const node = &#123;loc: &#123;start: &#123;line: 1,column: 5&#125;&#125;&#125;;</span><br><span class="line">let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // Object &#123;start: Object&#125;</span><br><span class="line">start // Object &#123;line: 1, column: 5&#125;</span><br></pre></td></tr></table></figure><p>对象的解构也可以设置默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x: y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line">默认值的条件是右边对象的属性值严格等于undefined</span><br><span class="line">undefined就会触发函数参数的默认值。</span><br><span class="line">[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);</span><br><span class="line">// [ 1, &apos;yes&apos;, 3 ]</span><br></pre></td></tr></table></figure><h4 id="已声明的变量解构"><a href="#已声明的变量解构" class="headerlink" title="已声明的变量解构"></a>已声明的变量解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">let x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">let x;</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br><span class="line"></span><br><span class="line">//这是为了避免JavaScript将&#123;x&#125;当成一个代码块</span><br></pre></td></tr></table></figure><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//对字符串直接进行转化成数组赋值，同时也可以对字符串的属性进行赋值</span><br><span class="line">//字符串赋值</span><br><span class="line">const [a, b, c, d, e] = &apos;hello&apos;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br><span class="line"></span><br><span class="line">//属性赋值</span><br><span class="line">let &#123;length : len&#125; = &apos;hello&apos;;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure><h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//如果是数值和布尔值，那么先转成对象，但是undefined和null无法转化对象，就会报错</span><br><span class="line">let &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // true</span><br><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = true;</span><br><span class="line">s === Boolean.prototype.toString // true</span><br></pre></td></tr></table></figure><h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//相当于以解构赋值的方式传参</span><br><span class="line">function add([x, y])&#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br><span class="line"></span><br><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br></pre></td></tr></table></figure><p>map()拓展：</p><p><strong>map定义和方法</strong>  map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值。  map()方法按照原始数组元素顺序依次处理元素。 </p><h4 id="不得使用圆括号的情况"><a href="#不得使用圆括号的情况" class="headerlink" title="不得使用圆括号的情况"></a>不得使用圆括号的情况</h4><p>对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 </p><h5 id="变量声明语句"><a href="#变量声明语句" class="headerlink" title="变量声明语句"></a>变量声明语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">let [(a)] = [1];</span><br><span class="line"></span><br><span class="line">let &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line">let (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line">let &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">let &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure><h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f([(z)]) &#123; return z; &#125;</span><br><span class="line">// 报错</span><br><span class="line">function f([z,(x)]) &#123; return x; &#125;</span><br></pre></td></tr></table></figure><h5 id="赋值语句的模式"><a href="#赋值语句的模式" class="headerlink" title="赋值语句的模式"></a>赋值语句的模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>赋值语句的非模式部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。 </p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li><p>用于交换变量值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li><li><p>从函数返回多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = example();</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>函数参数的定义</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br></pre></td></tr></table></figure><ol><li>提取JSON数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br></pre></td></tr></table></figure><ol><li><p>给予参数的默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function () &#123;&#125;,</span><br><span class="line">  cache = true,</span><br><span class="line">  complete = function () &#123;&#125;,</span><br><span class="line">  crossDomain = false,</span><br><span class="line">  global = true,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>遍历Map结构</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</span><br><span class="line">map.set(&apos;second&apos;, &apos;world&apos;);</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key + &quot; is &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取键名</span><br><span class="line">for (let [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// 获取键值</span><br><span class="line">for (let [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>输入模块的指定方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲2</title>
      <link href="/2019/03/19/angular%E7%B2%BE%E8%AE%B22/"/>
      <url>/2019/03/19/angular%E7%B2%BE%E8%AE%B22/</url>
      
        <content type="html"><![CDATA[<p>#angular精讲2</p><a id="more"></a><h4 id="轮播图组件"><a href="#轮播图组件" class="headerlink" title="轮播图组件"></a>轮播图组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li class=&quot;active&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&lt;div class=&quot;carousel-inner&quot;&gt;</span><br><span class="line">&lt;div class=&quot;item active&quot;&gt;</span><br><span class="line">&lt;img class=&quot;slide-image&quot; src=&quot;http://placehold.it/800x300&quot; alt=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">&lt;img class=&quot;slide-image&quot; src=&quot;http://placehold.it/800x300&quot; alt=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">&lt;img class=&quot;slide-image&quot; src=&quot;http://placehold.it/800x300&quot; alt=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;a class=&quot;left carousel-control&quot; href=&quot;javascript:$(&apos;.carousel&apos;).carousel(&apos;prev&apos;)&quot;&gt;</span><br><span class="line">&lt;span class=&quot;glyphicon glyphicon-chevron-left&gt;&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;a class=&quot;rightcarousel-control&quot; href=&quot;javascript:$(&apos;.carousel&apos;).carousel(&apos;next&apos;)&quot;&gt;</span><br><span class="line">&lt;span class=&quot;glyphicon glyphicon-chevron-right&gt;&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">//这两个样式可以实现点击切换效果</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//写个slide-image的样式</span><br><span class="line">.slide-image&#123;</span><br><span class="line">width:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="商品列表组件（这个涉及angular）"><a href="#商品列表组件（这个涉及angular）" class="headerlink" title="商品列表组件（这个涉及angular）"></a>商品列表组件（这个涉及angular）</h4><ol><li><p>在产品组件中新建一个Product对象，存储产品信息，在product.component.ts直接新建一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">export class Product&#123;</span><br><span class="line">constructor(</span><br><span class="line">public id:number,</span><br><span class="line">public title:string,</span><br><span class="line">public price:number,</span><br><span class="line">public rating:number,</span><br><span class="line">public desc:string,</span><br><span class="line">public categories:Array&lt;string&gt;</span><br><span class="line">)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">然后在ProductComponent控制器声明一个数组，存储页面将要展示的商品信息数据</span><br><span class="line">export class ProductComponent implements OnInit&#123;</span><br><span class="line">private products:Array&lt;Product&gt;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.products:[//初始化数组</span><br><span class="line">new Product(1,&quot;第一个商品&quot;,1.99,3.5,&quot;这是一个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(2,&quot;第一个商品&quot;,1.99,2.5,&quot;这是二个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(3,&quot;第一个商品&quot;,1.99,1.5,&quot;这是三个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(4,&quot;第一个商品&quot;,1.99,4.5,&quot;这是四个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(5,&quot;第一个商品&quot;,1.99,3.5,&quot;这是五个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(6,&quot;第一个商品&quot;,1.99,5,&quot;这是六个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">]</span><br><span class="line">this.products.push(new Product(6,&quot;第一个商品&quot;,1.99,5,&quot;这是六个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]))//可以添加一个商品</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，产品组件建立好了，就得写一下产品组件的模板了(即html)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngFor=&quot;let product of products&quot; class=&quot;col-md-4 col-sm-4 col-lg-4&quot;&gt;</span><br><span class="line">&lt;div class=&quot;thumbnail&quot;&gt;</span><br><span class="line">&lt;img src=&quot;http://placehold.it/320x150&quot;&gt;</span><br><span class="line">&lt;div class=&quot;caption&quot;&gt;</span><br><span class="line">&lt;h4 class=&quot;pull-right&quot;&gt;&#123;&#123;product.price&#125;&#125;元&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;&lt;a&gt;&#123;&#123;product.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;product.desc&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;app-stars&gt;&lt;/app-stars&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h6 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngFor=&quot;let product of products&quot; class=&quot;col-md-4 col-sm-4 col-lg-4&quot;&gt;</span><br><span class="line">//第一个学习的指令*ngFor</span><br></pre></td></tr></table></figure><h4 id="星级评价组件"><a href="#星级评价组件" class="headerlink" title="星级评价组件"></a>星级评价组件</h4><ol><li><p>如何显示一颗空心星星</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在html文件</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;span *ngFor=&quot;let star of stars&quot; class=&quot;glyphicon glyphicon-star glyphicon-star-empty&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>如何显示5颗星星</p><p>在ts文件中添加一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export class StarsComponent implements OnInit&#123;</span><br><span class="line">private stars:boolean[];</span><br><span class="line">onOnInit()&#123;</span><br><span class="line">this.stars=[true,ture,true,true,true];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>如何有星星亮其余不亮</p><p><strong>属性绑定</strong></p><p>用[属性]，将属性和控制器属性做绑定</p><p>比如讲img的src内容写到控制器，命名为imgUrl，然后在html中用[src]=”imgUrl”调用</p><p>为了让星星亮，可以采用属性绑定的特例，<strong>样式绑定</strong></p><p>先把空心星星的样式提出来，绑定到ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">&lt;span *ngFor=&quot;let star of stars&quot; class=&quot;glyphicon glyphicon-star&quot; [class. glyphicon-star-empty=&quot;star&quot;&gt;&lt;/span&gt;</span><br><span class="line">//这是表示，这是一个css样式，值要绑定到名为star变量</span><br><span class="line">//即，span标签是否拥有这个样式，是由star决定的，如果star是true就拥有样式</span><br><span class="line">&lt;span&gt;&#123;&#123;rating&#125;&#125;星&lt;/span&gt;//用于下一步测试</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>如何将星级评价数值，传递给组件ts</p><p>此时需要用到组件的另一个概念，<strong>输入属性</strong></p><p>即可以将外部商品组件的评分传递到星级评价组件来，从而实现星星亮的数量的判别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class StartsComponent implements OnInit&#123;</span><br><span class="line">@Input() private rating:number=0;//用来接收产品组件传来的评分数值</span><br><span class="line">private stars:boolean[];</span><br><span class="line">constructor()&#123; &#125;</span><br><span class="line">onOnInit()&#123;</span><br><span class="line">this.stars=[true,ture,true,true,true];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在产品组件模板使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngFor=&quot;let product of products&quot; class=&quot;col-md-4 col-sm-4 col-lg-4&quot;&gt;</span><br><span class="line">&lt;div class=&quot;thumbnail&quot;&gt;</span><br><span class="line">&lt;img src=&quot;http://placehold.it/320x150&quot;&gt;</span><br><span class="line">&lt;div class=&quot;caption&quot;&gt;</span><br><span class="line">&lt;h4 class=&quot;pull-right&quot;&gt;&#123;&#123;product.price&#125;&#125;元&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;&lt;a&gt;&#123;&#123;product.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;product.desc&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">//在这里使用属性绑定,app-stars的rating属性，是由product的rating属性传过去</span><br><span class="line">&lt;app-stars [rating]=&quot;product.rating&quot;&gt;&lt;/app-stars&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><p>5.如何根据商品的星级来决定星星是不是亮的</p><p>那就把星星初始化的值不写死，而是由传过来的rating来判断是ture还是false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export class StarsComponent implements OnInit&#123;</span><br><span class="line">private stars:boolean[];</span><br><span class="line">onOnInit()&#123;</span><br><span class="line">this.stars=[];</span><br><span class="line">for(let i=1;i&lt;=5;i++)&#123;</span><br><span class="line">this.stars.push(i&gt;this.rating)</span><br><span class="line">&#125;//这个好，直接使用数组的方式和数值比较的方式做判断</span><br><span class="line">//this.stars=[true,ture,true,true,true];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="这个组件涉及三个知识点"><a href="#这个组件涉及三个知识点" class="headerlink" title="这个组件涉及三个知识点"></a>这个组件涉及三个知识点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*ngFor</span><br><span class="line">属性绑定[src]、样式绑定[class.样式名]=&quot;变量&quot;//该变量为Boolean值，由后台传</span><br><span class="line">输入属性@Input(),由父组件将数据传到子组件</span><br></pre></td></tr></table></figure><h2 id="Angular路由"><a href="#Angular路由" class="headerlink" title="Angular路由"></a>Angular路由</h2><p>关键词：单页应用、视图状态、URL</p><p>每个应用都拥有路由器，为每一个页面分配URL，由路由器来分配</p><p><img src="C:\Users\28715\AppData\Local\Temp\1552970696547.png" alt="1552970696547"></p><p>在指定区域显示不同的组件</p><h3 id="路由知识小案例"><a href="#路由知识小案例" class="headerlink" title="路由知识小案例"></a>路由知识小案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建一个项目</span><br><span class="line">&gt;ng new router --routing</span><br></pre></td></tr></table></figure><ol><li>Routes:路由配置，保存哪个URL展示哪个组件，以及在哪个RouterOutlet展示组件</li><li>RouterOutlet:在hrml中标记路由内容呈现位置的占位符指令</li><li>Router：负责在运行时执行路由的对象，可以调用其navigate()和navigaeByUrl()方法来指向一个指定的路由</li><li>RouterLink:在html声明路由用的指令，用在模板的a标签，点a标签指向路由</li><li>ActivatedRoute当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数。</li></ol><h5 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h5><ol><li>angular应用是由多个组件组成的</li><li>每个组件都有控制器和模板，应用启动后，先展示APPcomponent组件的模板，所有的这些组件都会封装在一个模块</li><li>路由的配置也就是<strong>Routers</strong>对象就是存在模块，Routers对象由一组配置信息组成，path:用来表示url，component，用来指所展示的组件</li><li>而需要展示的组件放置的位置，就要是在需要的位置放置<strong>RouterOutlet</strong>指令，若想显示其余组件可以在模板放置链接地址（<strong>使用RouteLink</strong>)</li><li>在控制器调用<strong>Router</strong>的navigate方法来改变浏览器的地址，实现路由的转换</li><li>在url也可以传递数据，这些数据会保存在<strong>ActivatedRoute</strong></li></ol><p><img src="C:\Users\28715\AppData\Local\Temp\1552971865812.png" alt="1552971865812"></p><h4 id="使用新建项目"><a href="#使用新建项目" class="headerlink" title="使用新建项目"></a>使用新建项目</h4><p>当使用–router来新建项目的时候多一个名为app-routing-module.ts,在这个文件对这个应用配置路由</p><p>在这个文件中拥有一个AppRoutingModule模块，这个模块已经放到了app.module.ts的imports属性，也就是说，在新文件的路由配置都会直接放在app.module.ts，那么这个app就知道该使用什么样的路由配置来路由了</p><h5 id="新建两个组件"><a href="#新建两个组件" class="headerlink" title="新建两个组件"></a>新建两个组件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ng g c home</span><br><span class="line">ng g c product</span><br></pre></td></tr></table></figure><p>当点主页的链接时显示home组件</p><p>当点击商品详情链接时显示商品信息组件</p><p>然后分别在两个组件的模板写点结点去测试，现在测试肯定是没有效果的，因为没有添加路由配置</p><h5 id="添加路由配置"><a href="#添加路由配置" class="headerlink" title="添加路由配置"></a>添加路由配置</h5><p>在app-routing-module.ts文件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123;NgModule&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;Routes,RouterModule&#125; from &apos;@angular/router&apos;;</span><br><span class="line">import &#123;HomeComponent&#125; from &quot;./home/home.component&quot;;</span><br><span class="line">import &#123;ProductComponent&#125; from &quot;./product/product.component&quot;;</span><br><span class="line"></span><br><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">imports:[RouterModule.forRoot(routes)],</span><br><span class="line">exports:[RouterModule],</span><br><span class="line">providers:[]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppRoutingModule&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样路由的配置就结束</p><h5 id="这个时候看app-component-html的模板"><a href="#这个时候看app-component-html的模板" class="headerlink" title="这个时候看app.component.html的模板"></a>这个时候看app.component.html的模板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会发现有一个&lt;router-outlet&gt;&lt;/router-outlet&gt;标签//这就是一个指示路由组件显示位置的占位符</span><br></pre></td></tr></table></figure><h5 id="指向路由"><a href="#指向路由" class="headerlink" title="指向路由"></a>指向路由</h5><h6 id="方法一：使用routerLink来指向"><a href="#方法一：使用routerLink来指向" class="headerlink" title="方法一：使用routerLink来指向"></a>方法一：使用routerLink来指向</h6><p>在模板写两个a标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt;//这里就需要用/</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;]&quot;&gt;商品详情&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>这个时候使用这个项目</p><p>当直接使用localhost：4200时，url是空，那就是显示首页</p><p>当点击商品详情时，url跳转到product，那就是商品详情信息组件显示。</p><p>所有的组件内容只显示到router-outlet标签后面</p><p>这就是路由的基本策略</p><h5 id="routerLink的参数为何是一个数组而不是一个字符串"><a href="#routerLink的参数为何是一个数组而不是一个字符串" class="headerlink" title="routerLink的参数为何是一个数组而不是一个字符串"></a>routerLink的参数为何是一个数组而不是一个字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样可以在路由的时候传递参数，如[&apos;/product&apos;,&apos;&apos;]</span><br></pre></td></tr></table></figure><h6 id="方法二-使用Router对象"><a href="#方法二-使用Router对象" class="headerlink" title="方法二:使用Router对象"></a>方法二:使用Router对象</h6><p>在模板添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;商品详情&quot; (click)=&quot;toProductDetails()&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>这使用了数据绑定的第三种方式事件绑定，前面分别是差值表达式方式和属性绑定方式</code></p><p>之后需要在app.component.ts的class对象写一个函数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(private router:Router)&#123;//记得将包引到头部，一般自动引了</span><br><span class="line">//这个方法将在之后介绍</span><br><span class="line">&#125;</span><br><span class="line">toProductDetails()&#123;</span><br><span class="line">//这个方法需要用到Router对象</span><br><span class="line">this.router.navigate([&apos;/product&apos;]);//这样效果和方法一 一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="当用户点一个不存在的路径"><a href="#当用户点一个不存在的路径" class="headerlink" title="当用户点一个不存在的路径"></a>当用户点一个不存在的路径</h5><p>此时显示异常，界面没有内容</p><p><strong>解决办法</strong></p><p>需要一个通配符</p><p>再建一个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c code404//这个组件是当url不存在的地址的时候调用的组件</span><br></pre></td></tr></table></figure><p>在组件的模板写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">页面不存在</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>然后在app-routing-module.ts添加一个路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,&#123;//这个路由不能放到前面</span><br><span class="line">        path:&apos;**&apos;;</span><br><span class="line">        component:Code404Component</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>此时，当拥有不存在的url时会显示这个组件</p><h4 id="在路由时传递数据"><a href="#在路由时传递数据" class="headerlink" title="在路由时传递数据"></a>在路由时传递数据</h4><ol><li><p>在查询参数时传递数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:/product?id=1&amp;name=2 =&gt; ActivatedRoute.queryParams[id]</span><br><span class="line">这里是参数这里是在目标组件获取参数的方式</span><br></pre></td></tr></table></figure><p>修改之前的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt;//这里就需要用/</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;]&quot; [queryParams]=&quot;&#123;id=1&#125;&quot;&gt;商品详情&lt;/a&gt;</span><br><span class="line">//这个queryParams属性指向一个对象，然后在这个对象写参数，这时再点击这个链接时url就会显示参数了</span><br></pre></td></tr></table></figure><p>在product组件使用这个参数</p><p>在product.component.ts文件的class的构造器写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private routeInfo:ActivatedRoute)&#123;&#125;//记得引包</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productId = this.routeInfo.snapshot.queryParams[&quot;id&quot;];</span><br><span class="line">&#125;</span><br><span class="line">//然后将productId属性以&#123;&#123;&#125;&#125;的形式放在模板测试</span><br></pre></td></tr></table></figure></li><li><p>在路由的路径传递数据，即在url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg:&#123;path:/product/:id&#125; =&gt;/product/1 =&gt;ActivatedRoute.params[id]</span><br></pre></td></tr></table></figure><ul><li><p>需要修改路由构造函数的path属性，使得其可以传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product/:id&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import了</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>在app.component.html修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt;//这里就需要用/</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;,1]&quot;&gt;商品详情&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>此时若要取数据需要从url取则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private routeInfo:ActivatedRoute)&#123;&#125;//记得引包</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productId = this.routeInfo.snapshot.Params[&quot;id&quot;];//即可</span><br><span class="line">&#125;</span><br><span class="line">//然后将productId属性以&#123;&#123;&#125;&#125;的形式放在模板测试</span><br></pre></td></tr></table></figure><p>参数快照，参数订阅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructor(private routeInfo:ActivatedRoute)&#123;&#125;//记得引包</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productId = this.routeInfo.snapshot.Params[&quot;id&quot;];//即可</span><br><span class="line">&#125;</span><br><span class="line">//然后将productId属性以&#123;&#123;&#125;&#125;的形式放在模板测试</span><br><span class="line">//这样效果和刚刚在链接那传一样，但是如果同一个参数在ngOnInit定义，那么只会赋值一次，只有从home组件开始再点击才能ngOnInit，其他的给取到的参数再次赋值，这称为参数快照</span><br><span class="line">而如果想要解决这个问题，就需要使用参数订阅的方法</span><br><span class="line">this.routeInfo.params.subscribe((params:Params)=&gt;this.productId=params[&quot;id&quot;]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在路由配置传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eg:&#123;</span><br><span class="line">path:/product,</span><br><span class="line">component:ProductComponent,</span><br><span class="line">data:[&#123;</span><br><span class="line">       isProd:true </span><br><span class="line">&#125;];</span><br><span class="line">&#125; =&gt; ActivatedRoute.data[0][isProd]</span><br></pre></td></tr></table></figure></li></ol><h4 id="重定向路由"><a href="#重定向路由" class="headerlink" title="重定向路由"></a>重定向路由</h4><p>是指在用户访问一个特定的地址时，将其重定向到另一个指定的地址</p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.aaa.com=&gt;www.aaa.com/products</span><br><span class="line">www.aaa.com/x=&gt;www.aaa.com/y</span><br></pre></td></tr></table></figure><p>使用，如：一般我们的第一个为空的指向首页，但是规范化的还是需要将空字符串写上home</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">//path:&apos;&apos;,</span><br><span class="line">path:&apos;home&apos;,//记得绑定路由的a标签也要改</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product/:id&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import了</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的话，那么直接访问localhost:4200不会跳转到首页，而是页面不存在，只有点链接使用路由，才能显示组件</p><p>为了解决这个问题，就要使用重定向路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[//添加一个新的路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">redirectTo:&apos;/home&apos;,</span><br><span class="line">pathMatch:&apos;full&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#123;</span><br><span class="line">//path:&apos;&apos;,</span><br><span class="line">path:&apos;home&apos;,//记得绑定路由的a标签也要改</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在访问localhost：4200就会跳到localhost：4200/home</p><h4 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h4><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;//这是一个普通路由</span><br><span class="line">path:&apos;home&apos;,</span><br><span class="line">component：HomeComponent,</span><br><span class="line">&#125;</span><br><span class="line">//子路由</span><br><span class="line">&#123;//这是一个普通路由</span><br><span class="line">path:&apos;home&apos;,</span><br><span class="line">component:HomeComponent,</span><br><span class="line">children:[//写子路由后，访问home组件路由会显示HomeComponent组件模板，在outlet位置会显示子路由1</span><br><span class="line">        &#123;</span><br><span class="line">            path:&apos;&apos;,</span><br><span class="line">            component:子路由组件1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">path:&apos;/yyy&apos;,//当访问home/yyy路径的时候显示子路由组件2</span><br><span class="line">component:子路由组件2</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现子路由"><a href="#实现子路由" class="headerlink" title="实现子路由"></a>实现子路由</h5><ol><li><p>新建两个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ng g c product-desc</span><br><span class="line">ng g c seller-info</span><br></pre></td></tr></table></figure></li><li><p>在这两个组件的html模板添加一些标签测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:在一个组件写//seller-info</span><br><span class="line">&lt;p&gt;</span><br><span class="line">销售员ID是:&#123;&#123;sellerId&#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>然后在seller-info组件的ts文件写代码，为了使得sellerId能够获得参数id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在类写</span><br><span class="line">private sellerId:number;</span><br><span class="line">constructor(private routeInfo:ActivateRoute)&#123; &#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.sellerId=this.routeInfo.snapshot.params[&quot;id&quot;]//稍后以url方式传参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改路由配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//添加子路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">children:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;&apos;,</span><br><span class="line">                component:ProductDescComponent</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;seller/:id&apos;,</span><br><span class="line">                component:SellerInfoComponent</span><br><span class="line">            &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改ProductComponent的模板，因为这个子路由是在ProductComponent组件的，所以占位符需要放在ProductComponent的html模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在这个模板这放一个占位符</span><br><span class="line">//加两个链接拥有调用路由，使用组件</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;./&apos;]&quot;&gt;商品描述&lt;/a&gt;//./是用来表示当前路由的子路由的默认路由</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;./seller&apos;,99]&quot;&gt;销售员信息&lt;/a&gt;</span><br><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br></pre></td></tr></table></figure><p>写到这路由就写好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.第一个&lt;router-outlet&gt;&lt;/router-outlet&gt;是写在appcomponent的</span><br><span class="line">2.在商品详情组件又显示一个&lt;router-outlet&gt;&lt;/router-outlet&gt;这属于占位符的父子关系，当然你也可以在子路由的模板再写&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br><span class="line">3.谁是谁的父组件啥啥啥的都是在app-routing-module.ts配置的，路由信息都是在模块层，组件本身不知道路由相关信息</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲1</title>
      <link href="/2019/03/18/angular%E7%B2%BE%E8%AE%B21/"/>
      <url>/2019/03/18/angular%E7%B2%BE%E8%AE%B21/</url>
      
        <content type="html"><![CDATA[<h1 id="angular精讲1"><a href="#angular精讲1" class="headerlink" title="angular精讲1"></a>angular精讲1</h1><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">组件：是angular应用的基本构建块，你可以把一个组件理解为一段带有业务逻辑和数据的html</span><br><span class="line">服务：组件可以调用服务，服务是用来封装可以重用的业务逻辑，服务也可以互相调用</span><br><span class="line">指令：允许你想html元素添加自定义行为。</span><br><span class="line">模块：用来将应用中不同的部分组织成一个angular框架可以理解的单元。即包括组件、服务、指令</span><br></pre></td></tr></table></figure><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先下载node.js</span><br><span class="line">命令行输入</span><br><span class="line">&gt;npm install -g @angular/cli</span><br><span class="line">&gt;ng -v</span><br></pre></td></tr></table></figure><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new my-project</span><br></pre></td></tr></table></figure><h4 id="目录结构-部分重要的"><a href="#目录结构-部分重要的" class="headerlink" title="目录结构//部分重要的"></a>目录结构//部分重要的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e2e:基本的测试目录</span><br><span class="line">src:写代码的位置</span><br><span class="line">angular-cli.json:angular命令行工具的配置文件，引入jquery等包时需要修改</span><br><span class="line">karma.conf.js：执行自动化测试</span><br><span class="line">package.json:项目所需要的依赖包</span><br><span class="line">node_modules:都是项目的依赖包，不用自己写</span><br></pre></td></tr></table></figure><h5 id="src目录"><a href="#src目录" class="headerlink" title="src目录"></a>src目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app:用来写我们的代码</span><br><span class="line">assets:用来存静态资源</span><br><span class="line">environment:配置开发环境或别的环境</span><br><span class="line">index.html：总的html</span><br><span class="line">main.ts:脚本执行的大门</span><br><span class="line">polyfills.ts:添加库</span><br><span class="line">style.css:放全局的样式</span><br></pre></td></tr></table></figure><h6 id="app-component-ts"><a href="#app-component-ts" class="headerlink" title="app.component.ts"></a>app.component.ts</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.component.ts:整个项目的基础</span><br><span class="line">@component()：装饰器告知angular框架如何整这个类</span><br><span class="line">Template：模板</span><br><span class="line">Controller：包含组件的属性和方法，业务逻辑写在控制器中</span><br><span class="line">控制器通过数据绑定与模板通讯，模板展现控制器数据，控制器处理模板的事件</span><br><span class="line">import &#123;Component&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">selector:&apos;app-root,//选择器，可以通过命名的标签来调用，显示组件的内容</span><br><span class="line">templateUrl:&apos;./app.component.html&apos;,//模板，组件的内容</span><br><span class="line">styleUrls:[&apos;./app.component.css]//组件模板中需要使用的样式</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent&#123;//typescript类</span><br><span class="line">title=&apos;app works&apos;;</span><br><span class="line">/*</span><br><span class="line">模板相关的属性和方法，以及业务逻辑都放在这里</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="app-module-ts"><a href="#app-module-ts" class="headerlink" title="app.module.ts"></a>app.module.ts</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">模块</span><br><span class="line">也是带着装饰器的typescript类@NgModule装饰器，以装饰器让angular把类当成模块</span><br><span class="line">import引模块需要的东西</span><br><span class="line">在装饰器的declarations:声明组件、指令和管道</span><br><span class="line">在装饰器的imports:声明需要的其他模块如BrowserModule浏览器模块</span><br><span class="line">在装饰器的providers:[]：用来声明模块提供的服务，服务声明在这</span><br><span class="line">在装饰器的bootstrap：声明模块的主要组件是什么</span><br></pre></td></tr></table></figure><h4 id="事件绑定方式"><a href="#事件绑定方式" class="headerlink" title="事件绑定方式"></a>事件绑定方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性绑定</span><br><span class="line">事件绑定</span><br><span class="line">双向绑定</span><br></pre></td></tr></table></figure><h4 id="组件中元素"><a href="#组件中元素" class="headerlink" title="组件中元素"></a>组件中元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">必备元素：@component//装饰器 Template//模板  Controller//控制器</span><br><span class="line">可选注入对象：</span><br><span class="line">@inputs()//输入属性  接收外部传的数据，父组件可以直接传递数据给子组件</span><br><span class="line">providers//提供器  用来做依赖注入</span><br><span class="line">Lifecycle Hook//生命周期钩子 用来触发执行业务逻辑，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可选的输出对象</span><br><span class="line">Lifecycle Hook//生命周期钩子 用来触发执行业务逻辑</span><br><span class="line">styles:样式表</span><br><span class="line">Animations:动画包</span><br><span class="line">@Outputs:在组件之间传递数据</span><br></pre></td></tr></table></figure><h4 id="angular的启动过程"><a href="#angular的启动过程" class="headerlink" title="angular的启动过程"></a>angular的启动过程</h4><ol><li><p>angular启动时加载了哪个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在angular-cli.json中有一个&quot;apps&quot;拥有一个index属性和main属性，index属性一般指向src/index.html,main执行src/main.ts这是angular项目的起点脚本</span><br></pre></td></tr></table></figure><ul><li><p>main.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import是加载一些必要的库</span><br><span class="line">if(environment.production)这是根据项目当前的环境，来确定项目的模式</span><br><span class="line">platformBrowserDynamic.bootstrapModule(AppModule)让appModule作为项目起点，然后加载模块需要什么模块，然后像是原型链一样去找模块，加载完所有模块后，在index.html找启动项目时所需要的主要组件appModule指定的主要组件的selector,然后用template的内容去替换掉调用的标签。</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>   2.app文件夹任何改变都会让angular自动刷新</p><h4 id="在angular项目使用第三方类库"><a href="#在angular项目使用第三方类库" class="headerlink" title="在angular项目使用第三方类库"></a>在angular项目使用第三方类库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用命令行安装</span><br><span class="line">&gt;npm install jquery --save是为了引到package.json</span><br><span class="line">&gt;npm install bootstrap@3 --save</span><br><span class="line">//安装过程是首先将包放到node_module库然后将包引到package.json</span><br><span class="line">之后需要修改angular-cli</span><br><span class="line">把jquery和bootstrap的js和js/css分别添加到scripts属性和styles属性</span><br><span class="line"></span><br><span class="line">把类型描述文件添加到项目</span><br><span class="line">命令行</span><br><span class="line">npm install @types/jquery --save-dev</span><br><span class="line">npm install @types/bootstrap --save-dev</span><br></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>在app.component.ts的class添加一个test方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test()&#123;</span><br><span class="line">$(&quot;ada&quot;).show();</span><br><span class="line">&#125;//这样就可以使用jquery了</span><br></pre></td></tr></table></figure><h3 id="用组件化的思路来写项目"><a href="#用组件化的思路来写项目" class="headerlink" title="用组件化的思路来写项目"></a>用组件化的思路来写项目</h3><p>一个项目需要多个组件，情景，一个页面，需要页头，需要搜索组件，展示组件，商品列表组件，评价组件，页脚组件，做出一个项目来</p><p><img src="C:\Users\28715\AppData\Local\Temp\1552908485415.png" alt="1552908485415"></p><h5 id="组件新建方法-建立项目所需组件"><a href="#组件新建方法-建立项目所需组件" class="headerlink" title="组件新建方法//建立项目所需组件"></a>组件新建方法//建立项目所需组件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ng g component navbar</span><br><span class="line">ng g component footer</span><br><span class="line">ng g component search</span><br><span class="line">ng g component carousel</span><br><span class="line">ng g component product</span><br><span class="line">ng g component stars</span><br></pre></td></tr></table></figure><p>新建组件后，会自动更新app.module.ts,这些组件全都在app模块</p><h4 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h4><ol><li><p>从最基础的app组件来写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-navbar&gt;&lt;/app-navbar&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-md-3&quot;&gt;//左右布局，左边占1/4</span><br><span class="line">&lt;app-search&gt;&lt;/app-search&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;col-md-9&quot;&gt;//这片区域占3/4</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;//这片区域分成两个行</span><br><span class="line">&lt;app-carousel&gt;&lt;/app-carousel&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;app-product&gt;&lt;/app-product&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;app-footer&gt;&lt;/app-footer&gt;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1552909148495.png" alt="1552909148495"></p></li></ol><p>当前的效果肯定是不好看的，所以继续写</p><h4 id="先写头部吧-响应式"><a href="#先写头部吧-响应式" class="headerlink" title="先写头部吧//响应式"></a>先写头部吧//响应式</h4><p>在头部的组件的html文件写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav class=&quot;navbar navbar-inverse navbar-fiexed&quot;&gt;</span><br><span class="line">//这句话的意思是，我需要一个导航条，黑底白字，固定在头部</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;nav-header&quot;&gt;</span><br><span class="line">//添加一个按钮用来显示相应后隐藏的三个元素</span><br><span class="line">&lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-ex1-collapse&quot;&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;//在button加三个横线</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;在线竞拍&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;collapse navbar-collapse navbar-ex1-collapse&quot;&gt;//这个div是为了响应式布局用的</span><br><span class="line">&lt;ul class=&quot;nav navbar-nav&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站地址&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/nav&gt;</span><br><span class="line">//说明，要让按钮的点开下拉能起作用的话，就要给需要下拉的div元素设置同样的样式,其中navbar-ex1-collapse是随便取的名字，只是为了能够关联，下拉框</span><br><span class="line">//这样设置完之后就可以实现响应式的效果，点击按钮之后三个元素显示</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1552909994729.png" alt="1552909994729"></p><p>这时可以发现，部分内容被挡住了，这个时候可以在全局样式中做修改</p><p>在style.css加一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">padding-top:70px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写一下页脚"><a href="#写一下页脚" class="headerlink" title="写一下页脚"></a>写一下页脚</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;footer&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-lg-12&quot;&gt;//占据整屏幕宽</span><br><span class="line">&lt;p&gt;测试页面底部&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1552910331671.png" alt="1552910331671"></p><p>前面两个组件不涉及业务逻辑</p><h4 id="写搜索表单组件"><a href="#写搜索表单组件" class="headerlink" title="写搜索表单组件"></a>写搜索表单组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=&quot;search&quot; role=&quot;form&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;label for=&quot;productTitle&quot;&gt;商品名称:&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;productTitle&quot; placeholder=&quot;商品名称&quot; class=&quot;form-control&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">&lt;label for=&quot;productPrice&quot;&gt;商品价格:&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;number&quot; id=&quot;productPrice&quot; placeholder=&quot;商品价格&quot; class=&quot;form-control&quot;&gt;</span><br><span class="line">&lt;/div class=&quot;form-group&quot;&gt;</span><br><span class="line">&lt;label for=&quot;productCategory&quot;&gt;商品类别:&lt;/label&gt;</span><br><span class="line">&lt;select id=&quot;productCategory&quot; class=&quot;form-control&quot;&gt;&lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;form-control&quot;&gt;</span><br><span class="line">&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block&quot;&gt;搜索&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础_02</title>
      <link href="/2019/03/15/javascript%E5%9F%BA%E7%A1%80-02/"/>
      <url>/2019/03/15/javascript%E5%9F%BA%E7%A1%80-02/</url>
      
        <content type="html"><![CDATA[<p>重温JavaScript02</p><a id="more"></a><h3 id="javascript基础01-02"><a href="#javascript基础01-02" class="headerlink" title="javascript基础01_02"></a>javascript基础01_02</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h5><ol><li><p>JavaScript，number数值类型最值的表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1+0.2!=0.3//不要用小数去验证小数</span><br></pre></td></tr></table></figure></li><li><p>验证结果是不是NaN，使用方法isNaN();//不是一个数字吗？若要验证num,num=10;则返回结果为false；</p></li></ol><h5 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h5><ol><li><p>字符串可以使用单引号也可以使用双引号。</p></li><li><p>求字符串的个数 ，即求字符串的长度为多少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure></li><li><p>相关转义符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">html的转义符</span><br><span class="line">&lt;   &amp;lt</span><br><span class="line">&gt;   &amp;gt</span><br><span class="line">空格   &amp;nbsp</span><br><span class="line">js的转义符</span><br><span class="line">table键   \t</span><br><span class="line">退格键   \b</span><br><span class="line">\   \\</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>字符串的拼接</p><ul><li>用+号即可</li><li>只要有一个是字符串，其它是数字，那么也是拼接</li><li>如果有一个是字符串，另一个不是，使用-、*、/号，那么此时会发生计算”10”-5=5</li></ul></li></ol><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><h5 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h5><ol><li><p>变量声明未赋值是undefined</p></li><li><p>变量如果是null，只能自己赋值，要喝NaN区分开</p></li></ol><h5 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h5><ol><li><p>其它类型转数字类型</p><ul><li>parseInt()//转整数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10a"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"g10"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1fds0"</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10.98"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10.98dasda"</span>));<span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>parseFloat()//转小数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10a"</span>));<span class="comment">//10//别的语言无法转化</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"g10"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"1fds0"</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.98"</span>));<span class="comment">//10.98</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.98dasda"</span>));<span class="comment">//10.98</span></span><br></pre></td></tr></table></figure><ul><li>Number()//转数字——更加严格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10a"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"g10"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"1fds0"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10.98"</span>));<span class="comment">//10.98</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10.98dasda"</span>));<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li><li><p>其它类型转字符串类型</p><ul><li>toString</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());</span><br></pre></td></tr></table></figure><ul><li>String()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(num));</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>其它类型转布尔类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"1"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"0"</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"11"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"-10"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"嘎嘎"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">""</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"null"</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"undefined"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="通过构造函数创建数组"><a href="#通过构造函数创建数组" class="headerlink" title="通过构造函数创建数组"></a>通过构造函数创建数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var 数组名=new Array();</span><br><span class="line"></span><br><span class="line">var array=new Array();</span><br><span class="line">//数组的名字如果直接输出，那么直接就可以把数组中的数据显示出来，如果没有数据，就看不到数据。</span><br><span class="line">var array=new Array(5);//规定数组大小,此时数组的每个值就是undefined</span><br></pre></td></tr></table></figure><h3 id="通过字面量的方式创建数组"><a href="#通过字面量的方式创建数组" class="headerlink" title="通过字面量的方式创建数组"></a>通过字面量的方式创建数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var 数组名=[];</span><br><span class="line">var arr=[];</span><br></pre></td></tr></table></figure><ul><li><p>不管是构造函数的方式还是字面量的方式，如果定义了大小，那么数据默认为undefined</p></li><li><p>构造函数的方式创建数组的时候，如果在Array()写一个数字，则表示数组的长度，若在括号写多个值，那么数组就有数据了，数组的长度就是这些值的个数。</p></li><li><p>设置数组某个位置的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 [下标]=值；</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>数组的长度-1就是最大的索引值</p></li><li><p>字面量创建的方式更简单</p></li><li><p>arr.length数组大小</p></li></ul><h3 id="数组的注意问题"><a href="#数组的注意问题" class="headerlink" title="数组的注意问题"></a>数组的注意问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,2,3,4,1];</span><br><span class="line">alert(arr);//输出的逗号是浏览器自己加的</span><br></pre></td></tr></table></figure><h3 id="数组存储的类型一定是一样的吗"><a href="#数组存储的类型一定是一样的吗" class="headerlink" title="数组存储的类型一定是一样的吗"></a>数组存储的类型一定是一样的吗</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,&apos;嘎嘎&apos;，true,&apos;undefined&apos;,new object];//可以输出结果</span><br><span class="line">//但是一般使用都使用同样的数据类型</span><br></pre></td></tr></table></figure><h3 id="数据的长度是否可以改变"><a href="#数据的长度是否可以改变" class="headerlink" title="数据的长度是否可以改变"></a>数据的长度是否可以改变</h3><p>可以</p>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular路由</title>
      <link href="/2019/03/13/angular%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/03/13/angular%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="angular路由"><a href="#angular路由" class="headerlink" title="angular路由"></a>angular路由</h2><a id="more"></a><ol><li>我有三个组件需要作为页面显示，设置路由</li><li>使用路由，需要在app.module.ts文件的import下面添加然后将Routes引入到头部</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const appRoutes:Routes=[</span><br><span class="line">    &#123;path:&apos;&apos;,component:HomeComponent&#125;//建立第一个路由</span><br><span class="line">    &#123;path:&apos;users&apos;,component:UsersComponent&#125;//建立第一个路由</span><br><span class="line">    &#123;path:&apos;servers&apos;,component:ServersComponent&#125;//建立第一个路由</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol><li><p>在app.module.ts文件的@NgModule模块的imports数组添加RouterModule，然后将RouterModule添加到头部Routes的引入模块，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RouterModule。forRoot(appRoutes);//注册路由</span><br><span class="line">import &#123;Routes,RouterModule&#125; from &apos;@angular/router&apos;;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>至此，算是添加了路由功能了，基本模块结束了。angular知道了这个路由</p></li><li><p>在app.component.html模板中，你需要知道要把路由带来的页面添加到哪里，类似于模板引擎的原理。保留一个模板。在加载页面的html位置，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;//这是一个指令</span><br></pre></td></tr></table></figure></li><li><p>若使用某个a标签使得页面刷新到另外的页面，则删掉a标签的href属性添加routerLink属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li role=&quot;presentation&quot;&gt;&lt;a routerLink=&quot;/servers&quot;&gt;Servers&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li role=&quot;presentation&quot;&gt;&lt;a [routerLink]=&quot;[&apos;/users&apos;]&quot;&gt;Users&lt;/a&gt;&lt;/li&gt;//添加多个页面或参数时使用</span><br></pre></td></tr></table></figure></li><li><p>注意上面的class=”active”是引用的css样式当点击时是选中的样式，在路由修改成如下,添加指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li role=&quot;presentation&quot; routerLinkActive=&quot;active&quot;&gt;&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>也可以将这个指令添加到a标签,bootstrap还是放到li标签好点</p><p>将这个属性添加到6的每个li标签就可以实现点击样式，但是起初的默认选中样式却没有删掉。此时可以如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li role=&quot;presentation&quot; routerLinkActive=&quot;active&quot; [routeLinkActionOptions]=&quot;&#123;exact:true&#125;&quot;&gt;&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>在某个组件，若想要当点击某个按钮时使用router则如下</p><ul><li><p>在组件的ts文件的constructor括号里写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private router:Router//头部文件引用</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>当点击按钮后执行函数事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.router.navigate([&apos;/servers&apos;]);</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:&apos;users/:id&apos;,component:UsersComponent&#125;//传值选择某个数据</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础01_01</title>
      <link href="/2019/03/12/javascript%E5%9F%BA%E7%A1%8001-01/"/>
      <url>/2019/03/12/javascript%E5%9F%BA%E7%A1%8001-01/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript基础01"><a href="#javascript基础01" class="headerlink" title="javascript基础01"></a>javascript基础01</h1><a id="more"></a><h3 id="js分为三个部分"><a href="#js分为三个部分" class="headerlink" title="js分为三个部分"></a>js分为三个部分</h3><ul><li>ECMAScript</li><li>DOM</li><li>BOM</li></ul><h3 id="JavaScript是什么"><a href="#JavaScript是什么" class="headerlink" title="JavaScript是什么"></a>JavaScript是什么</h3><ul><li><p>是一门脚本语言</p></li><li><p>是一门解释性语言</p></li><li><p>是一门动态类型的语言</p></li><li><p>是一门基于对象的语言</p></li></ul><h3 id="编译语言与脚本语言的区别"><a href="#编译语言与脚本语言的区别" class="headerlink" title="编译语言与脚本语言的区别"></a>编译语言与脚本语言的区别</h3><p>编译语言：需要把代码翻译成计算机语言才能执行</p><p>脚本语言：不需要编译就可以直接执行</p><p>常用的脚本语言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-sql、cmd</span><br></pre></td></tr></table></figure><h3 id="js的作用"><a href="#js的作用" class="headerlink" title="js的作用"></a>js的作用</h3><p>js解决用户和浏览器之间的问题</p><h3 id="js写法"><a href="#js写法" class="headerlink" title="js写法"></a>js写法</h3><ul><li>js可以写在外部文件中，但是要引到html文件</li><li>js的代码可以写在html标签中写</li><li>在一对script标签有错误的js代码，那么错误代码后面的js代码不会执行</li><li>但是第一个script标签中的代码错了，后面script标签中的正确js代码都看看呀执行</li><li>script标签中可以写type=”text/javascript”和language=”javascript”,也可以两个标签都写，解决浏览器解析时可能出错的问题</li><li>script标签在页面可以出现多次</li><li>script标签一般是放在body标签的最后，也可以放在头部（需要别的方式）</li><li>js每一行后面都要加分号，不容易出错。</li><li>js区分大小写</li><li>js字符串可以使用单引号也可以使用双引号</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>操作的数据都是在内存中操作</p></li><li><p>js中存储数据使用变量的方式（名字，值—&gt;数据）</p></li><li><p>js中声明变量都用var，数据需要拥有数据类型</p></li><li><p>没有赋值的变量为undefined(没有返回值的函数也为undefined)</p></li><li><p>undefined+一个数字为NaN</p></li></ul><h3 id="变量的交换"><a href="#变量的交换" class="headerlink" title="变量的交换"></a>变量的交换</h3><h4 id="方法一-第三方变量"><a href="#方法一-第三方变量" class="headerlink" title="方法一:第三方变量"></a>方法一:第三方变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1=10;</span><br><span class="line">var num2=20;</span><br><span class="line">var temp = num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br></pre></td></tr></table></figure><h4 id="方法二-用于数字的交换"><a href="#方法二-用于数字的交换" class="headerlink" title="方法二:用于数字的交换"></a>方法二:用于数字的交换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1=10;</span><br><span class="line">var num2=20;</span><br><span class="line">num1=num1+num2;//30</span><br><span class="line">num2=num1-num2;//10</span><br><span class="line">num1=num1-num2;//20</span><br></pre></td></tr></table></figure><h3 id="方法三：异或的方式"><a href="#方法三：异或的方式" class="headerlink" title="方法三：异或的方式"></a>方法三：异或的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1=10;</span><br><span class="line">var num2=20;</span><br><span class="line">num1 = num1^num2;</span><br><span class="line">num2 = num1^num2;</span><br><span class="line">num1 = num1^num2;</span><br></pre></td></tr></table></figure><h3 id="代码格式规范化"><a href="#代码格式规范化" class="headerlink" title="代码格式规范化"></a>代码格式规范化</h3><p>webStorm:Ctrl+Alt+L</p><h3 id="获取变量的数据类型"><a href="#获取变量的数据类型" class="headerlink" title="获取变量的数据类型"></a>获取变量的数据类型</h3><h4 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number</span><br><span class="line">string</span><br><span class="line">boolean</span><br><span class="line">null//对象为空，赋值为null//为对象类型</span><br><span class="line">undefined</span><br><span class="line">object</span><br></pre></td></tr></table></figure><h4 id="typeof获取js变量数据类型"><a href="#typeof获取js变量数据类型" class="headerlink" title="typeof获取js变量数据类型"></a>typeof获取js变量数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeof 变量名</span></span><br><span class="line"><span class="comment">//typeof(变量名)</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="built_in">String</span>(<span class="literal">null</span>))结果为<span class="literal">null</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular服务的依赖注入</title>
      <link href="/2019/03/11/angular%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/03/11/angular%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="服务和依赖注入"><a href="#服务和依赖注入" class="headerlink" title="服务和依赖注入"></a>服务和依赖注入</h1><a id="more"></a><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ol><li><p>建立一个服务能够让多个组件同时使用，相当于封装外部函数，别的html文件可以引用这个函数，提高代码复用性。‘</p></li><li><p>服务是用来替代@Output和@Input的</p></li><li><p>情景：在一个APP中包含两个组件，要让这两个组件都能使用这个服务</p></li><li><p>首先在APP建立一个组件命名为logging.service.ts</p></li><li><p>文件中代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class LoggingService&#123;</span><br><span class="line">logStatusChange(status:string)&#123;</span><br><span class="line">console.log(&apos;A server status changed,new status:&apos;+status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在组件使用</p><ul><li>方法一(不推荐)</li></ul><p>在相应组件ts文件中写以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;LoggingService&#125; from &apos;../logging.service&apos;;</span><br></pre></td></tr></table></figure><p>在需要执行服务的地方输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const service = new LoggingService();</span><br><span class="line">service.logStatusChange(accountStatus);</span><br></pre></td></tr></table></figure><ul><li><p>方法二（angular提供）——依赖注入</p><ul><li><p>在需要使用服务的组件ts文件的class模块写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor（private loggingService:LoggingService)&#123;//服务的名称</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在头部引入LoggingService</p></li><li><p>在@component添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider：[LoggingService]</span><br></pre></td></tr></table></figure></li><li><p>在需要执行服务的地方执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.loggingService.logStatusChange(accountStatus)//传入的参数，本次执行是在一个事件之后执行的，所以添加this</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>管理和存储数据的服务</p><p>新建服务命名为：accounts.service.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export class AccountsService&#123;</span><br><span class="line">accounts=[</span><br><span class="line">&#123;</span><br><span class="line">name:&apos;master&apos;,</span><br><span class="line">status:&apos;active&apos;</span><br><span class="line">&#125;</span><br><span class="line">accounts=[</span><br><span class="line">&#123;</span><br><span class="line">name:&apos;master&apos;,</span><br><span class="line">status:&apos;active&apos;</span><br><span class="line">&#125;</span><br><span class="line">accounts=[</span><br><span class="line">&#123;</span><br><span class="line">name:&apos;master&apos;,</span><br><span class="line">status:&apos;active&apos;</span><br><span class="line">&#125;</span><br><span class="line">addAccount(name:string,status:string)&#123;//不同函数传参不同</span><br><span class="line">this.accounts.push(&#123;name:name,status:status&#125;);</span><br><span class="line">&#125;</span><br><span class="line">updataStatus(id:number,status:string)&#123;</span><br><span class="line">this.accounts[id].status = status;</span><br><span class="line">&#125;</span><br><span class="line">&#125;//这样的结构</span><br></pre></td></tr></table></figure><p>在app的ts文件写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accounts:&#123;name:string,status:string&#125;[]=[];</span><br><span class="line">//剩下的代码和上面的代码一样</span><br></pre></td></tr></table></figure><p>可以在export后添加implements OnInit</p><p>然后在模块中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngOnInit()&#123;</span><br><span class="line">this.accounts = this.accountsService.accounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><ol><li><p>放在app.moudule.ts的，全局都可以使用的服务</p></li><li><p>放在别的地方的，只能其子组件才能使用这个服务</p></li><li><p>放在最底层的，只有自己才能访问</p><ul><li>对于子组件来说，如果父级服务添加到了子组件，那么子组件就不能再添加服务了，不然就会覆盖掉，这个时候只需要将provider的服务名称保留一个即可。</li></ul></li><li><p>也可将子组件中provider的服务删掉，将服务添加到app.module.ts的@NgModule{}模块，添加provider:[],将服务添加。</p><p>如果要把服务引到同级的服务(注意是服务)，那要在服务中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular/core&apos;</span><br></pre></td></tr></table></figure><p>其他代码相同</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular 指令</title>
      <link href="/2019/03/10/angular-%E6%8C%87%E4%BB%A4%E7%AE%80%E8%BF%B0/"/>
      <url>/2019/03/10/angular-%E6%8C%87%E4%BB%A4%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="angular指令"><a href="#angular指令" class="headerlink" title="angular指令"></a>angular指令</h2><a id="more"></a><h3 id="一、在APP中建立指令文件夹"><a href="#一、在APP中建立指令文件夹" class="headerlink" title="一、在APP中建立指令文件夹"></a>一、在APP中建立指令文件夹</h3><ul><li><p>类似于建立组件文件</p></li><li><p>首先建立文件夹例如basic-heightlight</p></li><li><p>在文件夹中建立basic-height.directive.ts文件</p></li><li><p>文件中需要做的是(本指令主要是为了改变元素的北京燕山)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,ElementRef&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBasicHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BasicHightDirective implements OnInit&#123;</span><br><span class="line">constructor（private elementRef:ElementRef）&#123;//前面的elementRef名字自己选，但是后面的类型要确定</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.elementRef.nativeElement.style.backgroundColor=&quot;green&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="此处是组件的建立代码做对比"><a href="#此处是组件的建立代码做对比" class="headerlink" title="此处是组件的建立代码做对比"></a>此处是组件的建立代码做对比</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component&#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;app-shopping-edit&apos;,</span><br><span class="line">  templateUrl: &apos;./shopping-edit.component.html&apos;,</span><br><span class="line">  styleUrls: [&apos;./shopping-edit.component.css&apos;]</span><br><span class="line">&#125;)</span><br><span class="line">export class ShoppingEditComponent implements OnInit &#123;</span><br><span class="line">constructor() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二、将指令添加到app-module-ts，像组件一样"><a href="#二、将指令添加到app-module-ts，像组件一样" class="headerlink" title="二、将指令添加到app.module.ts，像组件一样"></a>二、将指令添加到app.module.ts，像组件一样</h3><p>在declarations里添加指令BasicHighLightDirective</p><p>同时在头部添加import {BasicHighLightDirective} from ‘路径’</p><h3 id="三、在html中使用这个指令"><a href="#三、在html中使用这个指令" class="headerlink" title="三、在html中使用这个指令"></a>三、在html中使用这个指令</h3><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p appBasicHighyLight&gt;test&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>就像是给p添加一个属性一样，这样就可以改变p元素的背景颜色了。</p><h3 id="四、another-way-推荐"><a href="#四、another-way-推荐" class="headerlink" title="四、another way(推荐)"></a>四、another way(推荐)</h3><p>使用命令行新建指令 ng g d better-hightlight</p><p>将会在app中新建两个ts文件，删掉其中一个spec.ts文件没什么用</p><p>可以将ts文件放到一个文件夹当中，之后要把app.module.ts文件中头部指令引入的路径修改了。</p><p>ts文件中同样需要这些代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.renderer.setStyle(this.elRef.nativeElement,&apos;backgroundColor&apos;,&apos;blue&apos;,false,false)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后再app的html文件中相应元素添加属性即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p appBetterHighyLight&gt;test&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="五、响应式样式变化"><a href="#五、响应式样式变化" class="headerlink" title="五、响应式样式变化"></a>五、响应式样式变化</h3><h4 id="使用-HostListener"><a href="#使用-HostListener" class="headerlink" title="使用@HostListener"></a>使用@HostListener</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef,HostListener&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line"></span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@HostListener(mouseenter) mouseover(eventData:Event)&#123;</span><br><span class="line">this.renderer.setStyle(this.elRef.nativeElement,&apos;backgroundColor&apos;,&apos;blue&apos;,false,false)</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(mouseleave) mouseleave(eventData:Event)&#123;</span><br><span class="line">this.renderer.setStyle(this.elRef.nativeElement,&apos;backgroundColor&apos;,&apos;transparent&apos;,false,false)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hostBinding使用"><a href="#hostBinding使用" class="headerlink" title="@hostBinding使用"></a>@hostBinding使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef,HostListener,hostBinding&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line">@hostBinding(&apos;style.backgroundColor&apos;) backgroundColor:string=&apos;transparent&apos;;</span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseenter&apos;) mouseover(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=&apos;blue&apos;</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseleave&apos;) mouseleave(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=&apos;transparent&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自己决定鼠标hover的颜色"><a href="#自己决定鼠标hover的颜色" class="headerlink" title="自己决定鼠标hover的颜色"></a>自己决定鼠标hover的颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef,HostListener,hostBinding,Input&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line">@Input() defaultColor:string=&apos;transparent&apos;;</span><br><span class="line">@Input() highlightColor:string=&apos;blue&apos;</span><br><span class="line">@hostBinding(&apos;style.backgroundColor&apos;) backgroundColor:string;</span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.backgroundColor=&quot;defaultColor&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseenter&apos;) mouseover(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=this.highlightColor;</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseleave&apos;) mouseleave(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=this.defaultColor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在p标签中添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p appBetterHighyLight [defaultColor]=&quot;&apos;yellow&apos;&quot; [highlightColor]=&quot;&apos;red&apos;&quot;&gt;test&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果将上述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Input() highlightColor:string=&apos;blue&apos;修改为</span><br><span class="line">@Input(&apos;appBetterHightLight&apos;) highlightColor:string=&apos;blue&apos;;那么html文件中就应该这样修改</span><br><span class="line">&lt;p [appBetterHighyLight]=&quot;&apos;red&apos;&quot; [defaultColor]=&quot;&apos;yellow&apos;&quot;&gt;test&lt;/p&gt;这里的&quot;&apos;red&apos;&quot;也可以改为&quot;red&quot;</span><br></pre></td></tr></table></figure><h3 id="六、structural-directives"><a href="#六、structural-directives" class="headerlink" title="六、structural directives"></a>六、structural directives</h3><p>命令行创建一个structural directives，使用ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,Input,TemplateRef&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appUnless]&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class UnlessDirective&#123;</span><br><span class="line">@Input() set appUnless(condition:boolean)&#123;</span><br><span class="line">if(!condition)&#123;</span><br><span class="line">this.vcRef.creatEmbeddedView(this.templateRef);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">this.vcRef.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor（private templateRef:TemplateRef&lt;any&gt;,private vcRef:ViewContainerRef）&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得将这个组件添加到moudule.ts文件</p><p>在html中使用这个指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *appUnless=&quot;onlyOdd&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="ngSwitch"><a href="#ngSwitch" class="headerlink" title="ngSwitch"></a>ngSwitch</h4><p>如果在app.ts复制value=10</p><p>在html中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div [ngSwitch]=&quot;value&quot;&gt;</span><br><span class="line">&lt;p *ngSwitchCase=&quot;5&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p *ngSwitchCase=&quot;10&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p *ngSwitchCase=&quot;100&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p *ngSwitchDefault&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular Component$databinding</title>
      <link href="/2019/03/09/Angular-Component-databinding/"/>
      <url>/2019/03/09/Angular-Component-databinding/</url>
      
        <content type="html"><![CDATA[<h1 id="Components-amp-Databinding详解"><a href="#Components-amp-Databinding详解" class="headerlink" title="Components&amp;Databinding详解"></a>Components&amp;Databinding详解</h1><a id="more"></a><h3 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h3><p>​    可以将一个大的组件划分成多个小的组件，直接将大组件中的代码剪切到小组件中</p><p>​    然后将大组件的ts文件中为这段代码所定义的模块剪切到小组件的ts文件中。</p><h3 id="父组件引用子组件中的内容（属性）"><a href="#父组件引用子组件中的内容（属性）" class="headerlink" title="父组件引用子组件中的内容（属性）"></a>父组件引用子组件中的内容（属性）</h3><p>需要在子组件的OnInit的定义使用@Input()，例如</p><blockquote><p>@Input() element:{name:string};</p><p>可以坐在Input（）加入’name’，定义外部组件访问此组件时的名称</p><p>然后将Input添加到子组件头部的import当中</p></blockquote><h3 id="如何通知父组件子组件有更新（比如新创建了按钮）（事件）"><a href="#如何通知父组件子组件有更新（比如新创建了按钮）（事件）" class="headerlink" title="如何通知父组件子组件有更新（比如新创建了按钮）（事件）"></a>如何通知父组件子组件有更新（比如新创建了按钮）（事件）</h3><ol><li><p>将子组件调用的方法放置到父组件当中如onServerAdded(serverData:{name:string}){<br>}</p></li><li><p>在父组件的html文件中引入子组件，例如在app中放入<app-cockpiy (servercreated)="onServerAdded($event)"></app-cockpiy></p></li><li><p>将</p><blockquote><p>@Output（） serverCreated = new EventEmitter\&lt;{name:string}>()定义到子组件的OnInit中</p><p>同时将output放置到头部的import中，括号内也可以分配别名</p></blockquote></li><li><p>将onServerAdded方法在子组件中定义，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onAddServer()&#123;</span><br><span class="line">this.serverCreated.emit(&#123;name:this.newServerName&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>angular默认将css封装在其自身组件之中，但是外部组件却不能用。这是angular提供的，不是浏览器提供的。</p><p>在某一组件的name.component.ts文件中的@Component模块中，可以添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encapsulation:ViewEncapsulation.Native或者None或者Emulated(默认的)</span><br></pre></td></tr></table></figure><p>None:样式为全局</p><p>Native：类似于Emulated</p><h3 id="在模板中使用本地参数-代替ngmodel"><a href="#在模板中使用本地参数-代替ngmodel" class="headerlink" title="在模板中使用本地参数(代替ngmodel)"></a>在模板中使用本地参数(代替ngmodel)</h3><p>eg:在input中添加#serverNameInput,然后在所调用的函数之中传入serverNameInput参数，console.log可以打印输入的内容再做调整</p><h3 id="ViewChild-代替ngmodel"><a href="#ViewChild-代替ngmodel" class="headerlink" title="ViewChild(代替ngmodel)"></a>ViewChild(代替ngmodel)</h3><p>eg:在input中添加#serverContentInput,在ts文件中添加@ViewChild(‘serverContentInput’) serverContentInput:ElementtRef;然后在头部文件添加ViewChild</p><p>console.log(this.serverContentInput.nativeElement.value)</p><p>可以直接给this.serverContentInput.nativeElement.value赋值，（是一个点击事件）那么点击按钮之后值就会直接显示在输入框。&lt;不推荐&gt;</p><h3 id="constructor和ngOnInit"><a href="#constructor和ngOnInit" class="headerlink" title="constructor和ngOnInit"></a>constructor和ngOnInit</h3><p>eg:每次创建都会执行这两个代码</p><p>在constructor代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;constructor&apos;);</span><br></pre></td></tr></table></figure><p>在ngOnInit代码块输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;ngOninit&apos;);</span><br></pre></td></tr></table></figure><p>在OnInit中创建代码，同时将onChanges添加到OnInit后面,将SimpleChanges添加到头部文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngOnChanges(changes:SimpleChanges)&#123;</span><br><span class="line">console.log(&apos;ngOnChanges&apos;);</span><br><span class="line">console.log(changes);//打印一个改变的状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在OnInit中创建代码，同时将doCheck添加到OnInit后面,将doCheck添加到头部文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngDoCheck()&#123;</span><br><span class="line">console.log(&quot;Check&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>survey.js</title>
      <link href="/2019/03/08/survey.js/"/>
      <url>/2019/03/08/survey.js/</url>
      
        <content type="html"><![CDATA[<p>学习一下survey.js</p><a id="more"></a><h3 id="一、首先需要在电脑中安装了node-js以及npm"><a href="#一、首先需要在电脑中安装了node-js以及npm" class="headerlink" title="一、首先需要在电脑中安装了node.js以及npm"></a>一、首先需要在电脑中安装了node.js以及npm</h3><p>可以用过在cmd命令行下输入node -v以及npm -v检查自己是否安装</p><h3 id="二、新建一个文件夹"><a href="#二、新建一个文件夹" class="headerlink" title="二、新建一个文件夹"></a>二、新建一个文件夹</h3><p>在命令行下cd到这个文件夹，然后输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/surveyjs/quickstart  my-proj</span><br><span class="line">cd my-proj</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>server.js建立成功</p><h3 id="三、做自己的demo问卷"><a href="#三、做自己的demo问卷" class="headerlink" title="三、做自己的demo问卷"></a>三、做自己的demo问卷</h3><p>找到my-proj文件夹，到达如下路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/app/app.component.ts</span><br></pre></td></tr></table></figure><p>查看前几行的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// If you want to show survey, uncomment the line below</span><br><span class="line">如果想要查看模板问卷就将下面的代码取消注释</span><br><span class="line">// template: `&lt;h1&gt;Survey&lt;/h1&gt;&lt;survey [json]=&quot;json&quot;&gt;&lt;/survey&gt;`</span><br><span class="line">// If you want to show survey editor, uncomment the line below</span><br><span class="line">如果想要编辑一份问卷就将下面的代码取消注释</span><br><span class="line">// template: `&lt;h1&gt;Survey JS Editor&lt;/h1&gt;&lt;survey-editor&gt;&lt;/survey-editor&gt;`</span><br></pre></td></tr></table></figure><h3 id="四、利用工具"><a href="#四、利用工具" class="headerlink" title="四、利用工具"></a>四、利用工具</h3><p>当我们想要建立自己的问卷时，就要利用server-editor工具即将上面的第四条代码取消注释后的工具，也可以直接通过网址使用</p><blockquote><blockquote><p><a href="https://surveyjs.io/Editor/Editor/" target="_blank" rel="noopener">https://surveyjs.io/Editor/Editor/</a></p></blockquote></blockquote><p>可以使用这个工具将所需要的问卷组件拖拽到空白区域</p><p>接着点击JSON Editor(左上角)将其中的代码除掉最外层的大括号，复制。</p><p>将app.component.ts中json数据块当中的pages删掉</p><p>将复制的内容粘贴，再打开浏览器就可以看到你制作的问卷了。</p><h3 id="五、查看提交数据格式"><a href="#五、查看提交数据格式" class="headerlink" title="五、查看提交数据格式"></a>五、查看提交数据格式</h3><blockquote><p><a href="https://surveyjs.io/Examples/Library/?id=real-productfeedback&amp;platform=Angular2#" target="_blank" rel="noopener">https://surveyjs.io/Examples/Library/?id=real-productfeedback&amp;platform=Angular2#</a></p></blockquote><p>通过网址点击侧边栏的SurveyJs Service中的Get Survey Result</p><p>填写数据，点击提交，就可以看到输出的数据格式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Survey.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular新建组件方法</title>
      <link href="/2019/03/06/angular%E6%96%B0%E5%BB%BA%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/06/angular%E6%96%B0%E5%BB%BA%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="angular新建组件方法"><a href="#angular新建组件方法" class="headerlink" title="angular新建组件方法"></a>angular新建组件方法</h1><a id="more"></a><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>工具</strong>：vs code</p><p><strong>项目名</strong>：project-app</p><h6 id="我的组件名为header"><a href="#我的组件名为header" class="headerlink" title="我的组件名为header"></a>我的组件名为header</h6><p><strong>步骤</strong>：</p><ul><li><p>vs code打开project-app项目</p></li><li><p>打开src文件夹</p></li><li><p>进入app文件夹</p></li><li><p>在app文件夹中新建一个文件夹作为组件文件夹</p></li><li><p>在文件夹中创建两个文件命名为 name.component.ts(name为你的组件名称)、name.component.html</p></li></ul><ul><li><p>在name.component.ts文件中数据以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Template &#125; from &apos;@angular/compiler/src/render3/r3_ast&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line"></span><br><span class="line">    selector:&apos;app-name&apos;,(name为你的组件名称)</span><br><span class="line"></span><br><span class="line">    templateUrl:&apos;./name.component.html&apos;此处为你的组建中新建的html文件的路径</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class HeaderComponent&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  示例代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Template &#125; from &apos;@angular/compiler/src/render3/r3_ast&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line"></span><br><span class="line">    selector:&apos;app-header&apos;,</span><br><span class="line"></span><br><span class="line">    templateUrl:&apos;./header.component.html&apos;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class HeaderComponent&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>找到app.module.ts文件，将nameCompontent添加到@NgModule中，同时在文件头部添加import { NameComponent } from ‘./header/header.compoment’; <code>此处是你组件的路径</code></p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">import &#123; AppComponent &#125; from &apos;./app.component&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; HeaderComponent &#125; from &apos;./header/header.compoment&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line"></span><br><span class="line">  declarations: [</span><br><span class="line"></span><br><span class="line">    AppComponent,</span><br><span class="line"></span><br><span class="line">    HeaderComponent,</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  imports: [</span><br><span class="line"></span><br><span class="line">    BrowserModule</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  providers: [],</span><br><span class="line"></span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件新建成功，可以开始在组件中添加内容了"><a href="#组件新建成功，可以开始在组件中添加内容了" class="headerlink" title="组件新建成功，可以开始在组件中添加内容了"></a>组件新建成功，可以开始在组件中添加内容了</h3><h2 id="方法二：命令行方式"><a href="#方法二：命令行方式" class="headerlink" title="方法二：命令行方式"></a>方法二：命令行方式</h2><ul><li>在cmd中cd到project-app文件夹</li><li>输入ng g c header即可创建组件，自动完成了以上步骤</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
