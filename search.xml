<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Oracle-02</title>
      <link href="/2019/12/17/Oracle-02/"/>
      <url>/2019/12/17/Oracle-02/</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle数据库管理"><a href="#Oracle数据库管理" class="headerlink" title="Oracle数据库管理"></a>Oracle数据库管理</h2><blockquote><p>对数据库的相关配置</p></blockquote><a id="more"></a><h4 id="导入-sql文件"><a href="#导入-sql文件" class="headerlink" title="导入.sql文件"></a>导入.sql文件</h4><ul><li>用scott用户登录之后，此时的数据库中有一部分的表但是自己可以从外部导入数据库文件以.sql结尾的<ul><li>点击左上角发光的文件图标，然后点击command Window</li><li>输入代码@+.sql文件所在路径，即可把.sql文件放到plsql所连接的数据库</li></ul></li></ul><h4 id="enterprise-manage配置"><a href="#enterprise-manage配置" class="headerlink" title="enterprise manage配置"></a>enterprise manage配置</h4><ul><li>Oracle11g已经取消了client目录下的enterprise manage，可以通过服务器文件夹的Database Control点击来登录enterprise manage;</li><li>要注意的是要想登录成功这个企业管理器，必须要开启OracleDBConsoleorcl服务和OracleoralDB11g_home1TNSListener</li><li>如果ie无法点开，那么记得换一下别的浏览器，因为ie有病</li><li>用普通用户登录会出现如下错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">应用程序要求的数据库权限超出了您当前具有的权限</span><br><span class="line"></span><br><span class="line">此时需要赋予登录的用户一个select_catalog_role的角色，让这个用户有权限</span><br></pre></td></tr></table></figure><ul><li>如果登录的那个用户要赋值给自己的话，那就会报错，报一个select_catalog_role角色不存在的错误</li><li>这时候可以使用超级用户在cmd登录然后在cmd中赋予角色</li><li>除此之外，登录企业管理器最好使用sys类型的用户，这样的权限比较高</li></ul><p><strong>服务器配置</strong></p><p>登录enterprise manage之后显示的页面内容为主目录，点击主目录右侧的服务器菜单</p><p>找到安全性模块</p><p>点击用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在这个模块可以创建用户，以及查看数据库的用户信息</span><br><span class="line">点击创建，即可创建用户</span><br><span class="line">1.输入名称</span><br><span class="line">2.概要文件默认</span><br><span class="line">3.输入口令</span><br><span class="line">4.选择默认表空间：USERS</span><br><span class="line">5.选择临时表空间：TEMP</span><br><span class="line">6.选择未锁定就行了，就可以创建了</span><br></pre></td></tr></table></figure><p>在之前登陆的scott用户中本来导入了几个表</p><p>现在我通过企业管理器新建了一个用户</p><p>然后用新建的用户tjh登陆plsql</p><p>在新登录的tjh用户中用select语句查找数据是不行的</p><p>这个时候要用到对象这种东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在用户下，选中新建的用户</span><br><span class="line">点击编辑</span><br><span class="line">点击对象权限</span><br><span class="line">选择对象类型为表</span><br><span class="line">点击添加</span><br><span class="line">选择表对象为之前导入数据的用户scott用户下的某个表</span><br><span class="line">然后把可用权限中的select权限放到所选权限</span><br><span class="line">点击确定</span><br><span class="line">这还不够</span><br><span class="line">还需要点击应用</span><br><span class="line">这时，新建的用户就可以查询表对象的那个表当中的数据了</span><br><span class="line">我这里用到的语句为select * from scott.employees;</span><br></pre></td></tr></table></figure><p>作为一个新用户，如果想要新建一个表，那会报一个没有权限的错误</p><p>这时，就可以编辑用户的系统权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为这个新用户添加CREATE ANY TABLE的权限，勾选管理选项的话，那么这个用户可以把这个权限赋予别的用户</span><br></pre></td></tr></table></figure><p>但是赋予了权限有时候也不能创建表</p><p>这是因为限额给了限制</p><p>限额中没有给你空间，那你得表就建不出来</p><p>这时可以编辑用户的限额</p><p>把默认表空间的USERS的限额调整就可以创建表了</p><p>在安全性模块下还有一个选项为<strong>角色</strong></p><p>每个角色都拥有一定的权限，可以通过把这些角色赋予给某些用户，从而让得某些用户能够拥有角色所拥有的系统权限。</p><p>角色可以自己创建，然后在创建的角色中为这个角色赋予相关的系统权限，让这个角色成为和内置的角色一样可以赋予给用户权限的角色</p><p>在plsql中，想要执行类似于创建表的那种长代码，可以敲ed然后回车，然后编辑代码后，选择OK。然后输入/再回车运行刚写的sql语句</p><p><strong>概要文件</strong></p><p>通过点击概要文件选择用户的一些配置信息，然后点击口令可以设置口令的有效期，历史记录，以及错误之后锁定账户</p><p>概要信息也是可以新建的</p>]]></content>
      
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-05</title>
      <link href="/2019/12/17/Python-05/"/>
      <url>/2019/12/17/Python-05/</url>
      
        <content type="html"><![CDATA[<h2 id="PyCharm的初始设置"><a href="#PyCharm的初始设置" class="headerlink" title="PyCharm的初始设置"></a>PyCharm的初始设置</h2><a id="more"></a><h4 id="设置项目使用的解释器版本"><a href="#设置项目使用的解释器版本" class="headerlink" title="设置项目使用的解释器版本"></a>设置项目使用的解释器版本</h4><ul><li>打开的目录如果不是由PyCharm建立的项目目录，有的时候是用的解释器版本是Python 2.x的，需要单独设置解释器的版本</li><li>通过File /Settings…可以打开设置窗口</li><li>然后点击project</li><li>然后点击project Interpreter设置Python的解释器版本</li><li>如果程序执行错误，如果程序本身没有问题，那可能就是解释器版本的问题</li></ul><h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ul><li>以后项目名前面都以数字编号，随着知识点递增，编号递增<ul><li>例如：01_Python基础、02_分支</li></ul></li><li>每个项目下的文件名都以hm_xx_知识点方式来命名<ul><li>其中xx是演练文件的序号</li></ul></li><li>注意<ul><li>命名文件名时建议只是欧诺个小写字母、数字和下划线</li><li>文件名不能以数字开始</li></ul></li><li>通过欢迎界面或者菜单File /New Project可以新建项目</li></ul><h5 id="演练步骤"><a href="#演练步骤" class="headerlink" title="演练步骤"></a>演练步骤</h5><ul><li>新建01_Python基础项目，使用Python 3.x解释器</li><li>在项目下新建hm_01_hello.pyPython文件</li><li>编写print(“Hello Python”)代码</li></ul><h5 id="设置编辑器的字体显示"><a href="#设置编辑器的字体显示" class="headerlink" title="设置编辑器的字体显示"></a>设置编辑器的字体显示</h5><ul><li>file</li><li>setting</li><li>editor</li><li>colors&amp;Fonts</li><li>font</li><li>修改字号为24</li><li>字体改为dialoginput</li><li>此时输出控制台的字体还是不好看</li><li>这是在colors&amp;font找到console font</li><li>找到字体和字号改为dialoginput和24即可</li></ul><h5 id="Pycharm的升级以及其他"><a href="#Pycharm的升级以及其他" class="headerlink" title="Pycharm的升级以及其他"></a>Pycharm的升级以及其他</h5><blockquote><p>PyCharm提供了对学生和教师免费使用的版本</p></blockquote><ul><li>教育版下载地址：<a href="http://www.jetbrains.com/pycharm-edu/download/#section=linux" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li><li>专业版下载地址：<a href="http://www.jetbrains.com/pycharm/download/#section=linux" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/download/#section=linux</a></li></ul><p><strong>安装和启动步骤</strong></p><ul><li>执行以下终端命令，解压缩后的安装包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf pycharm-prifessional-2017.1.3.tar.gz</span><br></pre></td></tr></table></figure><ul><li>将解压缩的目录移动到/opt目录下，可以方便其他用户使用</li></ul><blockquote><p>/opt目录用户存放给主机额外安装的软件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv pycharm-2017.1.3/ /opt/</span><br></pre></td></tr></table></figure><ul><li>切换工作目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/pycharm-2017.1.3/bin</span><br></pre></td></tr></table></figure><ul><li>启动PyCharm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.pycharm.sh</span><br></pre></td></tr></table></figure><h5 id="设置专业版启动图标"><a href="#设置专业版启动图标" class="headerlink" title="设置专业版启动图标"></a>设置专业版启动图标</h5><ul><li>在专业版中，选择菜单Tools/Create Desktop Entery…可以设置任务栏启动图标<ul><li>注意设置图标时需要勾选create the enter for all users</li></ul></li></ul><h5 id="卸载之前版本的Pycharm"><a href="#卸载之前版本的Pycharm" class="headerlink" title="卸载之前版本的Pycharm"></a>卸载之前版本的Pycharm</h5><p><strong>程序安装</strong></p><ul><li>程序文件目录<ul><li>将安装包解压缩，并且移动到/opt目录下</li><li>所有相关的文件都保存在解压缩的目录中</li></ul></li><li>配置文件目录<ul><li>启动PyCharm后，会在用户家目录下建立一个.PyCharmxxx的隐藏目录</li><li>保存PyCharm相关的配置信息</li></ul></li><li>快捷方式文件<ul><li>/user/share/applications/jetbrains-pycharm.desktop</li></ul></li></ul><blockquote><p>在ubuntu中，应用程序启动的快捷方式通常都保存在/user/share/applications目录下</p></blockquote><h5 id="程序卸载"><a href="#程序卸载" class="headerlink" title="程序卸载"></a>程序卸载</h5><ul><li>要卸载PyCharm只需要做以下两部工作：</li><li>删除解压缩目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -r /opt/pycharm-2016.3.1/</span><br></pre></td></tr></table></figure><ul><li>删除家目录下用于保存配置信息的吟唱目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r ~/.PyCharm2016.3</span><br></pre></td></tr></table></figure><blockquote><p>如果不再适用PyCharm还需要将/user/share/applications下的jetbrains-pycharm.desktop删掉</p></blockquote><h5 id="教育版安装演练"><a href="#教育版安装演练" class="headerlink" title="教育版安装演练"></a>教育版安装演练</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//解压缩下载后的安装包</span><br><span class="line">tar -zxvf pycharm-edu.3.5.1.tar.gz</span><br><span class="line">//将解压缩后的目录移动到&apos;/opt&apos;目录下，可以方便其他用户使用</span><br><span class="line">sudo mv pycharm-edu-3.5.1/ /opt/</span><br><span class="line">//启动&apos;PyCharm&apos;</span><br><span class="line">/opt/pycharm-edu-3.5.1/bin/pycharm.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-04</title>
      <link href="/2019/12/17/Python-04/"/>
      <url>/2019/12/17/Python-04/</url>
      
        <content type="html"><![CDATA[<h2 id="Python的IDE——PyCharm"><a href="#Python的IDE——PyCharm" class="headerlink" title="Python的IDE——PyCharm"></a>Python的IDE——PyCharm</h2><a id="more"></a><h4 id="PyCharm介绍"><a href="#PyCharm介绍" class="headerlink" title="PyCharm介绍"></a>PyCharm介绍</h4><ul><li>PyCharm是Python的一款非常优秀的集成开发环境</li><li>PyCharm除了具有一般IDE所必备功能外，还可以在Windows、Linux、macOS使用</li><li>PyCharm适合开发大型项目<ul><li>一个项目通常会包含很多源文件</li><li>每个源文件的代码的代码行数是有限的，通常在几百行代码之内</li><li>每个源文件各司其职，共同完成复杂的业务功能。</li></ul></li></ul><h4 id="PyCharm快速体验"><a href="#PyCharm快速体验" class="headerlink" title="PyCharm快速体验"></a>PyCharm快速体验</h4><ul><li>文件导航区域能够浏览/定位/打开项目文件</li><li>文件编辑区域能够编辑当前打开的文件</li><li>控制台区域能够:<ul><li>输出程序执行内容</li><li>跟踪调试代码的执行</li></ul></li><li>右上角的工具栏能够执行（SHIFT+F10）/调试（SHIFT+F9)代码</li></ul><h4 id="PyCharm的初始设置（知道）"><a href="#PyCharm的初始设置（知道）" class="headerlink" title="PyCharm的初始设置（知道）"></a>PyCharm的初始设置（知道）</h4><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><ul><li>恢复PyCharm的初始设置</li><li>第一次启动PyCharm</li><li>新建一个Python项目</li><li>设置PyCharm的字体显示</li><li>PyCharm的升级以及其他</li></ul><p>PyCharm的官方网站地址是：<a href="https://www.ietbrains.com/pytharm/" target="_blank" rel="noopener">https://www.ietbrains.com/pytharm/</a></p><h5 id="恢复PyCharm的初始设置"><a href="#恢复PyCharm的初始设置" class="headerlink" title="恢复PyCharm的初始设置"></a>恢复PyCharm的初始设置</h5><p>PyCharm的配置信息是保存在用户家目录下的.PyCharmxxxx.x目录下的，xxxx.x表示当前使用的PyCharm的版本号</p><p>如果要恢复PyCharm的初始设置，可以按照以下步骤进行：</p><ul><li>关闭PyCharm</li><li>在终端中执行以下终端命令，删除PyCharm的配置信息目录：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r ~/PyCharm2016.3</span><br></pre></td></tr></table></figure><ul><li>重新启动PyCharm</li></ul><h4 id="第一次启动PyCharm"><a href="#第一次启动PyCharm" class="headerlink" title="第一次启动PyCharm"></a>第一次启动PyCharm</h4><ol><li>导入配置信息</li><li>选择许可协议</li><li>配置初始界面</li></ol><h5 id="导入配置信息"><a href="#导入配置信息" class="headerlink" title="导入配置信息"></a>导入配置信息</h5><ul><li>在第一次启动PyCharm时，会首先提示用户是否导入之前的配置信息</li><li>如果是第一次使用，直接点击OK按钮</li></ul><h5 id="选择许可协议"><a href="#选择许可协议" class="headerlink" title="选择许可协议"></a>选择许可协议</h5><ul><li>PyCharm是一个付费软件，购买费用为199美金/年或者19.9美金/月</li><li>不过PyCharm提供了对学生和教师免费使用的版本<ul><li>下载地址是：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li></ul></li><li>商业版本会提示输入注册信息，或者选择免费评估</li></ul><h5 id="PyCharm的配置初始界面"><a href="#PyCharm的配置初始界面" class="headerlink" title="PyCharm的配置初始界面"></a>PyCharm的配置初始界面</h5><ul><li>在初始配置界面，可以通过Editor color and fonts选择编辑器的配色方案</li></ul><h5 id="欢迎界面"><a href="#欢迎界面" class="headerlink" title="欢迎界面"></a>欢迎界面</h5><ul><li>所有基础配置工作结束之后，就可以看到PyCharm的欢迎界面了，通过欢迎界面就可以开始开发Python项目了</li></ul><h4 id="新建-打开一个PyCharm项目"><a href="#新建-打开一个PyCharm项目" class="headerlink" title="新建/打开一个PyCharm项目"></a>新建/打开一个PyCharm项目</h4><h5 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h5><ul><li>开发项目就是开发一个专门解决一个复杂业务功能的软件</li><li>通常每一个项目就具有一个独立专属的目录，用于保存所有和项目相关的文件<ul><li>一个项目通常会包含很多源文件</li></ul></li></ul><h5 id="打开Python项目"><a href="#打开Python项目" class="headerlink" title="打开Python项目"></a>打开Python项目</h5><ul><li>直接点击Open按钮，然后浏览到之前保存Python文件的目录，即可以打开项目</li><li>打开之后，会在目录下新建一个.idea的目录，用于保存项目相关的信息，例如：解释器版本、项目包含的文件等等</li><li>第一次打开项目，需要耐心等待PyCharm对项目的初始配置</li><li>第一次打开PyCharm的时候右上角的工具栏不能用，需要右键先运行一下程序才能使用右上角的工具栏</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle-01</title>
      <link href="/2019/12/16/Oracle-01/"/>
      <url>/2019/12/16/Oracle-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle数据库-Oracle数据库的安装和配置"><a href="#Oracle数据库-Oracle数据库的安装和配置" class="headerlink" title="Oracle数据库_Oracle数据库的安装和配置"></a>Oracle数据库_Oracle数据库的安装和配置</h1><a id="more"></a><h2 id="Oracle数据库11g"><a href="#Oracle数据库11g" class="headerlink" title="Oracle数据库11g"></a>Oracle数据库11g</h2><ul><li>选择基本安装</li><li>安装类型为企业版</li><li>数据库口令为小写字母+数字加大写字母</li></ul><h2 id="Oracle简介"><a href="#Oracle简介" class="headerlink" title="Oracle简介"></a>Oracle简介</h2><ul><li>Oracle是殷墟出土的<strong>甲骨文</strong>(oracle bone inscriptions)的英文翻译的第一个单词</li><li><strong>Oracle</strong> <strong>公司</strong>是全球最大的信息管理软件及服务供应商，成立于1977年，总部位于美国加州<br>Redwood shore</li><li>Oracle公司<strong>因其复杂的关系数据库产品</strong>而闻名。Oracle的关系数据库是世界第一个支持SQL语言的数据库</li></ul><h2 id="Oracle数据库概述"><a href="#Oracle数据库概述" class="headerlink" title="Oracle数据库概述"></a>Oracle数据库概述</h2><ul><li>Oracle数据库是一种网络上的数据库, 它在网络上支持多用户, 支持服务器/客户机等部署(或配置)</li><li>服务器与客户机是软件概念, 它们与计算机硬件不存在一一对应的关系. 即: 同一台计算机既可以充当服务器又可以充当客户机, 或者, 一台计算机只充当服务器或只充当充当客户机</li></ul><h4 id="Oracle数据库体系结构简介"><a href="#Oracle数据库体系结构简介" class="headerlink" title="Oracle数据库体系结构简介"></a>Oracle数据库体系结构简介</h4><ul><li>平常所说的 Oracle 或 Oracle 数据库指的是 Oracle 数据库管理系统. Oracle 数据库管理系统是管理数据库访问的计算机软件(Oracle database manager system). 它由 Oracle 数据库和 Oracle 实例(instance)构成.</li><li>Oracle 数据库: 一个相关的操作系统文件(即存储在计算机硬盘上的文件)集合,这些文件组织在一起, 成为一个逻辑整体, 即为 Oracle 数据库. <ul><li>Oracle 用它来存储和管理相关的信息.Oracle数据库必须要与内存里实例合作，才能对外提供数据管理服务。</li></ul></li><li>Oracle 实例: 位于物理内存里的数据结构，它由操作系统的多个后台进程和一个共享的内存池所组成,共享的内存池可以被所有进程访问.<ul><li>Oracle 用它们来管理数据库访问.用户如果要存取数据库(也就是硬盘上的文件) 里的数据, 必须通过Oracle实例才能实现, 不能直接读取硬盘上的文件.</li><li>实际上, Oracle 实例就是平常所说的数据库服务(service) .</li></ul></li><li><strong>区别：</strong>实例可以操作数据库；在任何时刻一个实例只能与一个数据库关联，访问一个数据库；而同一个数据库可由多个实例访问（RAC）</li></ul><h4 id="Oracle数据库的启动"><a href="#Oracle数据库的启动" class="headerlink" title="Oracle数据库的启动"></a>Oracle数据库的启动</h4><ul><li>Oracle 数据库是一个庞大的软件. 启动它会占有大量的内存和 CPU 资源. 如果不想让 Oracle 数据库自动启动. 可做如下设置:<ul><li>我的电脑-管理-服务和应用程序-服务：</li><li>将ServiceORCL和Listener设置为手动，其它禁用</li></ul></li></ul><h2 id="Oracle数据库客户端的登录"><a href="#Oracle数据库客户端的登录" class="headerlink" title="Oracle数据库客户端的登录"></a>Oracle数据库客户端的登录</h2><ul><li>点全部文件</li><li>找到Oracle数据库客户端文件夹</li><li>点应用程序开发</li><li>点SQL plus，以管理员权限运行</li></ul><p>若忘记了自己的用户名和密码</p><p>则直接运行cmd</p><p>输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba   //以sys登陆 超级用户（sysdba）</span><br><span class="line">alter user 用户名 account unlock;  //解除锁定(必须带“;”号)</span><br><span class="line">alter user 用户名 identified by 密码;  //修改密码</span><br><span class="line">//此处我用的是scoot用户</span><br></pre></td></tr></table></figure><p>这样就可以登录数据库了，登陆之后通过如下代码可以查看系统有什么用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct owner from all_objects</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sysdate from dual; //返回系统的当前时间，如何这个程序能正常执行那么数据库安装基本没问题</span><br></pre></td></tr></table></figure><h4 id="配置监听程序"><a href="#配置监听程序" class="headerlink" title="配置监听程序"></a>配置监听程序</h4><ul><li>配置和移植程序——NET Manage</li><li>新增监听程序——添加地址——添加数据库</li><li>将类似于我电脑的C:\app\yu\product\11.2.0\dbhome_1这个目录复制到Oracle的主目录</li><li>保存网络配置</li></ul><ul><li>配置监听程序和本地网络服务名</li><li>client——Net Configuration Assistant管理员程序运行</li><li>执行相关配置任务</li></ul><p>如果不能连接sql，修改listener.ora文件，加入SID那一部分的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># listener.ora Network Configuration File: C:\app\yu\product\11.2.0\dbhome_1\network\admin\listener.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line"></span><br><span class="line">SID_LIST_LISTENER =</span><br><span class="line">  (SID_LIST =</span><br><span class="line">    (SID_DESC =</span><br><span class="line">      (SID_NAME = CLRExtProc)</span><br><span class="line">      (ORACLE_HOME = C:\app\yu\product\11.2.0\dbhome_1)</span><br><span class="line">      (PROGRAM = extproc)</span><br><span class="line">      (ENVS = &quot;EXTPROC_DLLS=ONLY:C:\app\yu\product\11.2.0\dbhome_1\bin\oraclr11.dll&quot;)</span><br><span class="line">    )</span><br><span class="line">    (SID_DESC =</span><br><span class="line">        (GLOBAL_DBNAME = ORCL)</span><br><span class="line">        (ORACLE_HOME = C:\app\yu\product\11.2.0\dbhome_1)</span><br><span class="line">        (SID_NAME = ORCL)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">LISTENER =</span><br><span class="line">  (DESCRIPTION_LIST =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">ADR_BASE_LISTENER = C:\app\yu</span><br></pre></td></tr></table></figure><p>如果数据库选择没有选项</p><p>在tools的perference设置</p><p>Oracle Home为OraDb11g_home1</p><p>OCI library为client\bin\oci.dll</p><p>如果不能使用64位，则要下载32位client并且重新设置Oracle Home以及OCI library，设置为32位的</p>]]></content>
      
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-03</title>
      <link href="/2019/12/16/Python-03/"/>
      <url>/2019/12/16/Python-03/</url>
      
        <content type="html"><![CDATA[<p>Python程序错误与版本、执行Python程序的方式以及认识IDE</p><a id="more"></a><h2 id="Python程序错误"><a href="#Python程序错误" class="headerlink" title="Python程序错误"></a>Python程序错误</h2><ul><li>4&gt;python 2.x默认不支持中文</li></ul><p>目前市场上有两个Python的版本并存着，分别是Python 2.x和Python 3.x</p><ul><li>Python 2.x默认不支持中文，具体原因，等到介绍字符编码时给大家讲解</li><li>Python 2.x的解释器名称是python</li><li>Python 3.x的解释器名称是python3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &apos;\xe4&apos; in file 01-HelloPython.py on line 3,</span><br><span class="line">but no encoding declared;</span><br><span class="line">see http://python. org/dew/peps/pep-0263/ for details</span><br><span class="line">语法错误:在01-HelloPython.py 中第3行出现了非ASCII 字符&apos;xe4&apos;, 但是没有声明文件编码</span><br><span class="line">请访问http://python. org/dev/peps/pep-0263/了解详细信息</span><br></pre></td></tr></table></figure><blockquote><ul><li>ASCII字符只包含256个字符，不支持中文</li><li>有关字符编码的问题，后续会讲</li></ul></blockquote><h2 id="Python-2-x与3-x版本简介"><a href="#Python-2-x与3-x版本简介" class="headerlink" title="Python 2.x与3.x版本简介"></a>Python 2.x与3.x版本简介</h2><p>目前市场上有两个Python的版本并存着，分别是Python 2.x和Python 3.x</p><blockquote><p>新的 Python程序建议使用Python 3.0版本的语法</p></blockquote><ul><li>Python 2.x是过去的版本<ul><li>解释器名称是python</li></ul></li><li>Python 3.x是现在和未来主流的版本<ul><li>解释器名称是python3</li><li>相对于Python的早期版本，这是一个较大的升级</li><li>为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下兼容<ul><li>许多早期Python 版本设计的程序都无法在Python 3.0上正常执行</li></ul></li><li>Python3.0发布于2008年</li><li>到目前为止，Python 3.0的稳定版本已经有很多年了<ul><li>Python 3.3发布于2012</li><li>Python 3.4发布于2014</li><li>Python3.5发布于2015</li><li>Python 3.6发布于2016</li></ul></li></ul></li><li>为了照顾现有的程序，官方提供了-一个过渡版本– Python 2.6<ul><li>基本使用了Python 2.x的语法和库</li><li>同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0 的语法与函数</li><li>2010 年中推出的Python 2.7 被确定为最后-个Python 2.x版本</li></ul></li></ul><blockquote><p>提示:如果开发时，无法立即使用Python 3.0 (还有极少的第三方库不支持3.0的语<br>法)，建议</p><ul><li>先使用Python 3.0版本进行开发</li><li>然后使用Python 2.6、 Python 2.7 来执行，并且做-些兼容性的处理</li></ul></blockquote><h2 id="执行Python程序的三种方式"><a href="#执行Python程序的三种方式" class="headerlink" title="执行Python程序的三种方式"></a>执行Python程序的三种方式</h2><h4 id="解释器Python-Python3"><a href="#解释器Python-Python3" class="headerlink" title="解释器Python/Python3"></a>解释器Python/Python3</h4><p>python的解释器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用python 2.x解释器</span><br><span class="line">python xxx.py</span><br><span class="line">//使用python 3.x解释器</span><br><span class="line">python3 xxx.py</span><br></pre></td></tr></table></figure><h5 id="其他解释器（知道）"><a href="#其他解释器（知道）" class="headerlink" title="其他解释器（知道）"></a>其他解释器（知道）</h5><p>Python的解释器如今有多个语言的实现，包括：</p><ul><li>CPython——官方版本的C语言实现</li><li>Jython——可以运行在Java平台</li><li>IronPython——可以运行在.NET和Mone平台</li><li>PyPy——Python实现的，支持JIT即时编译</li></ul><h4 id="交互式运行Python程序"><a href="#交互式运行Python程序" class="headerlink" title="交互式运行Python程序"></a>交互式运行Python程序</h4><ul><li>直接在终端中运行解释器，而不输入要执行的文件名</li><li>在Python的Shell中直接输入Python的代码，会立即看到程序执行结果</li></ul><p>1）交互式运行Python的优缺点</p><p>优点</p><ul><li>适合于学习/验证Python语法或者局部代码</li></ul><p>缺点</p><ul><li>代码不能保存</li><li>不适合运行太大的程序</li></ul><p>2）退出 官方的解释器</p><p>1&gt;直接输入exit()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;exit()</span><br></pre></td></tr></table></figure><p>输入exit不加小括号的话就能看到退出Shell的快捷键</p><p>2&gt;使用热键退出</p><p>在python解释其中，按热键ctrl + d可以退出解释器</p><p>3）IPython</p><ul><li>IPython中的”i“代表交互interactive</li></ul><p>特点</p><ul><li>IPython是一个python的交互式shell，比默认的python shell 好用得多<ul><li>支持自动补全</li><li>自动缩进</li><li>支持bash shell命令</li><li>内置了许多很有用的功能和函数</li></ul></li><li>IPython是基于BSD开源的</li></ul><p>版本</p><ul><li>Python 2.x使用的解释器是ipython</li><li>Python 3.x使用的解释器是ipython3</li><li>要退出解释器可以有以下两种方式：</li></ul><p>1&gt;直接输入exit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;exit //不需要括号</span><br></pre></td></tr></table></figure><p>2&gt;使用热键退出</p><p>在IPython解释器中，按热键ctrl+d,IPython会询问是否退出解释器</p><h2 id="Python的IDE——PyCharm"><a href="#Python的IDE——PyCharm" class="headerlink" title="Python的IDE——PyCharm"></a>Python的IDE——PyCharm</h2><h4 id="1-集成开发环境-IDE"><a href="#1-集成开发环境-IDE" class="headerlink" title="1)集成开发环境(IDE)"></a>1)集成开发环境(IDE)</h4><p>集成开发环境(IDE,Integrated Development Environment)——集成了开发软件需要的所有工具一般包括以下工具：</p><ul><li>图形用户界面</li><li>代码编辑器（支持代码补全/自动缩进）</li><li>编译器/解释器</li><li>调试器（断点/单步执行）</li><li>……</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-02</title>
      <link href="/2019/12/16/Python-02/"/>
      <url>/2019/12/16/Python-02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Python的优缺点及第一个Python程序及错误</p></blockquote><a id="more"></a><h2 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>简单、易学</li><li>免费、开源</li><li>面向对象</li><li>丰富的库</li><li>可扩展性<ul><li>如果需要一段关键代码运行得更开或者希望某些算法不公开，可以把这部分程序用C或C++编写，然后在Python程序中使用它们</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>运行速度</li><li>国内市场较小</li><li>中文资料匮乏</li></ul><h2 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>第一个HelloPython程序</li><li>Python 2.x与3.x版本简介</li><li>执行Python程序的三种方式<ul><li>解释器——Python/Python3</li><li>交互式——ipython</li><li>集成开发环境——pycharm</li></ul></li></ul><h4 id="第一个HelloPython程序"><a href="#第一个HelloPython程序" class="headerlink" title="第一个HelloPython程序"></a>第一个HelloPython程序</h4><h5 id="Python源程序的基本概念"><a href="#Python源程序的基本概念" class="headerlink" title="Python源程序的基本概念"></a>Python源程序的基本概念</h5><ol><li>Python源程序就是一个特殊格式的文本文件，可以使用任意文本编辑软件做Python的开发</li><li>Python程序的文件扩展名通常都是.py</li></ol><h5 id="演练步骤"><a href="#演练步骤" class="headerlink" title="演练步骤"></a>演练步骤</h5><ul><li>在桌面下，新建<strong>认识Python</strong>目录</li><li>在认识Python目录下新建01-HelloPython.py文件</li><li>使用gedit编辑01-HelloPython.py并且输入以下内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello python&quot;)</span><br><span class="line">print(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><ul><li>在终端中输入以下命令执行01-HelloPython.py</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 01-HelloPython.py</span><br></pre></td></tr></table></figure><blockquote><p>print是python中我们学习的第一个函数</p><p>print函数的作用，可以把“”内部的内容，输出到屏幕上</p></blockquote><h5 id="安装exe软件方法"><a href="#安装exe软件方法" class="headerlink" title="安装exe软件方法"></a>安装exe软件方法</h5><p>在unbuntu中想要输入中文，我就想装一个搜狗输入法，结果按照windows的方法双击运行会出现“装入归档文件时出现了一个错误”的提示，所以查找了一下发现要用wine安装才行，然后执行如下代码安装wine</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wine</span><br></pre></td></tr></table></figure><p>报如下错误</p><p>正在读取软件包列表… 完成<br>正在分析软件包的依赖关系树<br>正在读取状态信息… 完成<br>虚拟软件包 wine 由下面的软件包提供：<br>  wine-stable 3.0-1ubuntu1<br>  wine-development 3.6-1<br>请您明确地选择安装其中一个。</p><p>E: 软件包 wine 没有可安装候选</p><p>查找了解决方案后，执行如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wine-stable=3.0-1ubuntu1</span><br></pre></td></tr></table></figure><p>wine就可以安装啦</p><h5 id="演练扩展——认识错误（BUG"><a href="#演练扩展——认识错误（BUG" class="headerlink" title="演练扩展——认识错误（BUG)"></a>演练扩展——认识错误（BUG)</h5><p>关于错误</p><ul><li>编写的程序不能正常执行，或者执行的结果不是我们期望的</li><li>俗称BUG，是程序员在开发时非常常见的，初学者常见错误的原因包括：<ul><li>手误</li><li>对已经学习过的知识理解还存在不足</li><li>对语言还有需要学习和提升的内容</li></ul></li><li>在学习语言时，不仅要学会语言的语法，而且还要学会如何认识错误和解决错误的方法</li></ul><blockquote><p>每一个程序员都是在不断地修改错误中成长的</p></blockquote><h5 id="第一个演练中的常见问题"><a href="#第一个演练中的常见问题" class="headerlink" title="第一个演练中的常见问题"></a>第一个演练中的常见问题</h5><ul><li>1&gt;手误，例如使用print(“Hello world”)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NameError:name &apos;print&apos; is not defined</span><br><span class="line">名称错误：&apos;pirnt&apos;名字没有定义</span><br></pre></td></tr></table></figure><ul><li>2&gt;将多条print写在一行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError:invalid syntax</span><br></pre></td></tr></table></figure><blockquote><p>每行代码负责完成一个任务</p></blockquote><ul><li>3&gt;缩进错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IndentationError:unexpect indent</span><br><span class="line">缩进错误：不期望出现的缩进</span><br></pre></td></tr></table></figure><blockquote><ul><li>Python是一个格式非常严格的程序设计语言</li><li>目前而言，大家记住每行代码前面都不要增加空格</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-01</title>
      <link href="/2019/12/15/Python-01/"/>
      <url>/2019/12/15/Python-01/</url>
      
        <content type="html"><![CDATA[<h2 id="Python正式开始"><a href="#Python正式开始" class="headerlink" title="Python正式开始"></a>Python正式开始</h2><blockquote><p>主要讲解释器、Python的设计目标、Python的设计哲学、选择Python的原因以及Python的特点，还涉及一点面向对象。</p></blockquote><a id="more"></a><h3 id="解释器（科普）"><a href="#解释器（科普）" class="headerlink" title="解释器（科普）"></a>解释器（科普）</h3><p>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为编译器。</p><p>编译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译时间点的不同，当编译器以解释方式运行的时候，也称之为解释器。</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1576376542693.png" alt="1576376542693"></p><ul><li>编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了，程序执行效率高，依赖编译器，跨平台性差些，如C、C++</li><li>解释型语言：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行</li></ul><p>编译型语言和解释型语言对比</p><ul><li>速度——编译型语言比解释型语言执行速度快</li><li>跨平台性——解释型语言比编译型语言跨平台性好</li></ul><h3 id="Python的设计目标"><a href="#Python的设计目标" class="headerlink" title="Python的设计目标"></a>Python的设计目标</h3><ul><li>一门简单直观的语言并与主要的竞争者一样强大</li><li>开源，以便为Python做贡献</li><li>代码像纯英语那样容易理解</li><li>适用于短期开发的日常任务</li></ul><h3 id="Python的设计哲学"><a href="#Python的设计哲学" class="headerlink" title="Python的设计哲学"></a>Python的设计哲学</h3><p>用一种方法，最好是只有一种方法来做一件事</p><h3 id="为什么选择Python"><a href="#为什么选择Python" class="headerlink" title="为什么选择Python"></a>为什么选择Python</h3><ul><li>代码量少</li><li>……</li></ul><blockquote><p>同一样问题，用不同的语言解决，代码量差距较大，一般情况下Python是Java的1/5，所以说人生苦短，我用Python</p></blockquote><h3 id="Python特点"><a href="#Python特点" class="headerlink" title="Python特点"></a>Python特点</h3><ul><li>Python是完全面向对象的语言<ul><li>函数、模块、数字、字符串都是对象，在Python中一切皆对象</li><li>完全支持继承、重载、多重继承</li><li>支持重载运算符，也支持泛型设计</li></ul></li><li>Python拥有一个强大的标准库，Python语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数，而由Python标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、XML处理等额外的功能</li><li>Python社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖科学计算、人工智能、机器学习、Web开发、数据库接口、图形系统多个领域。</li></ul><h4 id="面向对象的思维方式"><a href="#面向对象的思维方式" class="headerlink" title="面向对象的思维方式"></a>面向对象的思维方式</h4><ul><li>面向对象是一种<strong>思维方式</strong>，也是一门程序设计技术</li><li>要解决一个问题前，首先考虑由<strong>谁</strong>来做，怎么做事情是<strong>谁</strong>的职责，最后把事情做好就行<ul><li>对象就是<strong>谁</strong></li></ul></li><li>要解决复杂的问题，就可以找多个<strong>不同的对象</strong>，各司其职，共同实现，最终完成需求</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-12</title>
      <link href="/2019/12/15/Python-Linux-12/"/>
      <url>/2019/12/15/Python-Linux-12/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要内容为gzip,bzip2的压缩解压缩以及Linux软件的安装</p></blockquote><a id="more"></a><h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h2><ul><li>tar与gzip命令结合可以使用实现文件打包和压缩<ul><li>tar只负责打包文件，但不压缩</li><li>用gzip压缩tar打包后的文件，其扩展名一般用xxx.tar.gz</li></ul></li></ul><blockquote><p>在Linux中，最常见的压缩文件格式就是xxx.tar.gz</p></blockquote><ul><li>在tar命令中有一个选项 -z 可以调用gzip，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//压缩文件</span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件/路径</span><br><span class="line">//解压缩文件</span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line">//解压缩到指定路径</span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure><h2 id="之前的演练改良"><a href="#之前的演练改良" class="headerlink" title="之前的演练改良"></a>之前的演练改良</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf py.tar.gz *.py//将三个文件压缩到py.tar.gz的文件</span><br><span class="line">mkdir gz //新建一个文件用于存放解压缩文件</span><br><span class="line">mv py.tar.gz gz //将压缩文件移动到新建文件夹</span><br><span class="line">tree //查看当前目录结构</span><br><span class="line">cd gz //切换到解压文件夹</span><br><span class="line">tar -zxvf py.tar.gz //解压文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>解压缩到指定目录，注意，要解压缩的目录必须存在</td></tr></tbody></table><h2 id="bzip2-two"><a href="#bzip2-two" class="headerlink" title="bzip2(two)"></a>bzip2(two)</h2><ul><li>tar与bzip2命令结合可以使用实现文件打包和压缩(用法和gzip一样)<ul><li>tar只负责打包文件，但不压缩</li><li>用bzip2压缩tar打包后的文件，其扩展名一般用xxx.tar.bz2</li></ul></li><li>在tar命令中有一个选项-j可以调用bzip2，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf 打包文件.tar.bz2 //被压缩的文件/路径…</span><br><span class="line">tar -jxvf 打包文件.tar.bz2 //加压缩文件</span><br><span class="line">//命令演练</span><br><span class="line">tar -jcvf py.tar.bz2 *.py //压缩文件</span><br><span class="line">tar -jxvf py.tar.bz2 -C bz2 //解压文件到指定文件夹</span><br></pre></td></tr></table></figure><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h2 id="通过apt安装-卸载软件"><a href="#通过apt安装-卸载软件" class="headerlink" title="通过apt安装/卸载软件"></a>通过apt安装/卸载软件</h2><ul><li>apt是Advanced Packagiing Tool，是Linux下的一款安装包管理工具</li><li>可以在终端中方便的安装/卸载/更新软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install 软件包 //安装软件</span><br><span class="line">sudo apt remove 软件名 //卸载软件</span><br><span class="line">sudo apt upgrade //更新已安装的包</span><br></pre></td></tr></table></figure><h2 id="安装演练"><a href="#安装演练" class="headerlink" title="安装演练"></a>安装演练</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在终端中输出一个小火车提示</span><br><span class="line">sudo apt install sl //需要输入超级用户密码</span><br><span class="line">//一个比较漂亮的查看当前进程排名的软件</span><br><span class="line">sudo apt install htop</span><br><span class="line">//当运行htop程序时，要是想要退出程序就点一个q</span><br></pre></td></tr></table></figure><h2 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h2><ul><li>如果希望在ubuntu中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器，来提供软件下载/安装服务</li><li>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</li></ul><blockquote><p>所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些</p></blockquote><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1576373894849.png" alt="1576373894849"></p><h4 id="设置镜像源"><a href="#设置镜像源" class="headerlink" title="设置镜像源"></a>设置镜像源</h4><p>点击系统设置的软件</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1576373933726.png" alt="1576373933726"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-11</title>
      <link href="/2019/11/14/Python-Linux-11/"/>
      <url>/2019/11/14/Python-Linux-11/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux相关命令"><a href="#Linux相关命令" class="headerlink" title="Linux相关命令"></a>Linux相关命令</h1><a id="more"></a><h2 id="软连接演练"><a href="#软连接演练" class="headerlink" title="软连接演练"></a>软连接演练</h2><ul><li>将桌面目录下的01.py移动到demo/b/c目录下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree确认一下我们要移动的目标路径</span><br><span class="line">mv 01.py demo/b/c</span><br></pre></td></tr></table></figure><ul><li>在桌面目录下新建01.py的软链接FirstPython<ul><li>分别使用相对路径和绝对路径建立FirstPyhon的软链接</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ln -s demo/b/c/01/py 01_xiangdui</span><br><span class="line">cat 01_xiangdui</span><br><span class="line">ls -l</span><br><span class="line">ln -s /home/python/Desktop/demo/b/c/01.py 01_juedui</span><br><span class="line">cat 01_juedui</span><br><span class="line">ls -l</span><br><span class="line">cat 01_xiangdui</span><br><span class="line">cat 01_juedui</span><br></pre></td></tr></table></figure><ul><li>将FirstPython移动到demo目录下，对比使用相对路径和绝对路径的区别</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tree看当前目录结构</span><br><span class="line">用一个命令把两个文件移动到同一个目录</span><br><span class="line">mv 01* demo</span><br><span class="line">tree</span><br><span class="line">相对路径的颜色为红色</span><br><span class="line">绝对路径的颜色为蓝色</span><br><span class="line">此时cat 01_juedui可看文件</span><br><span class="line">cat 02_xiangdui文件不可阅</span><br></pre></td></tr></table></figure><p>建立软链接的时候使用的是绝对路径的话，不管软链接移动到哪里都可以正常访问，但是软链接如果使用相对路径的话，则软链接不能改变目录</p><p>因此建立软链接的时候最好使用绝对路径</p><h2 id="硬链接简介"><a href="#硬链接简介" class="headerlink" title="硬链接简介"></a>硬链接简介</h2><ul><li>在使用ln建立链接时，如果没有-s选项，会创建一个硬链接，而不是软链接</li></ul><p><strong>硬链接演练</strong></p><ul><li>在~/Desktop/demo建立~/Desktop/demo/b/c/01.py的硬链接01_hard</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先在demo目录下tree</span><br><span class="line">然后建立硬链接ln /home/python/Desktop/demo/b/c/01.py 01_hard</span><br><span class="line">tree</span><br><span class="line">ls -l</span><br><span class="line">cat 01_hard可以看文件内容</span><br></pre></td></tr></table></figure><ul><li>使用ls -l看文件的硬链接数（硬链接——有多少种方式可以访问文件或者目录）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><ul><li>删除~/Desktop/demo/b/c/01.py,并且使用tree来确认demo目录下的三个链接文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm b/c/01.py</span><br><span class="line">tree</span><br><span class="line">此时软链接文件已经不能用，但是硬链接文件可以用</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>文件软硬链接的示意图</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1573696453563.png" alt="1573696453563"></p><p>在Linux，文件名和文件的数据是分开存储的</p><ul><li>提示：<ul><li>在Linux，只有文件的硬链接数==0才会让删除</li><li>使用ls -l可以看一个文件的硬链接的数量</li><li>在工作时，几乎不会建立文件的硬链接</li></ul></li></ul><h2 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h2><ul><li>打包压缩是工作时备份文件的一种方式</li><li>在不同系统，常用的打包压缩方式是不同的<ul><li>Windows常用rar</li><li>Mac常用zip</li><li>Linux常用tar.gz</li></ul></li></ul><h2 id="打包-解包"><a href="#打包-解包" class="headerlink" title="打包/解包"></a>打包/解包</h2><ul><li>tar是Linux最常用的备份工具，此命令可以把一系列文件打包到一个大文件夹，也可以把一个打包的大文件恢复成一些文件</li><li>tar的命令格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//打包文件</span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件/路径……</span><br><span class="line">//解包文件</span><br><span class="line">tar -xvf 打包文件/tar</span><br></pre></td></tr></table></figure><ul><li>tar选项说明</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解档案文件</td></tr><tr><td>v</td><td>列出归档解档的详细过程，显示归档解档过程</td></tr><tr><td>f</td><td>制定档案文件名称，f一定接.tar文件，所以必须放选项最后</td></tr></tbody></table><blockquote><p>注意：f选项必须放最后，其他选项顺序可以随意</p></blockquote><p><strong>打包解包演练</strong></p><ol><li>删除桌面下的所有内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r *</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><ol start="2"><li>在桌面新建三个文件01.py、02.py、03.py</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch 01.py</span><br><span class="line">touch 02.py</span><br><span class="line">touch 03.py</span><br></pre></td></tr></table></figure><ol start="3"><li>将三个文件打成一个py.tar包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf py.tar 01.py 02.py 03.py</span><br><span class="line">ls -l</span><br><span class="line">ls -lh</span><br></pre></td></tr></table></figure><ol start="4"><li>新建tar目录，将py.tar移动到tar目录下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir tar</span><br><span class="line">mv py.tar tar</span><br><span class="line">tree</span><br><span class="line">cd tar</span><br></pre></td></tr></table></figure><ol start="5"><li>解包py.tar</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf py.tar</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-10</title>
      <link href="/2019/11/02/Python-Linux-10/"/>
      <url>/2019/11/02/Python-Linux-10/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统信息相关命令"><a href="#Linux系统信息相关命令" class="headerlink" title="Linux系统信息相关命令"></a>Linux系统信息相关命令</h1><ul><li>本节内容主要是为了方便通过远程终端维护服务器时，查看服务器系统日期时间/磁盘空间占用情况/程序执行情况</li><li>本节学习的终端命令基本都是查询命令，通过这些命令对了解系统资源的适用情况</li></ul><a id="more"></a><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>时间和日期<ul><li>date</li><li>cal</li></ul></li><li>磁盘和目录空间<ul><li>df</li><li>du</li></ul></li><li>进程信息<ul><li>ps</li><li>top</li><li>kill</li></ul></li></ul><h2 id="01-时间和日期"><a href="#01-时间和日期" class="headerlink" title="01.时间和日期"></a>01.时间和日期</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>date</td><td>查看系统时间</td></tr><tr><td>02</td><td>cal</td><td>calendar查看日历，-y选项可以查看一年的日历</td></tr></tbody></table><h2 id="02-磁盘信息"><a href="#02-磁盘信息" class="headerlink" title="02.磁盘信息"></a>02.磁盘信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td>disk free显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td>disk usage显示目录下文件大小</td></tr></tbody></table><ul><li>选项说明</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>以人性化的方式显示文件大小</td></tr></tbody></table><h2 id="03-进程信息"><a href="#03-进程信息" class="headerlink" title="03.进程信息"></a>03.进程信息</h2><ul><li>所谓进程，就是当前正在执行的一个程序</li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td>process status查看进程的详细状况</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的进程并且排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>杀掉指定代号的进程，-9表示6力执行</td></tr></tbody></table><blockquote><p>ps默认只会显示当前用户通过终端启动的应用程序</p></blockquote><ul><li>ps选项说明功能</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示在终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><blockquote><p>提示：使用kill命令，最好只终止当前用户的进程，不终止root身份的进程，否则可能系统崩溃</p><p>kill命令是在某进程占用内存或cpu占用比较高的时候杀掉程序，也可以在重启Linux服务的时候杀掉进程</p><ul><li>要退出top可以直接输入q</li></ul></blockquote><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul><li>查找文件<ul><li>find</li></ul></li><li>软连接<ul><li>ln</li></ul></li><li>打包和压缩<ul><li>tar</li></ul></li><li>软件安装<ul><li>apt-get</li></ul></li></ul><h3 id="01-查找文件"><a href="#01-查找文件" class="headerlink" title="01.查找文件"></a>01.查找文件</h3><ul><li>find命令功能非常厉害，通常用来在特定的目录下搜索符合条件的文件</li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>find [路径] -name “*.py”</td><td>查找指定路径下扩展名是.py的文件，包括子目录</td></tr></tbody></table><ul><li>如果省略路径，表示在当前文件夹查找</li><li>之前学习的通配符，在使用find命令时可使用</li></ul><h4 id="演练目标"><a href="#演练目标" class="headerlink" title="演练目标"></a>演练目标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">搜索桌面目录下，文件名包含1的文件</span><br><span class="line">find Desktop/ -name &quot;*1*&quot;</span><br><span class="line">搜索桌面目录下，所有以.txt为扩展名的文件</span><br><span class="line">find -name &quot;*.txt&quot;</span><br><span class="line">搜索桌面目录下，以数字1开头的文件</span><br><span class="line">find -name &quot;1*&quot;</span><br></pre></td></tr></table></figure><h3 id="02-软连接"><a href="#02-软连接" class="headerlink" title="02.软连接"></a>02.软连接</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ln -s 被链接的源文件<br>链接文件</td><td>建立文件的软连接，用通俗的方式讲，类似于Windows的快捷方式</td></tr></tbody></table><ul><li>注意</li><li>1.没有-s选项建立的是一个硬链接文件<ul><li>两个文件占用相同的磁盘空间，工作中几乎不会建立文件的硬链接</li></ul></li><li>2.源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</li></ul><h4 id="演练目标-1"><a href="#演练目标-1" class="headerlink" title="演练目标"></a>演练目标</h4><ul><li>1.将桌面目录下的01.py移动到demo/b/c目录</li><li>2.在桌面目录下新建01.py的软连接FirstPython<ul><li>分别使用相对路径和绝对路径建立FirstPython的软连接</li></ul></li><li>3.将FirstPython移动到demo目录下，对比使用相对路径和绝对路径的区别</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-09</title>
      <link href="/2019/11/02/Python-Linux-09/"/>
      <url>/2019/11/02/Python-Linux-09/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux其它命令"><a href="#Linux其它命令" class="headerlink" title="Linux其它命令"></a>Linux其它命令</h1><a id="more"></a><h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><ul><li>usermod可以用来设置用户的主组/附加组和登录Shell，命令格式如下：</li><li>主组：通常在新建用户时指定，在etc/passwd的第4列GID对应的组</li><li>附加组：在etc/group中最后一列表示该组的用户列表，用于指定用户的附加权限</li></ul><blockquote><p>提示：设置了用户的附加组之后，需要重新登录才能生效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修改用户的主组（passwd中的GID）</span><br><span class="line">usermod -g 组 用户名</span><br><span class="line">修改用户的附加组</span><br><span class="line">usermod -G 组 用户名</span><br><span class="line">修改用户登录的Shell</span><br><span class="line">usermod -s /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>注意：默认使用useradd添加的用户是没有权限使用sudo以root身份执行命令的，可以使用以下命令，将用户添加到sudo附加组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure><h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><blockquote><p>提示：</p><ul><li>/etc/passwd是用于保存用户信息的文件</li><li>/usr/bin/passwd是用于修改用户密码的程序</li></ul></blockquote><ul><li>which命令可以查看执行的命令所在的位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">which ls</span><br><span class="line">/bin/ls</span><br><span class="line">which useradd</span><br><span class="line">/usr/sbin/useradd</span><br></pre></td></tr></table></figure><h2 id="bin和sbin"><a href="#bin和sbin" class="headerlink" title="bin和sbin"></a>bin和sbin</h2><ul><li>在Linux，绝大多数可执行文件都是保存在/bin,/sbin,/usr/bin,/usr/sbin</li><li>/bin(binary)是二进制执行文件目录，主要用于具体应用</li><li>/sbin(system binary)是系统管理员专用的二进制代码存放目录，主要用于系统管理</li><li>/usr/bin(user commadns for applications)后期安装的一些软件</li><li>/usr/sbin(super user commadns for applications)超级用户的一些管理程序</li></ul><blockquote><p>提示</p><ul><li>cd这个终端命令是内置正在系统内核的，没有独立的文件，因此用which无法找cd的位置</li></ul></blockquote><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>su - 用户名</td><td>切换用户，并且切换目录</td><td>-可以切换到用户家目录，否则保持位置不变</td></tr><tr><td>02</td><td>exit</td><td>退出当前登录账户</td></tr></tbody></table><ul><li>su - 不接用户名，可以切换到root，但是不推荐使用，因为不安全</li><li>exit示意图如下</li></ul><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572575218274.png" alt="1572575218274"></p><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>chown</td><td>修改拥有者</td></tr><tr><td>02</td><td>chgrp</td><td>修改组</td></tr><tr><td>03</td><td>chmod</td><td>修改权限</td></tr></tbody></table><ul><li>命令格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改文件|目录的拥有者</span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line">递归修改文件|目录的组</span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line">递归修改文件权限</span><br><span class="line">chmod -R 755 文件名|目录名</span><br><span class="line">//第一个数组表示拥有者权限，第二个数字表示组权限，第三个数字表示其他用户权限，分别到标着各自权限所代表数字的和</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572576391931.png" alt="1572576391931"></p><ul><li>chmod 在设置权限时，可以简单地使用三个数字分别对应拥有者/组合其他用户的权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接修改文件|目录的读|写|执行权限，但是不能精确到拥有者|组|其他</span><br><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><ul><li>常见数字组合（u表示用户/g表示组/o表示其他）：<ul><li>777===&gt;u=rwx,g=rwx,o=rwx</li><li>755===&gt;u=rwx,g=rx,o=rx</li><li>644===&gt;u=rw,g=r,o=r</li></ul></li></ul><h2 id="chmod演练目标"><a href="#chmod演练目标" class="headerlink" title="chmod演练目标"></a>chmod演练目标</h2><ol><li><p>将01.py的权限修改为u=rwx,g=rx,o=r</p><p>chmod 754 01.py</p></li><li><p>将123.txt的权限修改为u=rw,g=r,o=-</p><p>chmod 640 123.txt</p></li><li><p>将test目录以及目录下的所有文件权限修改为u=rwx,g=rwx,o=rx</p><p>chmod -R 775 test</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-08</title>
      <link href="/2019/10/31/Python-Linux-08/"/>
      <url>/2019/10/31/Python-Linux-08/</url>
      
        <content type="html"><![CDATA[<h2 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h2><a id="more"></a><ul><li>Linux系统的root账号通常用于系统的维护和管理，对操作系统的所有资源具有访问权限</li><li>在大多数版本的Linux，都不推荐直接使用root账号</li><li>标准用户是指只能在自己的家目录下执行命令的用户，在Linux安装，系统会自动创建一个用户账号，而这个默认的用户就是标准用户</li></ul><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><ul><li>su是substitute user的缩写，表示使用另一个用户的身份</li><li>sudo命令用来以其他身份来执行命令，预设的身份为root</li><li>用户使用sudo，必须输入密码，之后有5的有效期限权限，超过期限必须重新输入密码</li></ul><blockquote><p>若未经授权的用户企图使用sudo，则会发警告邮件给管理员</p></blockquote><h2 id="组管理终端命令"><a href="#组管理终端命令" class="headerlink" title="组管理终端命令"></a>组管理终端命令</h2><blockquote><p>提示：创建组/删除组的终端命令都需要通过sudo执行</p></blockquote><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>groupadd</td><td>添加组</td></tr><tr><td>02</td><td>groupdel组名</td><td>删除组</td></tr><tr><td>03</td><td>cat /etc/group</td><td>确认组信息</td></tr><tr><td>04</td><td>chgrp -R 组名 文件/目录名</td><td>修改文件/目录的所属值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupadd dev执行这个命令会告诉我们权限不够，无法锁定/etc/group</span><br><span class="line"></span><br><span class="line">sudo groupadd dev 要求写密码，然后就可以新建成功组了,可以查看/etc/group看看这个dev组，cat /etc/group</span><br><span class="line"></span><br><span class="line">groupdel dev 无权限</span><br><span class="line"></span><br><span class="line">sudo groupdel dev 可删除组</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p><ul><li>组信息保存在/etc/group文件中</li><li>/etc目录是专门用来保存系统配置信息的目录</li></ul></blockquote><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572486914737.png" alt="1572486914737"></p><ul><li>在实际使用，可以预先对组设置好权限，然后将不同的用户添加到组，而不用为用户单独设置权限</li></ul><h3 id="演练目标"><a href="#演练目标" class="headerlink" title="演练目标"></a>演练目标</h3><ul><li>在python用户的桌面文件夹创建python学习目录</li></ul><p>切换到python用户的桌面文件夹</p><p>mkdir Python学习</p><ul><li>新建dev组</li></ul><p>sudo groupadd dev</p><p>cat /etc/group</p><ul><li>将Python学习目录的组修改为dev</li></ul><p>chgrp -R dev Python学习/ 不允许执行这个命令</p><p>sudo chgrp -R dev Python学习/ 这就可以修改Python学习这个目录的组了</p><h2 id="用户管理终端命令"><a href="#用户管理终端命令" class="headerlink" title="用户管理终端命令"></a>用户管理终端命令</h2><blockquote><p>提示：创建用户/删除用户/修改其他用户密码的终端命令都需要通过sudo执行</p></blockquote><h3 id="1-创建用户-设置密码-删除用户"><a href="#1-创建用户-设置密码-删除用户" class="headerlink" title="1.创建用户/设置密码/删除用户"></a>1.创建用户/设置密码/删除用户</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>useradd -m -g组新建用户名</td><td>添加新用户</td><td>-m 自动建立用户家目录<br>-g指定用户所在组，否则会建立一个和同名的组</td></tr><tr><td>02</td><td>passwd 用户名</td><td>设置用户密码</td><td>如果是普通用户，直接passwd可以修改自己的账户密码</td></tr><tr><td>03</td><td>userdel -r 用户名</td><td>删除用户</td><td>-r 选项会自动删除用户家目录</td></tr><tr><td>04</td><td>cat/etc/passwd\</td><td>grep用户名</td><td>确认用户信息</td><td>新建用户后，用户信息会保存在/etc/passwd文件</td></tr></tbody></table><p>sudo useradd -m -g dev zhangsan 写密码后回车，则home文件夹就会多一个zhangsan用户的家目录文件夹</p><p>验证：ls -l /home可以看到zhangsan目录的文件拥有者是zhangsan用户,所属组为dev</p><p>需要指定密码</p><p>sudo passwd zhangsan 设置密码即可</p><blockquote><p>提示：</p><ul><li>创建用户时，如果忘记添加-m选项指定新用户的家目录——最简单的方法就是删除用户，重新创建</li><li>创建用户时，默认会创建一个和用户名同名的组名</li><li>用户信息保存在/etc/passwd文件</li></ul></blockquote><h3 id="2-查看用户信息"><a href="#2-查看用户信息" class="headerlink" title="2.查看用户信息"></a>2.查看用户信息</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>id [用户名]</td><td>查看用户UID和GID信息</td></tr><tr><td>02</td><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>03</td><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table><p>passwd文件</p><p>/etc/passwd文件存放的是用户的信息，由6个分好组成的7个信息，分别是</p><ol><li>用户名</li><li>密码（x，表示加密的密码）</li><li>UID（用户标识）</li><li>GID（组标识）</li><li>用户全名或本地账号</li><li>家目录</li><li>登录使用的Shell,就是登录之后，使用的终端命令，ubuntu默认是dash</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-07</title>
      <link href="/2019/10/31/Python-Linux-07/"/>
      <url>/2019/10/31/Python-Linux-07/</url>
      
        <content type="html"><![CDATA[<h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><a id="more"></a><p>配置别名可以让我们偷懒，比如将ssh -p port user@remote用：ssh mac来代替</p><p>则在~/.ssh/config追加如下内容,如果没有config文件，则新建一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host mac</span><br><span class="line">HostName ip地址</span><br><span class="line">User itheima</span><br><span class="line">Port 22</span><br></pre></td></tr></table></figure><p>保存之后就可以用ssh mac 实现远程登录了，scp同样可以使用</p><h2 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>用户和权限的基本概念</li><li>用户管理终端命令</li><li>组管理终端命令</li><li>修改权限终端命令</li></ul><h3 id="01-用户和权限的基本概念"><a href="#01-用户和权限的基本概念" class="headerlink" title="01.用户和权限的基本概念"></a>01.用户和权限的基本概念</h3><h4 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h4><ul><li>用户是Linux系统工作中重要的一环，用户管理包括用户与组管理</li><li>在Linux系统，不管是由本机或者是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的权限</li><li>在Linux，可以指定每一个用户，针对不同的文件或者目录的不同权限</li><li>对文件/目录的权限包括</li></ul><table><thead><tr><th>序号</th><th>权限</th><th>英文</th><th>缩写</th><th>数字代号</th></tr></thead><tbody><tr><td>01</td><td>读</td><td>read</td><td>r</td><td>4</td></tr><tr><td>02</td><td>写</td><td>write</td><td>w</td><td>2</td></tr><tr><td>03</td><td>执行</td><td>excute</td><td>x</td><td>1</td></tr></tbody></table><h4 id="1-2组"><a href="#1-2组" class="headerlink" title="1.2组"></a>1.2组</h4><ul><li>为了方便用户管理，提出了组的概念，如下图所示</li></ul><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572483299456.png" alt="1572483299456"></p><ul><li>在实际应用，可以预先针对组设置好权限，然后将不同的用户添加到对应的组，而不用为每一个用户设置权限</li></ul><h4 id="1-3ls-l扩展"><a href="#1-3ls-l扩展" class="headerlink" title="1.3ls -l扩展"></a>1.3ls -l扩展</h4><ul><li>ls -l可以查看文件夹下文件的详细信息，从左到右依次是<ul><li>权限，第一个字符如果是d表示目录</li><li>硬链接数，通俗的讲，就是有多少种方式，可以访问到当前目录/文件</li><li>拥有者，家目录下的文件/目录的拥有者通常都是当前用户</li><li>组，在Linux，很多时候会出现组名和用户名相同的情况</li><li>大小</li><li>时间</li><li>名称</li></ul></li></ul><p>rwxrwxrwx，第一组代表文件和目录的拥有者的权限</p><p>​            第二组代表文件或目录所存在组的权限</p><p>​            第三组代表既不是文件拥有者也不是目录所在组的其他用户所拥有的权限</p><h4 id="1-4简单使用"><a href="#1-4简单使用" class="headerlink" title="1.4简单使用"></a>1.4简单使用</h4><p>ls -l 先查看文件权限</p><p>chmod -rw 01.py 把01.py的读写权限删了</p><p>chmod +r 01.py 给01.py加读权限</p><p>chmod +x 01.py 给01.py加执行权限</p><ul><li>chmod修改用户/组对文件/目录的权限</li><li>命令格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><blockquote><p>提示：以上方式会一次性修改拥有者/组的权限</p></blockquote><p>执行文件的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./文件名</span><br></pre></td></tr></table></figure><p>新建测试文件夹test</p><p>ls -l 检测权限，默认拥有者可读可写可执行，组也是可读可写可执行，其他用户只有可读可执行</p><p>在测试文件夹建01.py</p><p>chmod -x test 即可去掉test的可执行权限,则目录不能查看</p><p>chmod -rw test 去掉test的读写权限,不能ls</p><p>若加上r权限，则ls可用，但不能新建文件</p><p>r就是目录的可读权限</p><p>w就是目录的可写权限</p><p>x在目录中就是执行终端命令的权限，如果没有x权限，则cd命令都不能用</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-06</title>
      <link href="/2019/10/29/Python-Linux-06/"/>
      <url>/2019/10/29/Python-Linux-06/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="SSH客户端的简单实用"><a href="#SSH客户端的简单实用" class="headerlink" title="SSH客户端的简单实用"></a>SSH客户端的简单实用</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-p port] user@remote</span><br></pre></td></tr></table></figure><ul><li>user是在远程机器上的用户名，如果不指定的话默认为当前用户</li><li>remote是远程机器的地址，可以是IP/域名，或者是后面会提到的别名</li><li>port是SSH Server监听的端口，如果不指定，就为默认值22</li></ul><blockquote><p>提示：</p><p>使用exit退出当前用户的登录</p><p>注意：</p><ul><li>ssh这个终端命令只能在Linux或者UNIX系统下使用</li><li>如果在Windows系统中，可以安装PuTTY或者XShell客户端软件即可</li></ul><p>提示：</p><ul><li>在工作中，SSH服务器的端口号很有可能不是22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器。</li></ul></blockquote><p>sudo shutdown -r now 超级用户权限执行关机/重启计算机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows下SSH客户端的安装</span><br><span class="line">Putty:http://www.chiark.greenend.org.uk/~sgtatham/putty/lastest.html</span><br><span class="line">XShell:http://xshellcn.com</span><br></pre></td></tr></table></figure><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><ul><li>scp就是secure copy，是一个在Linux下用来进行远程拷贝文件的命令</li><li>它的地址格式与ssh基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的</li></ul><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572314018564.png" alt="1572314018564"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">把本地当前目录下的01.py文件复制到远程家目录下的Desktop/01.py</span><br><span class="line">注意：“：”的路径如果不是绝对路径，则以用户的家目录为参照目录</span><br><span class="line">scp -P port 01.py user@remote:Desktop/01/py</span><br><span class="line">把远程家目录下的Desktop/01/py文件复制到本地当前目录下的01.py</span><br><span class="line">scp -P port user@remote:Desktop/01.py 01.py</span><br><span class="line"></span><br><span class="line">加上 -r 选项可以传送文件夹</span><br><span class="line">把当前目录下的demo文件夹复制到远程家目录下的Desktop</span><br><span class="line">scp -r demo user@remote:Desktop</span><br><span class="line">把远程家目录下的Desktop复制到当前目录下的demo文件夹</span><br><span class="line">scp -r user@remote:Desktop demo</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>若给出的源文件是目录文件，则scp<br>将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr><tr><td>-P</td><td>若远程SSH服务器的端口不是22，需要使用大写字母-P选项指定端口</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">scp这个终端命令只能在Linux或者UNIX系统下使用</span><br><span class="line">如果在Windows系统，可以安装PuTTY，使用pscp命令行工具或者安装FileZilla使用FTP传输文件</span><br></pre></td></tr></table></figure><p>FileZilla</p><ul><li>官方网站：<a href="https://www.filezilla.cn/download/client" target="_blank" rel="noopener">https://www.filezilla.cn/download/client</a></li><li>FileZilla在传输文件时，使用的是FTP（端口号21）服务</li></ul><h2 id="SSH高级"><a href="#SSH高级" class="headerlink" title="SSH高级"></a>SSH高级</h2><ul><li>免密码登录</li><li>配置别名</li></ul><blockquote><p>提示：有关SSH配置信息都保存在用户家目录的.ssh目录下</p></blockquote><p>1）免密码登录</p><ul><li>配置公钥<ul><li>执行ssh-keygen即可生成SSH钥匙，回车即可</li></ul></li><li>上传公钥到服务器<ul><li>执行ssh-copy-id -p port user@remote,可以让亚UN成服务器记住我们的公钥</li></ul></li></ul><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572316573336.png" alt="1572316573336"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非对称加密算法</span><br><span class="line">使用公钥加密的数据，需要使用私钥解密</span><br><span class="line">使用私钥加密的数据，需要使用公钥解密</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-05</title>
      <link href="/2019/10/29/Python-Linux-05/"/>
      <url>/2019/10/29/Python-Linux-05/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux其他命令"><a href="#Linux其他命令" class="headerlink" title="Linux其他命令"></a>Linux其他命令</h1><a id="more"></a><h2 id="1-echo"><a href="#1-echo" class="headerlink" title="1.echo"></a>1.echo</h2><ul><li>echo会在终端中显示参数指定的文字，通常会重定向联合使用</li><li>echo Hello Python &gt; a</li><li>echo命令在创建文件的同时就能指定文件内容</li></ul><h2 id="2-重定向-gt-和-gt-gt"><a href="#2-重定向-gt-和-gt-gt" class="headerlink" title="2.重定向&gt;和&gt;&gt;"></a>2.重定向&gt;和&gt;&gt;</h2><ul><li>Linux允许将命令执行结果重定向到一个文件</li><li>将本应显示在终端上的内容输出/追加到指定文件中</li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- ```&gt;&gt;```表示追加，会将内容追加到已有文件的末尾</span><br><span class="line"></span><br><span class="line">## 3.管道</span><br><span class="line"></span><br><span class="line">- Linux允许将一个命令的输出可以通过管道作为另一个命令的输入</span><br><span class="line">- 可以理解现实生活中的管子，管子的一头放东西，另一头取，这里 | 的左右分为两端，左端写东西，右端读东西</span><br><span class="line"></span><br><span class="line">常用的管道命令有：</span><br><span class="line"></span><br><span class="line">- more:分屏显示内容</span><br><span class="line">- grep:在命令执行结果的基础上查询指定文本</span><br><span class="line"></span><br><span class="line">&gt; ls -lha ~ | grep Do //列表文件名包含Do的文件</span><br><span class="line">&gt;</span><br><span class="line">&gt; ifconfig | grep inet</span><br><span class="line"></span><br><span class="line">## 4.远程管理常用命令</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">- 关机/重启</span><br><span class="line">  - shutdown</span><br><span class="line">- 查看或配置网卡信息</span><br><span class="line">  - ifconfig</span><br><span class="line">  - ping</span><br><span class="line">- 远程登录和赋值文件</span><br><span class="line">  - ssh</span><br><span class="line">  - scp</span><br><span class="line"></span><br><span class="line">### 01.关机/重启</span><br><span class="line"></span><br><span class="line">| 序号 | 命令               | 对应英文 | 作用          |</span><br><span class="line">| ---- | ------------------ | -------- | ------------- |</span><br><span class="line">| 01   | shutdown 选项 时间 | shutdown | 关机/重新启动 |</span><br><span class="line"></span><br><span class="line">#### 1.1shutdown</span><br><span class="line"></span><br><span class="line">- shutdown命令可以安全关闭或者重新启动系统</span><br><span class="line"></span><br><span class="line">| 选项 | 含义     |</span><br><span class="line">| ---- | -------- |</span><br><span class="line">| -r   | 重新启动 |</span><br><span class="line"></span><br><span class="line">&gt; 提示</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 不指定选项和参数，默认表示1分钟之后关闭电脑</span><br><span class="line">&gt; - 远程维护服务器时，最好不要关闭系统，而应该重新启动系统</span><br><span class="line"></span><br><span class="line">- 常用命令示例</span><br></pre></td></tr></table></figure></li></ul><p>#重新启动操作系统，其中now表示现在<br>shutdown -r now</p><p>#立刻关机，其中now表示现在<br>shutdown now</p><p>#系统在今天的时候关机<br>shutdown 20:25</p><p>#系统在过十分钟后关机<br>shutdown +10、</p><p>#取消之前指定的关机计划<br>shutdown -c<br><code>`</code></p><h3 id="02-查看或配置网卡信息"><a href="#02-查看或配置网卡信息" class="headerlink" title="02.查看或配置网卡信息"></a>02.查看或配置网卡信息</h3><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ifconfig</td><td>configure a network interface</td><td>查看/配置计算机当前的网卡配置信息</td></tr><tr><td>02</td><td>ping ip地址</td><td>ping</td><td>检测到目标ip地址的连接是否正常</td></tr></tbody></table><h4 id="2-1网卡和IP地址"><a href="#2-1网卡和IP地址" class="headerlink" title="2.1网卡和IP地址"></a>2.1网卡和IP地址</h4><p>网卡</p><ul><li>网卡是一个专门负责网络通讯的硬件设备</li><li>IP地址是设置在往卡上的地址信息</li></ul><blockquote><p>我们可以把电脑比作电话，网卡相当于SIM卡，IP地址相当于电话号码</p></blockquote><p>IP地址</p><ul><li>每台联网的电脑上都有IP地址，是保证电脑之间正常通讯的重要设置</li></ul><blockquote><p>注意：每台电脑的IP地址不能相同，否则会出现IP地址冲突，并且没有办法正常通讯</p></blockquote><h4 id="2-2ifconfig"><a href="#2-2ifconfig" class="headerlink" title="2.2ifconfig"></a>2.2ifconfig</h4><ul><li>ifconfig可以查看/配置计算机当前的网卡配置信息</li></ul><blockquote><p>//查看网卡配置信息</p><p>ifconfig</p><p>//查看网卡对应的IP地址</p><p>ifconfig | grep init</p></blockquote><blockquote><p>提示：一台计算机中可能会有一个物理网卡和多个虚拟网卡，在Linux中物理网卡的名字通常以ensXX表示</p></blockquote><ul><li>127.0.0.1被称为本地回环/环回地址，一般用来测试本机网卡是否正常</li></ul><h4 id="2-3-ping"><a href="#2-3-ping" class="headerlink" title="2.3 ping"></a>2.3 ping</h4><blockquote><p>//检测到目标主机是否连接正常</p><p>ping IP地址</p><p>//检测本地网卡工作正常</p><p>ping 127.0.0.1</p></blockquote><ul><li>ping一般用于检测当前计算机到目标计算机之间的网络是否通畅，数值越大，速度越慢</li></ul><blockquote><ul><li>ping的工作原理与潜水艇的声呐相似，ping这个命令就是取自声呐的声音</li><li>网络管理员之间也将ping作为动词——ping一下计算机X，看是否开机</li></ul></blockquote><p>原理：网络上的机器都有唯一确定的IP地址，我们给目标IP地址发送一个数据包，对方就要返回一个数据包，根据返回的数据报以及时间，我们可以确定目标主机的存在。</p><blockquote><p>提示：在Linux，想要终止一个终端程序的执行，大多数使用ctrl+c</p></blockquote><h3 id="03远程登录和复制文件"><a href="#03远程登录和复制文件" class="headerlink" title="03远程登录和复制文件"></a>03远程登录和复制文件</h3><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ssh用户名@ip</td><td>secure shell</td><td>关机/重新启动</td></tr><tr><td>02</td><td>scp用户名@ip：文件名或路径 用户名@ip：文件名或路径</td><td>secure copy</td><td>远程复制文件</td></tr></tbody></table><h4 id="3-1ssh基础（重点）"><a href="#3-1ssh基础（重点）" class="headerlink" title="3.1ssh基础（重点）"></a>3.1ssh基础（重点）</h4><p>在Linux中SSH是非常常用的工具，通过SSH客户端我们可以连接到运行了SSH服务器的远程机器上</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572233393471.png" alt="1572233393471"></p><ul><li>SSH客户端是一种使用Secure Shell(SSH)协议连接到远程计算机的软件程序</li><li>SSH是目前较可靠，专为远程登录会话和其他网络服务 提供安全性的协议<ul><li>利用SSH协议可以有效防止远程管理过程中的信息泄露</li><li>通过SSH协议可以对所有传输的数据加密，也能防止DNS欺骗和IP欺骗</li></ul></li><li>SSH的另一项优点是传输的数据可以经过压缩。提高数据传输效率</li></ul><h5 id="1-域名和端口号"><a href="#1-域名和端口号" class="headerlink" title="1)域名和端口号"></a>1)域名和端口号</h5><p>域名</p><ul><li>由一串用点分隔的名字组成，例如：<a href="http://www.itcast.cn" target="_blank" rel="noopener">www.itcast.cn</a></li><li>是IP地址的别名，方便用户记忆</li></ul><p>端口号</p><ul><li>IP地址：提高端口号可以找到网络上的计算机</li><li>端口号：通过端口号可以找到计算机上运行的应用程序<ul><li>SSH服务器的默认端口号是22，如果是默认端口号，在连接的时候，可以省略</li></ul></li><li>常见服务端口号列表：</li></ul><table><thead><tr><th>序号</th><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>01</td><td>SSH服务器</td><td>22</td></tr><tr><td>02</td><td>Web服务器</td><td>80</td></tr><tr><td>03</td><td>HTTPS</td><td>443</td></tr><tr><td>04</td><td>FTP服务器</td><td>21</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-04</title>
      <link href="/2019/10/27/Python-Linux-04/"/>
      <url>/2019/10/27/Python-Linux-04/</url>
      
        <content type="html"><![CDATA[<h1 id="拷贝和移动文件"><a href="#拷贝和移动文件" class="headerlink" title="拷贝和移动文件"></a>拷贝和移动文件</h1><a id="more"></a><p>##tree</p><p>tree命令可以以树状图的方式展示文件的目录结构</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>只显示目录</td></tr></tbody></table><p>##cp</p><p>cp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr><tr><td>-r</td><td>若给出的源文件是目录文件，则cp<br>将递归复制该目录下的所有子目录和文件，目标文件必须一个目录名</td></tr></tbody></table><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>mv命令可以用来移动文件或目录，也可以给文件或目录重命名</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr></tbody></table><h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cat文件名</td><td>concatenate</td><td>查看文件内容、创建文件、文件合并、追加文件内容等功能</td></tr><tr><td>02</td><td>more文件名</td><td>more</td><td>分屏显示文件内容</td></tr><tr><td>03</td><td>grep搜索文本文件名</td><td>grep</td><td>搜索文本文件内容</td></tr></tbody></table><p>##cat</p><p>cat 命令可以用来查看文件内容、创建文件、文件合并、追加文件内容等功能</p><p>cat会一次显示所有内容，适合内容较少的文本文件</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>对非空输出行编号</td></tr><tr><td>-n</td><td>对输出的所有行编号</td></tr></tbody></table><blockquote><p>Linux中还有一个nl的命令和cat -b 的效果等价</p></blockquote><p>##more</p><ul><li>more命令可以用于分屏显示文件内容，每次只显示一页内容</li><li>适合于查看内容较多的文本文件</li></ul><p>使用more的操作键：</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>/word</td><td>搜索word字符串</td></tr></tbody></table><p>##grep</p><ul><li>Linux系统中grep命令是一种文本搜索工具</li><li>grep允许对文本文件进行模式查找，所谓模式查找，又称为正则表达式</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><ul><li>常用的两种模式查找</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首，搜寻以a开头的行</td></tr><tr><td>ke$</td><td>行尾，搜寻以ke结尾的行</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Linux-03</title>
      <link href="/2019/10/27/Python-Linux-03/"/>
      <url>/2019/10/27/Python-Linux-03/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux查看目录内容"><a href="#Linux查看目录内容" class="headerlink" title="Linux查看目录内容"></a>Linux查看目录内容</h1><a id="more"></a><p>##终端实用技巧</p><p>###自动补全</p><ul><li>在敲出文件/目录/命令的前几个字母之后，按下tab键<ul><li>如果输入没有歧义，系统会自动补全</li><li>如果还存在其他文件/目录/命令，再按一下tab键，系统会提示可能存在的命令</li></ul></li></ul><p>###曾经使用过的命令</p><ul><li>按 上/下 光标键可以在曾经使用过的命令之间来回切换</li><li>如果想要瑞出选择，并且不想执行当前选中的命令，可以按ctrl+c</li></ul><p>##ls命令说明</p><ul><li>ls是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于DOS命令下的dir命令</li></ul><p><strong>Linux下文件和目录的特点</strong></p><ul><li>Linux文件或目录可拥有256个字符</li><li>以.开头的文件为隐藏文件，需要用-a参数来显示</li><li>. 代表当前目录</li><li>.. 代表上一级目录</li></ul><p>###ls常用选项</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合-l以人性化的方式显示文件大小</td></tr></tbody></table><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1572053758292.png" alt="1572053758292"></p><p>文件夹对应第一列的小写字母d，文件对应第一列的-</p><p>-h选项不能单独使用，智能和-l选项一起使用 ls -l -h</p><p>##通配符的使用</p><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意个数字符 ls 1<em>(找到1开头的字符) ls </em>1.txt(找到以1结尾的txt文件，不加txt加 * 代表存在3的所有字符)</td></tr><tr><td>？</td><td>代表任意1个字符，至少1个</td></tr><tr><td>[]</td><td>表示可以匹配字符组的任意一个</td></tr><tr><td>[abc]</td><td>匹配a、b、c的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从a到f范围内的任意一个字符</td></tr></tbody></table><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><ul><li>cd 是英文单词change directory的简写，其功能未更改当前的工作目录，也是用户最常用的命令之一</li></ul><blockquote><p>Linux所有的目录和文件名都是区分大小写的</p></blockquote><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主目录{/home/用户目录}</td></tr><tr><td>cd ~</td><td>切换到当前用户的主目录{/home/用户目录}</td></tr><tr><td>cd .</td><td>保持在当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><ul><li>相对路径：在输入路径时，最前面不是/或者~，表示相对当前目录所在的目录位置<ul><li>cd ../</li></ul></li><li>绝对路径：在输入路径时，最前面是/或者~，表示从根目录/家目录开始的具体目录位置<ul><li>cd /home/python/Destop</li></ul></li></ul><p>##创建和删除</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><ul><li>创建文件或修改文件时间<ul><li>如果文件不存在，可以创建一个空白文件</li><li>如果文件已经存在，可以修改文件的修改时间</li></ul></li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><ul><li>创建一个新的目录</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>可以递归创建目录</td></tr></tbody></table><p>Linux的文件和目录不可用重名</p><p>###rm</p><ul><li>删除文件或目录</li></ul><blockquote><p>使用rm删除后是不能恢复的</p></blockquote><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>直接删除，忽略不存在的文件,无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，删除文件夹时必须加此参数</td></tr></tbody></table><p>rm命令可以和通配符一起用</p><p>##拷贝和移动文件</p><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td></tr><tr><td>02</td><td>cp 源文件 目标文件</td><td>copy</td><td>复制文件或者目录</td></tr><tr><td>03</td><td>mv 源文件 目标文件</td><td>move</td><td>移动文件或者目录/文件或者目录重命名</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_Linux-02</title>
      <link href="/2019/10/24/Python-Linux-02/"/>
      <url>/2019/10/24/Python-Linux-02/</url>
      
        <content type="html"><![CDATA[<h1 id="常用Linux命令的基本使用"><a href="#常用Linux命令的基本使用" class="headerlink" title="常用Linux命令的基本使用"></a>常用Linux命令的基本使用</h1><a id="more"></a><h2 id="学习Linux终端命令的原因"><a href="#学习Linux终端命令的原因" class="headerlink" title="学习Linux终端命令的原因"></a>学习Linux终端命令的原因</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux刚面世时并没有图形界面，所有操作全靠命令完成，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等</span><br><span class="line">在职场中，大量的服务器维护工作都是在远程通过ssh客户端来完成的，并没有图形界面，多有的维护工作都需要通过命令来完成</span><br><span class="line">在职场中，作为后端程序员，必须要或多或少的掌握一些Linux常用的终端命</span><br><span class="line">Linux发行版本的命令大概有200多个，但是常用的命令只有10多个而已</span><br></pre></td></tr></table></figure><ul><li>学习终端命令的技巧<ul><li>不需要死记硬背，对于常用命令，用的多了，自然就记住了</li><li>不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以</li></ul></li></ul><h2 id="常用Linux命令的基本使用-1"><a href="#常用Linux命令的基本使用-1" class="headerlink" title="常用Linux命令的基本使用"></a>常用Linux命令的基本使用</h2><p>tip:ctrl+shift+=放大终端窗口的字体显示</p><p>ctrl+-缩小终端字体</p><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>02</td><td>pwd</td><td>print work directory</td><td>查看当前所在文件夹</td></tr><tr><td>03</td><td>cd [目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>04</td><td>touch [文件名]</td><td>touch</td><td>如果文件不存在，新建文件</td></tr><tr><td>05</td><td>mkdir [目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>06</td><td>rm [文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>07</td><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><p>删除文件夹 rm -r [文件夹名]</p><h2 id="Linux终端命令格式"><a href="#Linux终端命令格式" class="headerlink" title="Linux终端命令格式"></a>Linux终端命令格式</h2><p>command [-options] [parameter]</p><p>command : 命令名，相应功能的英文单词或单词的缩写</p><p>[option] : 选项，可用来对命令进行控制，也可以省略</p><p>parameter : 传给命令参数，可以是零个、一个或者多个</p><p>[] : 代表可选</p><h2 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h2><ul><li>tip:<ul><li>现阶段只需要知道通过以下两种方式可以查询命令的帮助信息</li><li>先学习常用命令及常用选项的使用即可，工作中遇到问题可以借助网络搜索</li></ul></li></ul><ol><li><p>–help</p><p>command –help</p><p>显示command命令的帮助信息</p></li><li><p>man</p><p>man command</p><p>查阅commmand命令的使用手册</p><p>| 操作键  | 功能                 |<br>| ——- | ——————– |<br>| 空格键  | 显示手册页的下一屏   |<br>| Enter键 | 一次滚动手册页的一行 |<br>| b       | 回滚一屏             |<br>| f       | 前滚一屏             |<br>| q       | 退出                 |<br>| /word   | 搜索word字符串       |</p></li></ol><h2 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><hr><ul><li><p>查看目录内容</p><ul><li>ls</li></ul></li><li><p>切换目录</p><ul><li>cd</li></ul></li><li><p>创建和删除操作</p><ul><li>touch</li><li>rm</li><li>mkdir</li></ul></li><li><p>拷贝和移动文件</p><ul><li>cp</li><li>mv</li></ul></li><li><p>参考文件内容</p><ul><li>cat</li><li>more</li><li>grep</li></ul></li><li><p>其他</p><ul><li><p>echo</p></li><li><p>重定向&gt;和&gt;&gt;</p></li><li><p>管道|</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_Linux-01</title>
      <link href="/2019/10/24/Python-Linux-01/"/>
      <url>/2019/10/24/Python-Linux-01/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>特殊的软件</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 直接操作硬件</span><br><span class="line">&gt;</span><br><span class="line">&gt; 把操作硬件的代码封装成系统调用，供其他应用程序通过系统调用操作硬件</span><br></pre></td></tr></table></figure><p>没有安装操作系统的计算机，通常称之为裸机<br>如果想在裸机运行自己编写的程序，就必须用机器语言书写程序<br>如果计算机安装了操作系统就可以在操作系统安装支持的高级语言环境，用高级语言开发程序`<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![1571790582554](C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1571790582554.png)</span><br></pre></td></tr></table></figure></p><p>没有操作系统的电脑听歌<br>将歌曲文件从硬盘加载到内存<br>使用声卡对音频数据进行解码<br>将解码后的数据发送给音箱<br><code>`</code></p><h2 id="不同应用领域的主流操作系统"><a href="#不同应用领域的主流操作系统" class="headerlink" title="不同应用领域的主流操作系统"></a>不同应用领域的主流操作系统</h2><p>桌面操作系统 Windows(用户群体大) macOS(适合于开发人员) Linux(应用软件少)</p><p>服务器操作系统 linux(安全、稳定、免费，占有率高)  Windows Server(付费，占有率低)</p><p>服务器就是一台电脑，装在机房，提供稳定带宽，方便访问</p><p>安装在电脑的操作系统</p><p>嵌入式操作系统(linux 内核小，可定制，人工智能python)</p><p>移动设备操作系统(IOS Android——基于linux)</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p><p>虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能</p><p>进入虚拟系统后，所有操作系统都是在这个全新的独立的虚拟系统，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响</p><p>而且能够在现有的系统与虚拟镜像之间灵活切换的一类操作系统</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1571793036539.png" alt="1571793036539"></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Linux内核及发行版"><a href="#Linux内核及发行版" class="headerlink" title="Linux内核及发行版"></a>Linux内核及发行版</h3><h4 id="Linux内核版本"><a href="#Linux内核版本" class="headerlink" title="Linux内核版本"></a>Linux内核版本</h4><p>内核是系统的心脏，是运行程序和管理硬件设备的核心程序，它提供了一个在逻辑与应用程序之间的抽象层。</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1571795933978.png" alt="1571795933978"></p><p>Linux内核版本氛围稳定版与开发板，两种版本是相互关联，相互循环</p><p>稳定版：工业级，可以广泛地应用和部署，新的稳定本相对于较旧的知识修正一些bug或加入一些新的驱动程序</p><p>开发板：由于要试验各种解决方案，所以变化很快。</p><h3 id="Linux文件和目录结构"><a href="#Linux文件和目录结构" class="headerlink" title="Linux文件和目录结构"></a>Linux文件和目录结构</h3><h4 id="单用户操作系统和多用户操作系统"><a href="#单用户操作系统和多用户操作系统" class="headerlink" title="单用户操作系统和多用户操作系统"></a>单用户操作系统和多用户操作系统</h4><p>单用户操作系统：指一台计算机在同一时间智能由一个用户使用，一个用户肚子想用系统的全部硬件和软件资源</p><p>Windows XP之前的版本都是单用户操作系统</p><p>多用户操作系统：指一台计算机在同一时间可以由多个 用户使用，多个用户共同想用系统的全部硬件和软件资源</p><p>Unix和Linux的设计初衷就是多用户操作系统</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1571801537310.png" alt="1571801537310"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例拓展</title>
      <link href="/2019/08/21/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%8B%93%E5%B1%95/"/>
      <url>/2019/08/21/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.输出域覆盖法</p><p>2.输入域覆盖法</p><p>3.异常分析法</p><p>4.错误猜测法</p><p>5.自动贩卖机功能测试</p><p>6.相关测试例子</p></blockquote><a id="more"></a><h2 id="输出域覆盖法"><a href="#输出域覆盖法" class="headerlink" title="输出域覆盖法"></a>输出域覆盖法</h2><p>需求界面当中可见参数存在有效和无效规则校验，但没有明确限制输入条件，而需求中</p><p>给出了输出的限定条件，而我们要根据业务由输出倒退输入，此时可以使用输出域覆盖法设计测试用例。 </p><p>1.询问开发或根据代码找出所有的输出结果</p><p>2.检查写过的测试用例是否把所有输出结果覆盖到，如果有未覆盖到用例则补测试用例</p><p>3.根据输出结果倒推测试用例步骤及测试数据</p><p>输出域覆盖法能保证所有输出结果是都被覆盖到，要求必须对业务要熟悉。</p><h2 id="输入域覆盖法"><a href="#输入域覆盖法" class="headerlink" title="输入域覆盖法"></a>输入域覆盖法</h2><p>输入域分析是一种综合的方法，综合了等价类划分法、边界值分析法等方法。这里说的输入域就是指输入，针对输入会有各种各样的输入值：</p><p>a.特殊值：主要和输入的特点有关，需要了解系统对该输入的存储和处理。</p><p>b.长时间输入：对于那些没有限制输入长度的输入进行长时间的持续输入，以查看是否会存在输入的数据内存越界导致系统故障的情况。</p><p>1.根据SRS找出输入的类型边界和特殊值</p><p>2.根据类型边界值和特殊值找到相应的类型边界值和特殊值并写出相应的测试用例</p><p>输入域覆盖法考虑的更加全面，但是输入不一定存在类型边界或特殊值</p><h2 id="异常分析法"><a href="#异常分析法" class="headerlink" title="异常分析法"></a>异常分析法</h2><p>异常分析就是针对系统有可能存在的异常操作、软硬件缺陷引起的故障进行分析，依此设计测试用例。</p><p>主要针对系统的容错能力、故障恢复能力进行测试。简单的说就是人为让系统出故障，然后检查系统的故障恢复能力。</p><p>另一方面，针对系统的异常测试（是否做了不应该做的事）也要通过异常分析等手段。</p><p><strong>应用：</strong></p><p>（1）针对系统罗列可能的故障</p><p>​        例如：断电；断网；数据损坏；内存错误；</p><p>（2）针对每种可能的故障设计测试用例</p><p>使用步骤： </p><p>1.构造各种可能出现的环境异常</p><p>2.做好手工备份/恢复</p><p>3.一个用例包含一个错误</p><p>优点：增加软件的可靠性</p><p>缺点：异常场景不容易构造，需要多方配合</p><h2 id="错误猜测法"><a href="#错误猜测法" class="headerlink" title="错误猜测法"></a>错误猜测法</h2><p>在软件测试活动中，人们可以依靠经验和直觉推测系统中可能存在的各种错误，从而有针对性地编写检查这些错误的例子，这就是错误推测法。</p><p>​        基本思想：根据以往的测试经验和对系统内部知识的了解，列出系统中各种可能有的错误和容易发生错误的特殊情况，再根据它们来设计测试用例，随着在产品测试的实践中对产品的了解的加深和测试经验的丰富，使用错误推测法设计的测试用例往往非常有效，可以作为测试设计的一种补充手段，并且积累的经验越丰富，方法使用效率越高。</p><p><strong>应用：</strong></p><p>（1）确定合适的错误推测清单</p><p>（2）确定需要进行错误猜测的测试子项</p><p>（3）根据清单对测试子项的规格进行错误猜测</p><h2 id="自动贩卖机功能测试"><a href="#自动贩卖机功能测试" class="headerlink" title="自动贩卖机功能测试"></a>自动贩卖机功能测试</h2><p>若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币；橙汁与啤酒均为5角钱一瓶。</p><p>自动贩卖机功能测试</p><p>Step1、如果需求是文字描述，将文字转化为图形</p><p>Step2、需求中包含1个独立功能 —— 贩卖功能</p><p>Step3、针对打印功能开展需求分析</p><p>​             界面可见输入参数：橙汁、啤酒、投币</p><p>​             界面不可见输入参数： 电量、货源</p><p>Step4、分析界面可见输入参数之间的关系及特点</p><p>l等价类 ——不存在无效规则（点橙汁是对的，不点是错的？）</p><p>l边界值 —— 不存在区间范围</p><p>l判定表 —— 参数之间存在逻辑关系√，不同组合输出不同结果√</p><p>​                        不存在一个是什么另外一个必须是什么</p><p>l正交试验 —— 不全是有效的，存在无效（投币存在无效）</p><p>l流程分析法 —— 不跨界面</p><p>l状态迁移图 —— 不全是有效的，存在无效× </p><p>​                              参数之间存在约束关系（点橙汁不能点啤酒）√</p><p>参数之间存在逻辑关系，不同逻辑组合会输出不同结果</p><p>参数之间存在约束关系，输出结果不确定</p><p>​                                 —— 因果图</p><p>因果符号：</p><p>恒等、非、或、与</p><p>原因符号：</p><p>异、或、唯一、要求</p><p>结果符号：强制</p><p><strong>因果关系</strong></p><p>恒等：条件C满足要求时，一定会输出结果E</p><p>​     例如：投5毛点橙汁，一定会输出橙汁</p><p>非：条件C满足要求时，一定不会输出结果E</p><p>​     例如：投5毛点橙汁，一定不会输出啤酒</p><p>或：条件C1、C2、C3任何一项满足要求时，就会输出结果E</p><p>​     例如：测试管理工具QC、禅道、Jira中会使用任何一款工具即会被录用</p><p>与：条件C1、C2、C3同时满足要求时，才会输出结果E</p><p>​     例如：同时会使用禅道、SVN、selenium三款工具才会被录用</p><p><strong>原因与原因之间的关系</strong></p><p>异：原因a、b中只能有一个为真（只有2个条件）</p><p>​     例如：两支笔（签字笔、白板笔）中有且只有一支是白板笔</p><p>或：原因a、b中至少有一个为真（a为真，b也可以为真）</p><p>​     例如：两支笔（白板笔）中至少有一支是白板笔</p><p>唯一：在多组判定条件中，有且只有一个为真（多个条件）</p><p>​     例如：在多人的间谍游戏中，有且只有一个是间谍</p><p>要求：原因a满足条件时，原因b一定满足条件</p><p>​     例如：面试穿正装（约束，共同努力完成一件事情）</p><p><strong>结果与结果之间的关系</strong></p><p>强制：结果a出现时，结果b一定不出现</p><p>​     例如：橙汁出现时，啤酒一定不出现</p><h2 id="相关测试例子"><a href="#相关测试例子" class="headerlink" title="相关测试例子"></a>相关测试例子</h2><blockquote><p>某软件规格说明书包含这样的要求：</p><p>第一列字符必须是A或B，第二列字符必须是一个数字，</p><p>在此情况下进行文件的修改，</p><p>但如果第一列字符不正确，则给出信息L；</p><p>如果第二列字符不是数字，则给出信息M。</p><p>某软件规格说明书包含这样的要求：</p><p>第一列字符必须是A或B，第二列字符必须是一个数字，</p><p>在此情况下进行文件的修改，</p><p>但如果第一列字符不正确，则给出信息L；</p><p>如果第二列字符不是数字，则给出信息M。</p></blockquote><blockquote><p>以中国象棋中马的走法为例子，具体说明：</p><p>1、如果落点在棋盘外，则不移动棋子；</p><p>2、如果落点与起点不构成日字型，则不移动棋子；</p><p>3、如果落点处有自己方棋子，则不移动棋子；</p><p>4、如果在落点方向的邻近交叉点有棋子（绊马腿），则不移动棋子；</p><p>5、如果不属于1-4条，且落点处无棋子，则移动棋子；</p><p>6、如果不属于1-4条，且落点处为对方棋子 (非老将) ，则移动棋子并除去对方棋子；</p><p>7、如果不属于1-4条，且落点处为对方老将，则移动棋子，并提示战胜对方，游戏结束。</p><p>案例分析因果图</p><p>根据程序规格说明书描述的语义内容，分析并确定“因”和“果”；</p><p>原因：</p><p>1、  落点在棋盘外；</p><p>2、  不构成日字；</p><p>3、  落点有自方棋子；</p><p>4、  绊马腿；</p><p>5、  落点无棋子；</p><p>6、  落点为对方棋子；</p><p>7、  落点为对方老将。</p><p>结果：</p><p>21、 不移动；</p><p>22、移动；</p><p>23、移动己方棋子消除对方棋子；</p><p>24、  移动并战胜对方。</p></blockquote><p><strong>因果图</strong></p><p>优点： </p><p>1.充分考虑了输入条件之间的组合，对组合情况覆盖充分。</p><p>2.最终每个用例覆盖多种输入情况，有利于提高测试效率。</p><p>3.设计过程中，对输入条件间的约束关系做了考虑，避免了无效用例，用例的有效性高。</p><p>4.能够同时得出每个测试项目的预期输出</p><p>缺点：</p><p>1.当被测试特性输入较多时，判定表的规模会非常大。</p><p>2.输入之间的约束条件不能有效区分输入是否确实需要进行组合测试，会造成不需要组合测试的输入做了组合，从而产生用例冗余。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例总结02</title>
      <link href="/2019/08/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%80%BB%E7%BB%9302/"/>
      <url>/2019/08/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%80%BB%E7%BB%9302/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.因果图方法</p><p>2.判定表驱动分析方法</p><p>3.正交试验设计方法</p><p>4.功能图分析方法</p><p>5.场景设计方法</p><p>6.测试用例设计综合策略</p></blockquote><a id="more"></a><p>###因果图方法</p><p>一.方法简介</p><ol><li><p>定义：是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p></li><li><p>因果图法产生的背景：</p></li></ol><p>等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。</p><p>如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。</p><ol start="3"><li>因果图介绍</li></ol><p>1) 4种符号分别表示了规格说明中向4种因果关系。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>2) 因果图中使用了简单的逻辑符号，以直线联接左右结点。左结点表示输入状态（或称原因），右结点表示输出状态（或称结果）。 </p><p>3) Ci表示原因，通常置于图的左部；ei表示结果，通常在图的右部。Ci和ei均可取值0或1，0表示某状态不出现，1表示某状态出现。 </p><ol start="4"><li>因果图概念</li></ol><p>1)    关系</p><p>①恒等：若ci是1，则ei也是1；否则ei为0。</p><p>②非：若ci是1，则ei是0；否则ei是1。</p><p>③或：若c1或c2或c3是1，则ei是1；否则ei为0。“或”可有任意个输入。</p><p>④与：若c1和c2都是1，则ei为1；否则ei为0。“与”也可有任意个输入。</p><p>2)    约束</p><p>输入状态相互之间还可能存在某些依赖关系，称为约束。例如, 某些输入条件本身不可能同时出现。输出状态之间也往往存在约束。在因果图中,用特定的符号标明这些约束。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg" alt="img"></p><p>A.输入条件的约束有以下4类：</p><p>   ① E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。</p><p>   ② I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。</p><p>   ③ O约束（唯一）；a和b必须有一个，且仅有1个为1。</p><p>   ④R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。</p><p>B.输出条件约束类型</p><p>   输出条件的约束只有M约束（强制）：若结果a是1，则结果b强制为0。</p><ol start="5"><li>采用因果图法设计测试用例的步骤：</li></ol><p>1)分析软件规格说明描述中, 那些是原因(即输入条件或输入条件的等价类),那些是结果(即输出条件), 并给每个原因和结果赋予一个标识符。</p><p>2)分析软件规格说明描述中的语义，找出原因与结果之间, 原因与原因之间对应的关系，根据这些关系,画出因果图。</p><p>3)由于语法或环境限制, 有些原因与原因之间,原因与结果之间的组合情况不可能出现，为表明这些特殊情况, 在因果图上用一些记号表明约束或限制条件。</p><p>4)把因果图转换为判定表。</p><p>5)把判定表的每一列拿出来作为依据,设计测试用例。</p><p>二.实战演习</p><ol><li>某软件规格说明书包含这样的要求：第一列字符必须是A或B，第二列字符必须是一个数字，在此情况下进行文件的修改，但如果第一列字符不正确，则给出信息L；如果第二列字符不是数字，则给出信息M。</li></ol><p>解答：</p><p>1) 根据题意，原因和结果如下：</p><p>​       原因：</p><p>​          1——第一列字符是A；</p><p>​          2——第一列字符是B；</p><p>​          3——第二列字符是一数字。</p><p>​       结果：</p><p>​          21——修改文件；</p><p>​          22 ——给出信息L；</p><p>​          23——给出信息M。</p><p>2) 其对应的因果图如下：</p><p>11为中间节点；考虑到原因1和原因2不可能同时为1，因此在因果图上施加E约束。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><p>3)根据因果图建立判定表。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg" alt="img"> </p><p>​       表中8种情况的左面两列情况中，原因①和原因②同时为1，这是不可能出现的，故应排除这两种情况。表的最下一栏给出了6种情况的测试用例，这是我们所需要的数据。 </p><p>2.有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。</p><p>1) 分析这一段说明，列出原因和结果</p><p>原因：</p><p>1.售货机有零钱找</p><p>2.投入1元硬币</p><p>3.投入5角硬币 </p><p>4.押下橙汁按钮</p><p>5.押下啤酒按钮 </p><p>结果： </p><p>21.售货机〖零钱找完〗灯亮    </p><p>22.退还1元硬币</p><p>23.退还5角硬币              </p><p>24.送出橙汁饮料</p><p>25.送出啤酒饮料</p><p>2)画出因果图，如图所示。所有原因结点列在左边，所有结果结点列在右边。建立中间结点，表示处理的中间状态。中间结点：</p><ol start="11"><li><p>投入1元硬币且押下饮料按钮</p></li><li><p>押下〖橙汁〗或〖啤酒〗的按钮</p></li><li><p>应当找5角零钱并且售货机有零钱找</p></li><li><p>钱已付清</p></li></ol><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></p><p>3)转换成判定表：</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg" alt="img"> </p><p>4) 在判定表中，阴影部分表示因违反约束条件的不可能出现的情况，删去。第16列与第32列因什么动作也没做，也删去。最后可根据剩下的16列作为确定测试用例的依据。</p><h3 id="判定表驱动分析方法"><a href="#判定表驱动分析方法" class="headerlink" title="判定表驱动分析方法"></a>判定表驱动分析方法</h3><p>一.    方法简介</p><p>1.定义：判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。</p><p>2.判定表的优点</p><p>能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用判定表能够设计出完整的测试用例集合。</p><p>在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表很适合于处理这类问题。</p><p>3.“阅读指南”判定表</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image009.jpg" alt="img"></p><ol start="4"><li>判定表通常由四个部分组成如下图所示。</li></ol><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></p><p>1)条件桩（Condition Stub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。</p><p>2)动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。</p><p>3)条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。</p><p>4)动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。</p><p>5.规则及规则合并</p><p>1)规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然,判定表中列出多少组条件取值,也就有多少条规则,既条件项和动作项有多少列。</p><p>2)化简：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。</p><p>6.规则及规则合并举例</p><p>1)如下图左端，两规则动作项一样，条件项类似，在1、2条件项分别取Y、N时，无论条件3取何值，都执行同一操作。即要执行的动作与条件3无关。于是可合并。“－”表示与取值无关。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image011.jpg" alt="img"></p><p>2)与上类似，下图中，无关条件项“－”可包含其他条件项取值，具有相同动作的规则可合并。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg" alt="img"></p><p>3)化简后的读书指南判定表</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th></th></tr></thead><tbody><tr><td><strong>问</strong>   <strong>题</strong></td><td><strong>你觉得疲倦吗？</strong></td><td>-</td><td>-</td><td>Y</td><td>N</td></tr><tr><td><strong>你对内容感兴趣吗？</strong></td><td>Y</td><td>Y</td><td>N</td><td>N</td><td></td></tr><tr><td><strong>书中内容使你胡涂吗？</strong></td><td>Y</td><td>N</td><td>-</td><td>-</td><td></td></tr><tr><td><strong>建</strong>   <strong>议</strong></td><td><strong>请回到本章开头重读</strong></td><td>x</td><td></td><td></td><td></td></tr><tr><td><strong>继续读下去</strong></td><td></td><td>X</td><td></td><td></td><td></td></tr><tr><td><strong>跳到下一章去读</strong></td><td></td><td></td><td></td><td>x</td><td></td></tr><tr><td><strong>停止阅读，请休息</strong></td><td></td><td></td><td>x</td><td></td></tr></tbody></table><p>7.判定表的建立步骤：（根据软件规格说明）</p><p>1)确定规则的个数.假如有n个条件。每个条件有两个取值（0,1）,故有2n种规则。</p><p>2)列出所有的条件桩和动作桩。</p><p>3)填入条件项。</p><p>4)填入动作项。等到初始判定表。</p><p>5)简化.合并相似规则（相同动作）。</p><p>二<strong>.</strong>实战演习</p><ol><li>问题要求：”……对功率大于50马力的机器、维修记录不全或已运行10年以上的机器，应给予优先的维修处理……” 。这里假定，“维修记录不全”和“优先维修处理”均已在别处有更严格的定义 。请建立判定表。</li></ol><p>解答：</p><p>①确定规则的个数：这里有3个条件，每个条件有两个取值，故应有2<em>2</em>2=8种规则。</p><p>②列出所有的条件茬和动作桩：</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image013.jpg" alt="img"></p><p>③填入条件项。可从最后1行条件项开始，逐行向上填满。如第三行是： Y N Y N Y N Y N，第二行是： Y Y N N Y Y N N等等。  </p><p>④填入动作桩和动作顶。这样便得到形如图的初始判定表。</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th></th></tr></thead><tbody><tr><td><strong>条</strong>   <strong>件</strong></td><td>功率大于50马力吗？</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td></tr><tr><td>维修记录不全吗？</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td></td></tr><tr><td>运行超过10年吗？</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td></td></tr><tr><td><strong>动</strong>   <strong>作</strong></td><td><strong>进行优先处理</strong></td><td>x</td><td>x</td><td>X</td><td></td><td>X</td><td></td><td>X</td><td></td></tr><tr><td><strong>作其他处理</strong></td><td></td><td></td><td></td><td>X</td><td></td><td>x</td><td></td><td>x</td></tr></tbody></table><p>初始判定表</p><p>⑤化简。合并相似规则后得到图。</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr></thead><tbody><tr><td><strong>条</strong>   <strong>件</strong></td><td><strong>功率大于50马力吗？</strong></td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td><strong>维修记录不全吗？</strong></td><td>Y</td><td>N</td><td>N</td><td>-</td><td>-</td><td></td></tr><tr><td>运行超过10年吗？</td><td>-</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td></td></tr><tr><td><strong>动</strong>   <strong>作</strong></td><td><strong>进行优先处理</strong></td><td>x</td><td>x</td><td></td><td>X</td><td></td></tr><tr><td><strong>作其他处理</strong></td><td></td><td></td><td>x</td><td></td><td>x</td></tr></tbody></table><ol start="2"><li>NextData函数的精简决策表</li></ol><p>M1＝{月份， 每月有30天}</p><p>M2＝{月份， 每月有31天}</p><p>M3＝{月份， 2月}                 有29＝512条规则</p><p>D1＝{日期，1～28}                 12月末31日和其它31</p><p>D2＝{日期，29}                    日月份的31日处理不同</p><p>D3＝{日期，30}                    平年2月28日处理不同</p><p>D4＝{日期，31}                    于2月27日</p><p>Y1 ＝{年：年是闰年}</p><p>Y2 ＝{年：年不是闰年}</p><p>改进为</p><p>M1＝{月份： 每月有30天}</p><p>M2＝{月份： 每月有31天， 12月除外}</p><p>M4＝{月份：12月}</p><p>M3＝{月份： 2月} </p><p>D1＝{日期：1&lt;=日期&lt;=27}</p><p>D2＝{日期：28}</p><p>D3＝{日期：29}</p><p>D4＝{日期：30}</p><p>D5＝{日期：31}</p><p>Y1 ＝{年：年是闰年}</p><p>Y2 ＝{年：年不是闰年}</p><p>输入变量间存在大量逻辑关系的NextData决策表</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image015.jpg" alt="img"></p><ol start="3"><li><p>用决策表测试法测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤month≤12和1≤day≤31），分别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。</p><p>例如，输入为2004年11月29日，则该程序的输出为2000年12月1日。</p></li></ol><p>1)分析各种输入情况，列出为输入变量month、day、year划分的有效等价类。</p><p>2)分析程序规格说明，结合以上等价类划分的情况给出问题规定的可能采取的操作（即列出所有的动作桩）。</p><p>3)根据（1）和（2），画出简化后的决策表。</p><p>案例分析如下：</p><p>1)      month变量的有效等价类：</p><p> M1: {month=4,6,9,11}            </p><p> M2: {month=1,3,5,7,8,10}</p><p>M3: {month=12}                 </p><p> M4: {month=2}</p><p>2)day变量的有效等价类：</p><p>​    D1:{1≤day≤26}         D2: {day=27}         D3: {day=28}                    D4: {day=29}                    D5: {day=30}                D6: {day=31}</p><p>3)year变量的有效等价类：</p><p>Y1: {year是闰年}                Y2:  {year不是闰年}</p><p>4)考虑各种有效的输入情况，程序中可能采取的操作有以下六种：</p><p>a1: day+2                       a2: day=2                    a3: day=1  </p><p>a4: month+1                     a5: month=1                  a6: year+1  </p><ol start="4"><li>判定表在功能测试中的应用</li></ol><p>1)一些软件的功能需求可用判定表表达得非常清楚，在检验程序的功能时判定表也就成为一个不错的工具。如果一个软件的规格说明指出：</p><p>I. 当条件1和条件2满足，并且条件3和条件4不满足，或者当条件1、3和条件4满足时，要执行操作1。</p><p>II. 在任一个条件都不满足时，要执行操作2。</p><p>III. 在条件1不满足，而条件4被满足时，要执行操作3。 根据规格说明得到如下判定表：</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image017.jpg" alt="img"></p><p>这里，判定表只给出了16种规则中的8种。事实上，除这8条以外的一些规则是指当不能满足指定的条件，执行3种操作时，要执行1个默许的操作。在没必要时，判定表通常可略去这些规则。但如果用判定表来设计测试用例，就必须列出这些默许规则（如下表）。</p><table><thead><tr><th></th><th>规则5</th><th>规则6</th><th>规则7</th><th>规则8</th></tr></thead><tbody><tr><td>条件1</td><td>-</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>条件2</td><td>-</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>条件3</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr><tr><td>条件4</td><td>N</td><td>N</td><td>Y</td><td>-</td></tr><tr><td>默许操作</td><td>x</td><td>x</td><td>x</td><td>x</td></tr></tbody></table><p>默许的规则</p><p>2)判定表的优点和缺点</p><p>I.  优点：它能把复杂的问题按各种可能的情况一一列举出来，简明而易于理解，也可避免遗漏。</p><p>II. 缺点：不能表达重复执行的动作，例如循环结构。</p><p>3)B. Beizer 指出了适合使用判定表设计测试用例的条件：</p><p>①规格说明以判定表形式给出,或很容易转换成判定表。</p><p>②条件的排列顺序不会也不影响执行哪些操作。</p><p>③规则的排列顺序不会也不影响执行哪些操作。</p><p>④每当某一规则的条件已经满足,并确定要执行的操作后,不必检验别的规则。</p><p>⑤如果某一规则得到满足要执行多个操作,这些操作的执行顺序无关紧要。</p><p>B. Beizer提出这5个必要条件的目的是为了使操作的执行完全依赖于条件的组合。其实对于某些不满足这几条的判定表，同样可以借以设计测试用例，只不过尚需增加其它的测试用例罢了。</p><h3 id="正交实验设计方法"><a href="#正交实验设计方法" class="headerlink" title="正交实验设计方法"></a>正交实验设计方法</h3><p>一.方法简介</p><p>利用因果图来设计测试用例时, 作为输入条件的原因与输出结果之间的因果关系,有时很难从软件需求规格说明中得到。往往因果关系非常庞大,以至于据此因果图而得到的测试用例数目多的惊人，给软件测试带来沉重的负担，为了有效地,合理地减少测试的工时与费用,可利用正交实验设计方法进行测试用例的设计。</p><p>正交实验设计方法:依据Galois理论,从大量的（实验）数据（测试例）中挑选适量的,有代表性的点（例）,从而合理地安排实验（测试）的一种科学实验设计方法.类似的方法有:聚类分析方法,因子方法方法等.</p><p>利用正交实验设计测试用例的步骤：</p><p>1.提取功能说明,构造因子–状态表</p><p>把影响实验指标的条件称为因子.而影响实验因子的条件叫因子的状态.利用正交实验设计方法来设计测试用例时,首先要根据被测试软件的规格说明书找出影响其功能实现的操作对象和外部因素,把他们当作因子,而把各个因子的取值当作状态.对软件需求规格说明中的功能要求进行划分,把整体的概要性的功能要求进行层层分解与展开,分解成具体的有相对独立性的基本的功能要求.这样就可以把被测试软件中所有的因子都确定下来,并为确定个因子的权值提供参考的依据.确定因子与状态是设计测试用例的关键.因此要求尽可能全面的正确的确定取值,以确保测试用例的设计作到完整与有效。</p><p>2.加权筛选,生成因素分析表</p><p>对因子与状态的选择可按其重要程度分别加权.可根据各个因子及状态的作用大小,出现频率的大小以及测试的需要,确定权值的大小。</p><p>3.利用正交表构造测试数据集</p><p>正交表的推导依据Galois理论（这里省略,需要时可查数理统计方面的教材）。</p><p>利用正交实验设计方法设计测试用例,比使用等价类划分,边界值分析,因果图等方法有以下优点:节省测试工作工时；可控制生成的测试用例数量；测试用例具有一定的覆盖率。</p><h3 id="功能图分析方法"><a href="#功能图分析方法" class="headerlink" title="功能图分析方法"></a>功能图分析方法</h3><p>一.方法简介</p><p>一个程序的功能说明通常由动态说明和静态说明组成.动态说明描述了输入数据的次序或转移的次序.静态说明描述了输入条件与输出条件之间的对应关系.对于较复杂的程序,由于存在大量的组合情况,因此,仅用静态说明组成的规格说明对于测试来说往往是不够的.必须用动态说明来补充功能说明.功能图方法是用功能图FD形式化地表示程序的功能说明,并机械地生成功能图的测试用例. 功能图模型由状态迁移图和逻辑功能模型构成.状态迁移图用于表示输入数据序列以及相应的输出数据.在状态迁移图中,由输入数据和当前状态决定输出数据和后续状态.逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系.逻辑功能模型只适合于描述静态说明,输出数据仅由输入数据决定.测试用例则是由测试中经过的一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成.功能图方法其实是是一种黑盒白盒混合用例设计方法。</p><p>（功能图方法中,要用到逻辑覆盖和路径测试的概念和方法,其属白盒测试方法中 的内容.逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法.该方法要求测试人员对程序的逻辑结构有清楚的了解.由于覆盖测试的目标不同,逻辑覆盖可分为:语句覆盖,判定覆盖,判定-条件覆盖,条件组合覆盖及路径覆盖.下面我们指的逻辑覆盖和路径是功能或系统水平上的,以区别与白盒测试中的程序内部的.）</p><p>1.功能图</p><p>功能图由状态迁移图和布尔函数组成.状态迁移图用状态和迁移来描述.一个状态指出数据输入的位置（或时间）,而迁移则指明状态的改变.同时要依靠判定表或因果图表示的逻辑功能.例,一个简化的自动出纳机ATM的功能图。</p><p>2.测试用例生成方法</p><p>从功能图生成测试用例,得到的测试用例数是可接受的. 问题的关键的是如何从状态迁移图中选取测试用例. 若用节点代替状态,用弧线代替迁移,则状态迁移图就可转化成一个程序的控制流程图形式.问题就转化为程序的路径测试问题（如白盒测试）问题了.</p><p>3.测试用例生成规则</p><p>为了把状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来,从功能图生成实用的测试用例,须定义下面的规则.在一个结构化的状态迁移（SST）中,定义三种形式的循环:顺序,选择和重复.但分辨一个状态迁移中的所有循环是有困难的.（其表示图形省略）。</p><p>4.从功能图生成测试用例的过程</p><p>1)生成局部测试用例:在每个状态中,从因果图生成局部测试用例.局部测试用例由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成。</p><p>2)测试路径生成:利用上面的规则（三种）生成从初始状态到最后状态的测试路径。</p><p>3)测试用例合成:合成测试路径与功能图中每个状态中的局部测试用例.结果是初始状态到最后状态的一个状态序列,以及每个状态中输入数据与对应输出数据的组合。</p><p>5.测试用例的合成算法:采用条件构造树.</p><h3 id="场景设计方法"><a href="#场景设计方法" class="headerlink" title="场景设计方法"></a>场景设计方法</h3><p>一.方法简介</p><p>现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。</p><p>基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）；也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入到某个流（如备选流2和4）。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image019.jpg" alt="img"></p><p>二.实战演习</p><ol><li>例子描述</li></ol><p>下图所示是ATM例子的流程示意图。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image021.jpg" alt="img"></p><ol start="2"><li>场景设计：下表所示是生成的场景。</li></ol><p>表3-8 场景设计</p><table><thead><tr><th>场景1——成功提款</th><th>基本流</th><th></th></tr></thead><tbody><tr><td>场景2——ATM内没有现金</td><td>基本流</td><td>备选流2</td></tr><tr><td>场景3——ATM内现金不足</td><td>基本流</td><td>备选流3</td></tr><tr><td>场景4——PIN有误（还有输入机会）</td><td>基本流</td><td>备选流4</td></tr><tr><td>场景5——PIN有误（不再有输入机会）</td><td>基本流</td><td>备选流4</td></tr><tr><td>场景6——账户不存在/账户类型有误</td><td>基本流</td><td>备选流5</td></tr><tr><td>场景7——账户余额不足</td><td>基本流</td><td>备选流6</td></tr></tbody></table><p>注：为方便起见，备选流3和6（场景3和7）内的循环以及循环组合未纳入上表。</p><ol start="3"><li>用例设计</li></ol><p>对于这7个场景中的每一个场景都需要确定测试用例。可以采用矩阵或决策表来确定和管理测试用例。下面显示了一种通用格式，其中各行代表各个测试用例，而各列则代表测试用例的信息。本示例中，对于每个测试用例，存在一个测试用例ID、条件（或说明）、测试用例中涉及的所有数据元素（作为输入或已经存在于数据库中）以及预期结果。</p><p>表3-9 测试用例表</p><p>​    </p><table><thead><tr><th>TC（测试用例）ID号</th><th>场景/条件</th><th>PIN</th><th>账号</th><th>输入（或选择）的金额</th><th>账面   金额</th><th>ATM内的金额</th><th>预期结果</th></tr></thead><tbody><tr><td>CW1</td><td>场景1：成功提款</td><td>V</td><td>V</td><td>V</td><td>V</td><td>V</td><td>成功提款</td></tr><tr><td>CW2</td><td>场景2：ATM内没有现金</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>提款选项不可用，用例结束</td></tr><tr><td>CW3</td><td>场景3：ATM内现金不足</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>警告消息，返回基本流步骤6，输入金额</td></tr><tr><td>CW4</td><td>场景4：PIN有误（还有不止一次输入机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，返回基本流步骤 4，输入 PIN</td></tr><tr><td>CW5</td><td>场景4：PIN有误（还有一次输入机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，返回基本流步骤 4，输入 PIN</td></tr><tr><td>CW6</td><td>场景4：PIN有误（不再有输入机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，卡予保留，用例结束</td></tr></tbody></table><ol start="4"><li>数据设计</li></ol><p>一旦确定了所有的测试用例，则应对这些用例进行复审和验证以确保其准确且适度，并取消多余或等效的测试用例。</p><p>测试用例一经认可，就可以确定实际数据值（在测试用例实施矩阵中）并且设定测试数据，如表3-10所示。</p><p>表3-10    测试用例表</p><table><thead><tr><th>TC（测试用例）ID号</th><th>场景/条件</th><th>PIN</th><th>账号</th><th>输入（或选择）的金额   （元）</th><th>账面    金额（元）</th><th>ATM内的金额（元）</th><th>预期结果</th></tr></thead><tbody><tr><td>CW1</td><td>场景1：成功提款</td><td>4987</td><td>809-498</td><td>50.00</td><td>500.00</td><td>2 000</td><td>成功提款。账户余额被更新为450.00</td></tr><tr><td>CW2</td><td>场景2：ATM内没有现金</td><td>4987</td><td>809-498</td><td>100.00</td><td>500.00</td><td>0.00</td><td>提款选项不可用，用例结束</td></tr><tr><td>CW3</td><td>场景3：ATM内现金不足</td><td>4987</td><td>809-498</td><td>100.00</td><td>500.00</td><td>70.00</td><td>警告消息，返回基本流步骤6，输入金额</td></tr><tr><td>CW4</td><td>场景4：PIN有误（还有不止一次输入机会）</td><td>4978</td><td>809-498</td><td>n/a</td><td>500.00</td><td>2 000</td><td>警告消息，返回基本流步骤4，输入PIN</td></tr><tr><td>CW5</td><td>场景4：PIN有误（还有一次输入机会）</td><td>4978</td><td>809-498</td><td>n/a</td><td>500.00</td><td>2 000</td><td>警告消息，返回基本流步骤4，输入PIN</td></tr><tr><td>CW6</td><td>场景4：PIN有误（不再有输入机会）</td><td>4978</td><td>809-498</td><td>n/a</td><td>500.00</td><td>2 000</td><td>警告消息，卡予保留，用例结束</td></tr></tbody></table><h3 id="测试用例设计综合策略"><a href="#测试用例设计综合策略" class="headerlink" title="测试用例设计综合策略"></a>测试用例设计综合策略</h3><ol><li>Myers提出了使用各种测试方法的综合策略：</li></ol><p>1)在任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强。 【文章来源：文斯测试技术研究中心 <a href="http://blog.csdn.net/vincetest" target="_blank" rel="noopener">http://blog.csdn.net/vincetest</a>】</p><p>2)必要时用等价类划分方法补充一些测试用例。</p><p>3)用错误推测法再追加一些测试用例。</p><p>4)对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，应当再补充足够的测试用例。</p><p>5)如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法。</p><ol start="2"><li>测试用例的设计步骤 【文章来源：文斯测试技术研究中心 <a href="http://blog.csdn.net/vincetest" target="_blank" rel="noopener">http://blog.csdn.net/vincetest</a>】</li></ol><p>1)构造根据设计规格得出的基本功能测试用例；</p><p>2)边界值测试用例；</p><p>3)状态转换测试用例；</p><p>4)错误猜测测试用例；</p><p>5)异常测试用例； 【文章来源：文斯测试技术研究中心 <a href="http://blog.csdn.net/vincetest" target="_blank" rel="noopener">http://blog.csdn.net/vincetest</a>】</p><p>6)性能测试用例；</p><p>7)压力测试用例。</p><ol start="3"><li>优化测试用例的方法</li></ol><p>1)利用设计测试用例的8种方法不断的对测试用例进行分解与合并；</p><p>2)采用遗传算法理论进化测试用例；</p><p>3)在测试时利用发散思维构造测试用例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例总结01</title>
      <link href="/2019/08/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%80%BB%E7%BB%9301/"/>
      <url>/2019/08/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%80%BB%E7%BB%9301/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.等价类划分方法</p><p>2.边界值分析方法</p><p>3.错误推测方法</p></blockquote><a id="more"></a><h3 id="等价类划分方法"><a href="#等价类划分方法" class="headerlink" title="等价类划分方法"></a>等价类划分方法</h3><p>一.方法简介</p><p>1.定义<br>   是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。该方法是一种重要的,常用的黑盒测试用例设计方法。</p><p>2.划分等价类：<br>   等价类是指某个输入域的子集合。在该子集合中,各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其它值的测试，因此,可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果。等价类划分可有两种不同的情况：有效等价类和无效等价类。<br>   1)有效等价类<br>     是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。<br>   2)无效等价类<br>     与有效等价类的定义恰巧相反。无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。<br>   设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。</p><p>3.划分等价类的标准：<br>   1)完备测试、避免冗余;<br>   2)划分等价类重要的是：集合的划分，划分为互不相交的一组子集，而子集的并是整个集合;<br>   3)并是整个集合：完备性;<br>   4)子集互不相交：保证一种形式的无冗余性;<br>   5)同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到”相同的执行路径”。</p><p>4.划分等价类的方法<br>   1)在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0～100；</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg" alt="img"></p><p>2)在输入条件规定了输入值的集合或者规定了”必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类；<br>   3)在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类。<br>   4)在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类。<br>     例：输入条件说明学历可为:专科、本科、硕士、博士四种之一，则分别取这四种这四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。<br>   5)在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；<br>   6)在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。</p><p> 5.设计测试用例<br>   在确立了等价类后,可建立等价类表,列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：<br>   1)为每一个等价类规定一个唯一的编号；<br>   2)设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；<br>   3)设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止。</p><p>二.实战演习 </p><p>1.某程序规定：”输入三个整数 a 、 b 、 c 分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型，当此三角形为一般三角形、等腰三角形及等边三角形时，分别作计算 … “。用等价类划分方法为该程序进行测试用例设计。（三角形问题的复杂之处在于输入与输出之间的关系比较复杂。）<br>   分析题目中给出和隐含的对输入条件的要求：<br>   （1）整数    （2）三个数    （3）非零数   （4）正数  </p><p>   （5）两边之和大于第三边     （6）等腰     （7）等边<br>    如果 a 、 b 、 c 满足条件（ 1 ） ~ （ 4 ），则输出下列四种情况之一：<br>    1)如果不满足条件（5），则程序输出为 “ 非三角形 “ 。<br>    2)如果三条边相等即满足条件（7），则程序输出为 “ 等边三角形 “ 。<br>    3)如果只有两条边相等、即满足条件（6），则程序输出为 “ 等腰三角形 “ 。<br>    4)如果三条边都不相等，则程序输出为 “ 一般三角形 “ 。<br>    列出等价类表并编号</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>覆盖有效等价类的测试用例：<br>     a      b      c              覆盖等价类号码<br>     3      4      5             （1）–（7）<br>     4      4      5             （1）–（7），（8）<br>     4      5      5             （1）–（7），（9）    </p><p>​     5      4      5             （1）–（7），（10）<br>​     4      4      4             （1）–（7），（11）<br>​    覆盖无效等价类的测试用例：</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg" alt="img"></p><p>2.设有一个档案管理系统，要求用户输入以年月表示的日期。假设日期限定在1990年1月~2049年12月，并规定日期由6位数字字符组成，前4位表示年，后2位表示月。现用等价类划分法设计测试用例，来测试程序的”日期检查功能”。<br>   1)划分等价类并编号,下表等价类划分的结果</p><table><thead><tr><th><strong>输入等价类</strong></th><th><strong>有效等价类</strong></th><th><strong>无效等价类</strong></th></tr></thead><tbody><tr><td>日期的类型及长度</td><td>①6位数字字符</td><td>②有非数字字符   ③少于6位数字字符   ④多于6位数字字符</td></tr><tr><td>年份范围</td><td>⑤在1990~2049之间</td><td>⑥小于1990   ⑦大于2049</td></tr><tr><td>月份范围</td><td>⑧在01~12之间</td><td>⑨等于00   ⑩大于12</td></tr></tbody></table><p>2)设计测试用例，以便覆盖所有的有效等价类在表中列出了3个有效等价类，编号分别为①、⑤、⑧，设计的测试用例如下：<br>     测试数据    期望结果      覆盖的有效等价类<br>     200211      输入有效      ①、⑤、⑧<br>   3)为每一个无效等价类设计一个测试用例，设计结果如下：<br>     测试数据   期望结果     覆盖的无效等价类<br>     95June     无效输入          ②<br>     20036      无效输入          ③<br>     2001006   无效输入          ④<br>     198912     无效输入          ⑥<br>     200401     无效输入          ⑦<br>     200100     无效输入          ⑨<br>     200113     无效输入          ⑩</p><p>3.NextDate 函数包含三个变量：month 、 day 和 year ，函数的输出为输入日期后一天的日期。 例如，输入为 2006年3月 7日，则函数的输出为 2006年3月8日 。要求输入变量 month 、 day 和 year 均为整数值，并且满足下列条件：<br>   ①1≤month≤12<br>   ②1≤day≤31<br>   ③1920≤year≤2050<br>   1)有效等价类为：<br>     M1＝{月份：1≤月份≤12}<br>     D1＝{日期：1≤日期≤31}<br>     Y1＝{年：1812≤年≤2012}<br>   2)若条件 ① ~ ③中任何一个条件失效，则 NextDate 函数都会产生一个输出，指明相应的变量超出取值范围，比如 “month 的值不在 1-12 范围当中 “ 。显然还存在着大量的 year 、 month 、 day 的无效组合， NextDate 函数将这些组合作统一的输出： “ 无效输入日期 “ 。其无效等价类为：<br>     M2＝{月份：月份&lt;1}<br>     M3＝{月份：月份&gt;12}<br>     D2＝{日期：日期&lt;1}<br>     D3＝{日期：日期&gt;31}<br>     Y2＝{年：年&lt;1812}<br>     Y3＝{年：年&gt;2012}<br>   弱一般等价类测试用例<br>   月份    日期       年               预期输出<br>    6       15        1912           1912年6月16日<br>   强一般等价类测试用例同弱一般等价类测试用例<br>   注：弱–有单缺陷假设；健壮–考虑了无效值<br>   (一)弱健壮等价类测试<br>   用例ID   月份  日期    年          预期输出<br>   WR1      6      15    1912      1912年6月16日<br>   WR2     -1     15    1912      月份不在1～12中<br>   WR3     13     15    1912      月份不在1～12中<br>   WR4      6      -1    1912      日期不在1～31中<br>   WR5      6      32    1912      日期不在1～31中<br>   WR6      6      15    1811      年份不在1812～2012中<br>   WR7      6      15    2013      年份不在1812～2012中</p><p>  (二)强健壮等价类测试<br>   用例ID   月份    日期      年          预期输出<br>   SR1       -1      15       1912      月份不在1～12中<br>   SR2        6      -1        1912      日期不在1～31中<br>   SR3        6      15       1811      年份不在1812～2012中<br>   SR4       -1      -1       1912      两个无效一个有效<br>   SR5        6      -1        1811      两个无效一个有效<br>   SR6       -1      15       1811      两个无效一个有效<br>   SR7       -1      -1       1811      三个无效</p><p>4.佣金问题等价类测试用例，它是根据佣金函数的输出值域定义等价类，来改进测试用例集合。<br> 输出销售额≤1000元     佣金10％<br> 1000&lt;销售额≤1800     佣金=100+(销售额-1000)<em>15%<br> 销售额&gt;1800              佣金=220+(销售额-1800)</em>20%<br> 测试用例         枪机(45)    枪托(30)      枪管(25)          销售额     佣金<br>     1               5             5                5                  500        50<br>     2              15           15              15                 1500       175<br>     3              25           25              25                 2500       360<br> 根据输出域选择输入值，使落在输出域等价类内，可以结合弱健壮测试用例结合。</p><h3 id="边界值分析方法"><a href="#边界值分析方法" class="headerlink" title="边界值分析方法"></a>边界值分析方法</h3><p>一.方法简介 </p><p>1.定义：边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。  </p><p>2.与等价划分的区别<br>   1)边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。<br>   2)边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。</p><p>3.边界值分析方法的考虑：<br>   长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。<br>   使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。 </p><p>4.常见的边界值<br>   1)对16-bit 的整数而言 32767 和 -32768 是边界<br>   2)屏幕上光标在最左上、最右下位置<br>   3)报表的第一行和最后一行<br>   4)数组元素的第一个和最后一个<br>   5)循环的第 0 次、第 1 次和倒数第 2 次、最后一次</p><p>5.边界值分析<br>   1)边界值分析使用与等价类划分法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。<br>     例：测试计算平方根的函数<br>         –输入：实数<br>         –输出：实数<br>         –规格说明：当输入一个0或比0大的数的时候，返回其正平方根；当输入一个小于0的数时，显示错误信息”平方根非法-输入值小于0”并返回0；库函数Print-Line可以用来输出错误信息。<br>   2)等价类划分：<br>     I.可以考虑作出如下划分：<br>       a、输入 (i)<0 和 (ii)>=0<br>       b、输出 (a)&gt;=0 和 (b) Error<br>     II.测试用例有两个：<br>       a、输入4，输出2。对应于 (ii) 和 (a) 。<br>       b、输入-10，输出0和错误提示。对应于 (i) 和 (b) 。</0></p><p>  3)边界值分析：<br>     划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0。由此得到以下测试用例：<br>     a、输入 {最小负实数}<br>     b、输入 {绝对值很小的负数}<br>     c、输入 0<br>     d、输入 {绝对值很小的正数}<br>     e、输入 {最大正实数}<br>   4)通常情况下，软件测试所包含的边界检验有几种类型：数字、字符、位置、重量、大小、速度、方位、尺寸、空间等。<br>   5)相应地，以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、  最短/最长、 空/满等情况下。<br>   6)利用边界值作为测试数据</p><table><thead><tr><th>项</th><th>边界值</th><th>测试用例的设计思路</th></tr></thead><tbody><tr><td>字符</td><td>起始-1个字符/结束+1个字符</td><td>假设一个文本输入区域允许输入1个到255个 字符，输入1个和255个字符作为有效等价类；输入0个和256个字符作为无效等价类，这几个数值都属于边界条件值。</td></tr><tr><td>数值</td><td>最小值-1/最大值+1</td><td>假设某软件的数据输入域要求输入5位的数据值，可以使用10000作为最小值、99999作为最大值；然后使用刚好小于5位和大于5位的 数值来作为边界条件。</td></tr><tr><td>空间</td><td>小于空余空间一点/大于满空间一点</td><td>例如在用U盘存储数据时，使用比剩余磁盘空间大一点（几KB）的文件作为边界条件。</td></tr></tbody></table><p>7)内部边界值分析：<br>     在多数情况下，边界值条件是基于应用程序的功能设计而需要考虑的因素，可以从软件的规格说明或常识中得到，也是最终用户可以很容易发现问题的。然而，在测试用例设计过程中，某些边界值条件是不需要呈现给用户的，或者说用户是很难注意到的，但同时确实属于检验范畴内的边界条件，称为内部边界值条件或子边界值条件。<br>     内部边界值条件主要有下面几种：<br>     a)数值的边界值检验：计算机是基于二进制进行工作的，因此，软件的任何数值运算都有一定的范围限制。</p><table><thead><tr><th>项</th><th>范围或值</th></tr></thead><tbody><tr><td>位（bit）</td><td>0或者1</td></tr><tr><td>字节（byte）</td><td>0——225</td></tr><tr><td>字（word）</td><td>0~65535（单字）或 0~4294967295（双字）</td></tr><tr><td>千（K）</td><td>1024</td></tr><tr><td>兆（M）</td><td>1048576</td></tr><tr><td>吉（G）</td><td>1073741824</td></tr></tbody></table><p>b)字符的边界值检验：在计算机软件中，字符也是很重要的表示元素，其中ASCII和Unicode是常见的编码方式。下表中列出了一些常用字符对应的ASCII码值。</p><table><thead><tr><th>字符</th><th><strong>ASCII**</strong>码值**</th><th>字符</th><th><strong>ASCII**</strong>码值**</th></tr></thead><tbody><tr><td>空 (null)</td><td>0</td><td>A</td><td>65</td></tr><tr><td>空格 (space)</td><td>32</td><td>a</td><td>97</td></tr><tr><td>斜杠 ( / )</td><td>47</td><td>Z</td><td>90</td></tr><tr><td>0</td><td>48</td><td>z</td><td>122</td></tr><tr><td>冒号 ( : )</td><td>58</td><td>单引号 ( ‘ )</td><td>96</td></tr><tr><td>@</td><td>64</td><td></td></tr></tbody></table><p>c)其它边界值检验</p><p>6.基于边界值分析方法选择测试用例的原则<br>   1)如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。<br>     例如，如果程序的规格说明中规定：”重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取10及50，还应取10.01,49.99,9.99及50.01等。<br>   2)如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一,比最大个数多一的数作为测试数据。<br>     比如，一个输入文件应包括1~255个记录，则测试用例可取1和255，还应取0及256等。<br>   3)将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。<br>     例如，某程序的规格说明要求计算出”每月保险金扣除额为0至1165.25元”，其测试用例可取0.00及1165.24、还可取一0.01及1165．26等。<br>     再如一程序属于情报检索系统，要求每次”最少显示1条、最多显示4条情报摘要”，这时我们应考虑的测试用例包括1和4，还应包括0和5等。<br>   4)如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例。<br>   5)如果程序中使用了一个内部数据结构,则应当选择这个内部数据结构的边界上的值作为测试用例。<br>   6)分析规格说明,找出其它可能的边界条件。</p><p>二.实战演习</p><p>1.现有一个学生标准化考试批阅试卷,产生成绩报告的程序。其规格说明如下:程序的输入文件由一些有80个字符的记录组成,如右图所示，所有记录分为3组：</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><p>①标题：这一组只有一个记录，其内容为输出成绩报告的名字。<br>   ②试卷各题标准答案记录：每个记录均在第80个字符处标以数字”2”。该组的第一个记录的第1至第3个字符为题目编号（取值为1一999）。第10至第59个字符给出第1至第50题的答案（每个合法字符表示一个答案）。该组的第2，第3……个记录相应为第51至第100，第101至第150，…题的答案。<br>   ③每个学生的答卷描述：该组中每个记录的第80个字符均为数字”3”。每个学生的答卷在若干个记录中给出。如甲的首记录第1至第9字符给出学生姓名及学号，第10至第59字符列出的是甲所做的第1至第50题的答案。若试题数超过50，则第2，第3……纪录分别给出他的第51至第100，第101至第150……题的解答。然后是学生乙的答卷记录。<br>   ④学生人数不超过200，试题数不超过999。<br>   ⑤程序的输出有4个报告：<br>     a)按学号排列的成绩单，列出每个学生的成绩、名次。<br>     b)按学生成绩排序的成绩单。<br>     c)平均分数及标准偏差的报告。<br>     d)试题分析报告。按试题号排序，列出各题学生答对的百分比。<br>   解答：分别考虑输入条件和输出条件，以及边界条件。给出下表所示的输入条件及相应的测试用例。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg" alt="img"></p><p>   输出条件及相应的测试用例表。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></p><p>2.三角形问题的边界值分析测试用例<br> 在三角形问题描述中，除了要求边长是整数外，没有给出其它的限制条件。在此，我们将三角形每边边长的取范围值设值为[1, 100] 。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg" alt="img"></p><p>3.NextDate函数的边界值分析测试用例<br> 在NextDate函数中，隐含规定了变量mouth和变量day的取值范围为1≤mouth≤12和1≤day≤31，并设定变量year的取值范围为1912≤year≤2050 。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img"></p><h3 id="错误推测方法"><a href="#错误推测方法" class="headerlink" title="错误推测方法"></a>错误推测方法</h3><p><strong>一.   </strong>方法简介</p><ol><li><p>定义：基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。</p></li><li><p>错误推测方法的基本思想：</p></li></ol><p>列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。</p><p>1)        例如, 输入数据和输出数据为0的情况；输入表格为空格或输入表格只有一行。 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。</p><p>2)        例如，前面例子中成绩报告的程序，采用错误推测法还可补充设计一些测试用例：</p><p>I.          程序是否把空格作为回答</p><p>II.       在回答记录中混有标准答案记录</p><p>III.     除了标题记录外，还有一些的记录最后一个字符即不是2也不是3</p><p>IV.     有两个学生的学号相同</p><p>V.        试题数是负数。 </p><p>3)    再如，测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：</p><p>I.          输入的线性表为空表；</p><p>II.       表中只含有一个元素；</p><p>III.     输入表中所有元素已排好序；</p><p>IV.     输入表已按逆序排好；</p><p>V.输入表中部分或全部元素相同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例05</title>
      <link href="/2019/08/17/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B05/"/>
      <url>/2019/08/17/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B05/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试——测试用例设计"><a href="#软件测试——测试用例设计" class="headerlink" title="软件测试——测试用例设计"></a>软件测试——测试用例设计</h1><blockquote><p>1.状态迁移</p><p>2.流程法</p></blockquote><a id="more"></a><h2 id="状态迁移"><a href="#状态迁移" class="headerlink" title="状态迁移"></a>状态迁移</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p>手机中MP3播放功能状态-事件表如下，并且当MP3曲目在起点时不能按R键，当MP3曲目在末端时不能按P、F键。</p></blockquote><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">停止</th><th style="text-align:center">倒</th><th style="text-align:center">播放</th><th style="text-align:center">进</th><th style="text-align:center">录音</th></tr></thead><tbody><tr><td style="text-align:center">R（倒）</td><td style="text-align:center">倒</td><td style="text-align:center">·</td><td style="text-align:center">倒</td><td style="text-align:center">倒</td><td style="text-align:center">·</td></tr><tr><td style="text-align:center">P（播放）</td><td style="text-align:center">播放</td><td style="text-align:center">播放</td><td style="text-align:center">·</td><td style="text-align:center">播</td><td style="text-align:center">·</td></tr><tr><td style="text-align:center">F（进）</td><td style="text-align:center">进</td><td style="text-align:center">进</td><td style="text-align:center">进</td><td style="text-align:center">·</td><td style="text-align:center">·</td></tr><tr><td style="text-align:center">RC（录音）</td><td style="text-align:center">录音</td><td style="text-align:center">·</td><td style="text-align:center">·</td><td style="text-align:center">·</td><td style="text-align:center">·</td></tr><tr><td style="text-align:center">S（停止）</td><td style="text-align:center">·</td><td style="text-align:center">停止</td><td style="text-align:center">停止</td><td style="text-align:center">停止</td><td style="text-align:center">停止</td></tr></tbody></table><blockquote><p>Step1、如果需求是文字描述，将文字转化为图形</p><p>Step2、需求中包含1个独立功能 —— 播放功能</p><p>Step3、针对打印功能开展需求分析</p><p>​             界面可见输入参数：   播放、停止、前进、倒退、录音          </p><p>​             界面不可见输入参数： 电量、音源</p><p>Step4、分析界面可见输入参数之间的关系及特点</p><p>​    界面所有参数都是有效的，不存在区间范围—X— 等价类、边界值</p><p>​    参数之间不存在一个是什么另外一个必须是什么 —X— 判定表</p><p>​    有效参数组合会输出不同结果，需求中参数部分可以组合，部分不可以组合，如前进与后退是互斥的  —X— 正交试验</p><p>​    不跨多个界面 —X— 流程分析法</p><p>​        所有参数都是有效的</p><p>​        参数之间存在约束条件（功能之间的约束、状态之间的约束）</p><p>​                                                —— 状态迁移图</p><p>Step5、利用状态迁移图设计测试用例</p><p>​    根据需求《SRS》提取所有的功能名或状态名</p><p>​    形成N*N业务矩阵</p><p>​    根据需求分析功能/状态的可达项可达用功能名/状态名代替、不可达用黑点表示</p><p>​    将业务矩阵转化为需求树深度优先画法、广度优先画法</p><p>​    一条分支为一条测试用例</p></blockquote><h3 id="深度优先画法"><a href="#深度优先画法" class="headerlink" title="深度优先画法"></a>深度优先画法</h3><ol><li><p>找一个功能名/状态名作为入口</p></li><li><p>根据业务矩阵从第一列开始竖着画，把可达项并列存放在入口的下一行</p></li><li><p>画可达项，从左边第一个功能画起，其他都注掉</p></li><li><p>一个功能只画一次，再出现就注掉，一直画到最后一个功能的可达项</p></li></ol><h3 id="状态迁移图的优缺点"><a href="#状态迁移图的优缺点" class="headerlink" title="状态迁移图的优缺点"></a>状态迁移图的优缺点</h3><p>优点：保证每一个功能/状态的可达项都被覆盖</p><p>缺点：对无效的路径无法覆盖</p><h2 id="场景测试方法"><a href="#场景测试方法" class="headerlink" title="场景测试方法"></a>场景测试方法</h2><p>​    我们申请一个项目，需先提交审批单据，再由部门经理审批，审核通过后由总经理来最终审批，如果部门经理审核不通过，就直接退回.</p><p>​    每个事件触发时的情景便形成了场景。而同一事件不同的触发顺序和处理结果形成事件流<strong>场景法：</strong>通过运用场景来对系统的功能点或业务流程进行描述，从而提高测试效果的一种方法。场景法一般包含基本流和备用流，从一个流程开始，通过描述经过的路径来确定的过程，经过遍历所有的基本流和备用流来完成整个场景。</p><blockquote><p><em>基本流</em>是从系统某个初始态开始，经一系列状态后到达终止状态的过程中最主要的一个业务流程。</p><p><em>备选流</em>是以基本流为基础，在经过的每个判定节点处满足不同的触发条件而导致的其他事件流。</p></blockquote><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>对ATM机的取款用例，使用场景法设计用例</p><p>（1）描述提款用例的基本流和备选流 </p><table><thead><tr><th>基本流</th><th><strong>1</strong> <strong>插入银行卡</strong></th></tr></thead><tbody><tr><td></td><td><strong>2</strong> <strong>验证银行卡</strong></td></tr><tr><td></td><td><strong>3</strong> <strong>输入</strong> <strong>PIN</strong></td></tr><tr><td></td><td><strong>4</strong> <strong>验证帐户代码和</strong> <strong>PIN</strong></td></tr><tr><td></td><td><strong>5 ATM</strong> <strong>选项</strong></td></tr><tr><td></td><td><strong>6</strong> <strong>输入金额</strong></td></tr><tr><td></td><td><strong>7</strong> <strong>授权</strong></td></tr><tr><td></td><td><strong>8</strong> <strong>出钞</strong></td></tr><tr><td></td><td><strong>9</strong> <strong>退卡</strong></td></tr></tbody></table><table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr><tr><td>备选流 1 - 帐户不存在</td></tr><tr><td>备选流 2 - PIN 有误</td></tr><tr><td>备选流 3 - ATM 内没有现金</td></tr><tr><td>备选流 4 - ATM 内现金不足</td></tr><tr><td>备选流 5 - 帐户金额不足</td></tr><tr><td></td></tr><tr><td></td></tr></tbody></table><p>（2）场景设计 </p><table><thead><tr><th><strong>场景1-成功的提款</strong></th><th>基本流</th><th></th></tr></thead><tbody><tr><td>场景2-ATM内没有现金</td><td>基本流</td><td>备选流3</td></tr><tr><td>场景3-ATM内现金不足</td><td>基本流</td><td>备选流4</td></tr><tr><td>场景4-PIN有误（还有输入机会）</td><td>基本流</td><td>备选流2</td></tr><tr><td>场景5-PIN有误（不再有输入机会）</td><td>基本流</td><td>备选流2</td></tr><tr><td>场景6-帐户不存在/帐户类型有误</td><td>基本流</td><td>备选流1</td></tr><tr><td>场景7-帐户余额不足</td><td>基本流</td><td>备选流5</td></tr></tbody></table><p>备选流 1 - 帐户不存在</p><p>备选流 2 - PIN 有误</p><p>备选流 3 - ATM 内没有现金</p><p>备选流 4 - ATM 内现金不足</p><p>备选流 5 - 帐户金额不足</p><p>（3）用例设计 </p><table><thead><tr><th>ID号</th><th>场景/条件</th><th>PIN码</th><th>帐号</th><th>输入金额</th><th>帐面金额</th><th>ATM 的金额</th><th>预期结果</th></tr></thead><tbody><tr><td>CW1</td><td>场景1-成功的提款</td><td>V</td><td>V</td><td>V</td><td>V</td><td>V</td><td>成功的提款</td></tr><tr><td>CW2</td><td>场景2-ATM 内没有现金</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>提款选项不可用，用例结束</td></tr><tr><td>CW3</td><td>场景3-ATM 内现金不足</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>警告消息，返回基本流步骤 6，输入金额</td></tr><tr><td>CW4</td><td>场景4-PIN 有误（还有两次机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，返回基本流步骤 4，输入PIN</td></tr><tr><td>CW5</td><td>场景4-PIN 有误（还有一次机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，返回基本流步骤 4，输入PIN</td></tr><tr><td>CW6</td><td>场景5-PIN 有误（没有输入机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，卡予保留，用例结束</td></tr></tbody></table><p>（4）补充异常流</p><p>无效卡（挂失卡、非承兑银行发卡、磁条损坏等） </p><p>无法读卡（读卡机堵塞、脱机或出现故障）</p><p>无法联系银行系统以获得认可 </p><p>银行网络离线或交易过程中断电 </p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>【例】　有一个处理单价为5角钱的饮料的自动售货机，相应规格说明如下。</p><p>① 若投入5角钱或1元钱的硬币，按下【橙汁】或【啤酒】的按钮，则相应的饮料就送出来。（每次只投入一个硬币，只按下一种饮料的按钮。）</p><p>② 如投入5角的硬币，按下按钮后，总有饮料送出。</p><p>③ 若售货机没有零钱找，则【零钱找完】的红灯不会亮，这时再投入1元硬币并按下按钮后，饮料不送出来而且1元硬币也退出来。</p><p>④ 若有零钱找，则【零钱找完】的红灯不会亮，若投入1元硬币及按饮料按钮，则送出饮料的同时找回5角硬币。</p><p>（1）分析基本流和备选流</p><p>基本流：投入5角钱，按下【橙汁】或【啤酒】的按钮，则相应的饮料就送出来。</p><p>备选流：</p><ol><li><p>备选流1：【零钱找完】的红灯没亮，若投入1元硬币及按饮料按钮，则送出饮料的同时找回5角硬币。</p></li><li><p>备选流2：【零钱找完】的红灯亮，这时投入1元硬币并按下按钮后，饮料不送出来且1元硬币也退出来。</p></li></ol><p>（2）分析场景</p><p>场景1：基本流</p><p>场景2：备选流1</p><p>场景3：备选流2</p><p>（3）设计测试用例</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1566019423441.png" alt="1566019423441"></p><h3 id="QQ安装功能测试"><a href="#QQ安装功能测试" class="headerlink" title="QQ安装功能测试"></a>QQ安装功能测试</h3><p>安装系统之家版QQ</p><p>运行XTZJQQ2006.exe</p><p>点击“下一步”</p><p>点击“上一步</p><p>返回上一个界面，</p><p>点击“下一步”</p><p>点击“上一步</p><p>返回上一个界面，</p><p>点击“下一步”</p><p>点击“上一步</p><p>返回上一个界面，</p><p>点击“下一步”</p><p>点击“上一步</p><p>返回上一个界面，</p><p>点击“下一步”</p><p>点击“上一步</p><p>返回上一个界面，</p><p>点击“下一步”</p><p>点击“上一步</p><p>返回上一个界面，</p><p>点击“安装”</p><p>点击“完成”</p><p>安装过程结束，</p><p>在所有界面中点击“取消”</p><blockquote><p>Step1、如果需求是文字描述，将文字转化为图形</p><p>Step2、需求中包含1个独立功能 —— QQ安装功能</p><p>Step3、针对打印功能开展需求分析</p><p>​             界面可见输入参数：同意、安装组件、安装位置、</p><p>​                                           创建菜单文件夹、显示说明书</p><p>​             界面不可见输入参数：系统平台兼容、安装组件、安装空间</p><p>Step4、分析界面可见输入参数之间的关系及特点</p><p>​    选择组件、显示说明书不存在有效无效规则校验 —X— 等价类、边界值</p><p>​    同意、安装位置、创建菜单文件夹存在有效无效，但是当前界面并不提示错误，所以不能用等价类、边界值</p><p>​    参数之间不存在一个是什么另外一个必须什么的逻辑关系 —X— 判定表</p><p>​    参数存在无效，不全是有效的 —X— 正交试验</p><p>​        一个功能的实现需要多个界面协同完成（跨界面）</p><p>​        存在逻辑关系（对错不能同时存在，同意/不同意、上一步/下一步）</p><p>​        并且不同参数组合会输出不同结果</p><p>​                                —— 流程分析法</p><p>Step5、利用流程分析法设计测试用例</p><p>画图法：</p><ol><li><p>将安装向导界面的判定条件并列存放在一行</p></li><li><p>将许可协议加密的判定条件并列存放在下一行</p></li><li><p>重复步骤1，直到所有界面都画完</p></li><li><p>先画条件为真的分支</p></li><li><p>再画条件为假的分支</p></li><li><p>一条分支为一条测试用例</p></li></ol><p>Step4_2、流程分析法设计测试用例</p><p>矩阵法（实战）：</p></blockquote><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1566020072149.png" alt="1566020072149"></p><h3 id="流程分析法的优缺点"><a href="#流程分析法的优缺点" class="headerlink" title="流程分析法的优缺点"></a>流程分析法的优缺点</h3><p>优点：流程分析法既能覆盖条件为真的分支，也能覆盖条件为假的分支</p><p>缺点：流程分析法不能验证每个界面的参数是否正确，验证的是流程，所以需要与开发进行沟通需求，需要在每个界面进行校验，如果错误，直接在当前界面提示信息，所以需要多种方法组合使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例04</title>
      <link href="/2019/08/17/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B04/"/>
      <url>/2019/08/17/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B04/</url>
      
        <content type="html"><![CDATA[<h1 id="正交试验"><a href="#正交试验" class="headerlink" title="正交试验"></a>正交试验</h1><a id="more"></a><p>正交试验设计法，就是使用已经造好了的表格——正交表来安排试验并进行数据分析的一种方法。</p><p>正交试验采用两两组合方式，减少用例个数</p><p>适用于兼容性测试、测试范围小。</p><h2 id="正交表生成工具的使用方法"><a href="#正交表生成工具的使用方法" class="headerlink" title="正交表生成工具的使用方法"></a>正交表生成工具的使用方法</h2><blockquote><p>1、打开虚拟机，将安装程序解压到C盘根目录下</p><p>2、在文件夹中新建一个文本文档aaa.txt，将步骤②因子状态表复制到此文本文档中，    </p><p>​      不要做任何改动，直接保存关闭</p><p>3、打开doc窗口，输入 cd + 安装文件路径</p><p>4、输入dir ，查看一下安装程序和aaa.txt文档是否存在</p><p>5、输入allpairs aaa.txt &gt; bbb.txt</p><p>6、在文件夹目录下多出bbb.txt文档，此文档上一部分内容即为生成的正交表</p></blockquote><h2 id="打印功能测试"><a href="#打印功能测试" class="headerlink" title="打印功能测试"></a>打印功能测试</h2><p>例子1: PowerPoint 软件打印功能描述如下：</p><p>​       打印范围分：全部、当前幻灯片、给定范围</p><p>​       打印内容分：幻灯片、讲义、备注页、大纲视图</p><p>​       打印颜色/灰度分：颜色、灰度、黑白共三种设置</p><p>​       打印方式：是否加框</p><blockquote><p>Step1、如果需求是文字描述，将文字转化为图形</p><p>Step2、需求中包含1个独立功能 —— 打印功能</p><p>Step3、针对打印功能开展需求分析</p><p>​             界面可见输入参数：打印范围、打印内容、打印颜色、打印方式</p><p>​             界面不可见输入参数：网络、打印机本身（耗材、硬件）、驱动打印服务</p><p>Step4、分析界面可见输入参数之间的关系及特点</p><p>参数存在用户输入数据，但是不存在无效数据，全部都是有效的</p><p>​    —X— 等价类</p><p>参数不存在区间范围 —X— 边界值</p><p>参数之间不存在逻辑判定关系 —X— 判定表</p><p>参数都是有效的，有效参数组合会输出不同结果，功能的实现是由Switch…case…多分支结构组成 —— 正交试验</p><p>Step5、使用正交试验法设计测试用例</p><p>将需求转化为因子状态表（因子：输入参数，状态：输入参数取值）</p><p>将因子状态表中的文字用字母代替</p><p>将因子状态表代入正交表（规则：多则合并，少则补充）</p><p>如果正交表中有合并项，将合并项拆分成多行</p><p>将正交表中的字母用文字代替</p><p>一行对应一条测试用例</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例03</title>
      <link href="/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B03/"/>
      <url>/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B03/</url>
      
        <content type="html"><![CDATA[<h1 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h1><a id="more"></a><p>在一个程序中，<strong>如果输入输出比较多，输入之间和输出之间相互制约的条件比较多，在这种情况下应用决策表很合适</strong>，它可以很清楚地表达它们之间的各种复杂关系。</p><p>决策表法简述：<br>       决策表是把作为条件的所有输入的各种组合值以及对应输出值都罗列出来而形成的表格。它能够将复杂的问题按照各种可能的情况全部列举出来，简明并可避免遗漏。因此，利用决策表能够设计出完整的测试用例集合。</p><blockquote><p>决策表通常由以下4部分组成：</p><p>1.条件桩—列出问题的所有条件</p><p>2.条件项—针对条件桩给出的条件列出所有可能取值</p><p>3.动作桩—列出问题规定的可能采取的操作</p><p>4.动作项—指出在条件项的各组取值情况下应采取的动作 </p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote><p>打印机是否能打印出来正确的内容有多个因素影响，包括驱动程序、纸张、墨粉等。（为了简化问题，不考虑中途断电、卡纸等因素的影响）</p><p>假定：优先警告缺纸，然后警告没有墨粉，最后警告驱动程序不对。</p><p>1)列出条件桩和动作桩</p><p>条件桩:  a)驱动程序是否正确   b)是否有纸张   c)是否有墨粉</p><p>动作桩:  a) 打印内容       b)提示驱动程序不对   </p><p>​              c)提示没有纸张      d)提示没有墨粉</p></blockquote><h2 id="决策表的构造及化简"><a href="#决策表的构造及化简" class="headerlink" title="决策表的构造及化简"></a>决策表的构造及化简</h2><blockquote><p>1.列出所有的条件桩和动作桩。</p><p>2.确定规则的个数。</p><p>3.填入条件项。</p><p>4.填入动作项，得到初始决策表。</p><p>5.简化决策表，合并相似规则。</p></blockquote><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="得到初始判定表"><a href="#得到初始判定表" class="headerlink" title="得到初始判定表"></a>得到初始判定表</h3><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>条件：   功率大于50马力？   维修记录不全？   运行超过10年？</td><td>Y   Y   Y</td><td>Y   Y   N</td><td>Y   N   Y</td><td>Y   N   N</td><td>N   Y   Y</td><td>N   Y   N</td><td>N   N   Y</td><td>N   N   N</td></tr><tr><td>动作：   进行优先处理   做其他处理</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="简化判定表，合并相似规则"><a href="#简化判定表，合并相似规则" class="headerlink" title="简化判定表，合并相似规则"></a>简化判定表，合并相似规则</h3><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>条件：   功率大于50马力？   维修记录不全？   运行超过10年？</td><td>Y   Y   -</td><td>Y   N   Y</td><td>Y   N   N</td><td>N   -   Y</td><td>N   -  N</td><td></td><td>N   N   Y</td><td>N   N   N</td></tr><tr><td>动作：   进行优先处理   做其他处理</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例02</title>
      <link href="/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B02/"/>
      <url>/2019/08/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B02/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h1><blockquote><p>1.等价类法</p><p>2.边界值法</p></blockquote><a id="more"></a><h2 id="等价类法"><a href="#等价类法" class="headerlink" title="等价类法"></a>等价类法</h2><p>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这个过程，直至所有的有效等价类均被测试用例所覆盖；</p><p>设计一个新的测试用例，使其仅覆盖一个无效等价类，重复这个过程，直至所有的无效等价类均被测试用例所覆盖。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote><p>某城市电话号码由三部分组成，分别是</p><p>地区码：空白或是3位数字</p><p>前缀：非‘0’且非‘1’开头的三位数字</p><p>后缀：4位数字</p><p>假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的电话号码</p></blockquote><table><thead><tr><th><strong>条件</strong></th><th><strong>有效等价类</strong></th><th><strong>编号</strong></th><th><strong>无效等价类</strong></th><th style="text-align:center"><strong>编号</strong></th></tr></thead><tbody><tr><td>地区码</td><td>空白</td><td>1</td><td>非数字</td><td style="text-align:center">5</td></tr><tr><td>三位数字</td><td>2</td><td>小于三位</td><td>6</td><td style="text-align:center"></td></tr><tr><td>前缀</td><td>大于三位</td><td>7</td><td></td><td style="text-align:center"></td></tr><tr><td>非0且非1开头的三位数字</td><td>3</td><td>空值</td><td>8</td><td style="text-align:center"></td></tr><tr><td></td><td>0开头的三位数字</td><td>9</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>1开头的三位数字</td><td>10</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>非0且非1 开头的长度小于三位的数字</td><td>11</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>非0且非1 开头的长度大于三位的数字</td><td>12</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>非数字</td><td>13</td><td></td><td style="text-align:center"></td></tr><tr><td>后缀</td><td>四位数字</td><td>4</td><td>空值</td><td style="text-align:center">14</td></tr><tr><td></td><td>非数字</td><td>15</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>小于四位</td><td>16</td><td></td><td style="text-align:center"></td></tr><tr><td></td><td>大于四位</td><td>17</td><td></td></tr></tbody></table><blockquote><p>1.Step1、分析需求中包含多少个独立功能</p><p>判断独立功能的标准：功能名是一个动词、不可继续往下分割、包含三要素：输入、处理、输出</p><p>2.Step2、分别针对每个独立功能开展需求分析</p><p>分析界面可见输入参数，罗列参数个数及名称、  分析界面不可见输入参数：网络、浏览器/系统、权限、数据库服务、系统本身服务</p><p>3.Step3、分析界面可见输入参数的特点及其关系</p><p>输入参数需要用户输入数据，并且存在有效/无效规则校验—— 则用等价类法设计测试用例</p><p>4.Step4、分别罗列每个界面可见输入参数的有效无效规则，形成等价类表</p><p>测试文本框类型应考虑的几个维度：长度、类型、组成规则、是否为空、是否重复、是否区分大小写、是否去前中后空格</p><p>构造无效规则时要注意：只能同时违背一条规则</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><blockquote><p>用户注册页面需求</p><p>-USER NAME  长度为  3-19：以字母开头</p><p>-姓名：非空</p><p>-密码： 非空</p><p>-确认密码： 值和密码相同</p><p>-出生月份： 年—–四位数字</p><p>-                    月——1-12</p><p>​             日——-1-31</p></blockquote><table><thead><tr><th><strong>输入项</strong></th><th><strong>有效等价类</strong></th><th><strong>无效等价类</strong></th></tr></thead><tbody><tr><td>username</td><td>长3—19（1）      以字母开头   （4）</td><td>长度<3 (2) 长度>19      (3)   非字母开头（5）</3></td></tr><tr><td>姓名</td><td>非空    （6）</td><td>为空      （7）</td></tr><tr><td>密码</td><td>非空    （8）</td><td>为空    （9）</td></tr><tr><td>确认密码</td><td>值和密码值相同   （10）</td><td>值和密码值不同   （11）</td></tr><tr><td>出生年份</td><td>年  —-    四位（12）   年    —-   数字  （14）      年    —-     合理范围（16）</td><td>&lt;4(13)  &gt;4(18)   年数中他非数字符号(19)   空（15）   年数在不合理范围（17）</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="边界值"><a href="#边界值" class="headerlink" title="边界值"></a>边界值</h2><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法</p><p>长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部（从开发角度可以发现）。因此针对各种边界情况设计测试用例，可以查出更多的错误。</p><p>使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据</p><p><img src="C:\Users\28715\AppData\Roaming\Typora\typora-user-images\1565956632576.png" alt="1565956632576"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p>例如，如果程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取？</p><p>9.99，10，10.01，49.99,50，50.01。</p><p>练习：</p><p>   [100   200]</p><p>   [100   200）</p><p>   (100   200)</p></blockquote><p>结合等价类划分法，设计测试数据！</p><p>移动公司话费赠送方案如下：</p><table><thead><tr><th><strong>话费累计</strong></th><th><strong>赠送</strong></th></tr></thead><tbody><tr><td>[0,200)</td><td>0</td></tr><tr><td>[200,500)</td><td>20</td></tr><tr><td>[500,800)</td><td>30</td></tr><tr><td>&gt;=800</td><td>50</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>等价类用例设计要点</p><p>  1 操作步骤 </p><pre><code>1 一个新用例尽量覆盖有效规则2 一个新用例只能覆盖一条无效规则</code></pre><p>  2 测试过程中需要考虑要点</p><p>边界值用例设计要点</p><p>  1 上点</p><p>  2 离点</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试用例01</title>
      <link href="/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B01/"/>
      <url>/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B01/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例概述"><a href="#测试用例概述" class="headerlink" title="测试用例概述"></a>测试用例概述</h1><blockquote><p>1.测试用例的定义</p><p>2.测试用例的特性</p><p>3.测试用例的编制要素</p><p>4.测试用例的设计原则</p></blockquote><a id="more"></a><h2 id="测试用例的定义"><a href="#测试用例的定义" class="headerlink" title="测试用例的定义"></a>测试用例的定义</h2><p>​    测试用例(Test Case)是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试某个程序路径或核实是否满足某个特定需求。</p><p>​    通过大量的测试用例来检验软件的运行效果，它是指导测试工作进行的依据。</p><p>​    输入数据        执行条件和执行步骤         预期结果</p><p>测试用例（TestCase）是为了高效率地发现软件缺陷而精心设计的少量测试数据。实际测试中，由于无法达到穷举测试，所以要从大量输入数据中精选有代表性或特殊性的数据来作为测试数据。好的测试用例应该能发现尚未发现的软件缺陷</p><h2 id="测试用例的特性"><a href="#测试用例的特性" class="headerlink" title="测试用例的特性"></a>测试用例的特性</h2><blockquote><p>1.有效性：测试用例的能够被使用，且被不同人员使用测试结果一致。</p><p>2.可复用性：良好的测试用例具有重复使用的功能</p><p>3.易组织性：好的测试用例会分门别类地提供给测试人员参考和使用。</p><p>4.可评估性：从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。</p><p>5.可管理性：测试用例可以作为检验测试人员进度、工作量以及跟踪/管理测试人员工作效率的因素。</p></blockquote><h2 id="测试用例的编制要素"><a href="#测试用例的编制要素" class="headerlink" title="测试用例的编制要素"></a>测试用例的编制要素</h2><p>软件测试用例的基本要素包括用例编号、测试模块、用例标题、用例级别、测试环境、测试输入、执行操作、预期结果。</p><blockquote><p>1.用例编号：每个测试用例都有唯一的标识号，用以区别其他测试用例。</p><p>例：系统测试用例的编号这样定义规则：PROJECT1-ST-001，命名规则是项目名称＋测试阶段类型（系统测试阶段）＋编号。</p><p>2.测试标题：对测试用例的描述，测试用例标题应该清楚表达测试用例的用途。</p><p>例： “测试用户登录时输入错误密码时，软件的响应情况 ” 。</p><p>3.测试模块：指明并简单描述本测试用例是用来测试哪些项目、子项目或软件特性的。</p><p>例： 购物模块</p><p>4.用例级别：定义测试用例的优先级别，可以粗略地分为“ 高 ” 和 “ 低 ” 两个级别，</p><p>例： 核心功能 —高        界面风格 —低</p><p>5.测试环境：描述执行测试用例所需要的具体测试环境，包括硬件环境和软件环境。</p><p>例： 硬件  ： 计算机的具体配置，见测试计划       软件   ：  操作系统    linux                      数据库       mysql                      中间件       weblogic</p><p>6.测试输入：用来执行测试用例的输入要求。这些输入可能是数据、文件或具体操作。</p><p>例如： 数据  ：  12           文件  ：   c：\a.c  件couture           动作  ：  单击鼠标，在键盘做按键处理）。</p><p>7.执行操作：执行本测试用例所需的每一步操作。</p><p>例： 求和运算         输入加数12          输入被加数 24          点击“加法按钮”</p><p>8.预期结果：描述被测项目或被测特性所希望或要求达到的输出或指标。</p><p>例：  加法器    12+24           预期结果：  36</p></blockquote><h2 id="测试用例的设计原则"><a href="#测试用例的设计原则" class="headerlink" title="测试用例的设计原则"></a>测试用例的设计原则</h2><ol><li>保证测试用例的明确性</li></ol><p>测试人员要尽量避免测试用例存在含糊的因素，在测试过程中，测试用例的测试结果是唯一的。</p><p>明确清晰的描述  如：即通过、没通过或未进行测试。</p><p>不确定的描述    例如，测试用例这样描述：  </p><p>用户正确操作，系统正常运行；</p><p>用户进行非法操作，系统不能正常运行。</p><ol start="2"><li>保证测试用例的代表性</li></ol><p>尽量将具有相似功能的测试用例抽象合并。</p><p>如： 以后我们要学习的等价类测试   </p><p>​        测试1 —-100之间的两个整数的和   </p><p>​       用例  1+2=3</p><p>​               2+4 =6  </p><p>功能相似的用例要合并</p><ol start="3"><li>保证测试用例的简洁性</li></ol><p>测试用例简洁，可读性良好，测试过程目的明确，测试结果唯一。</p><p>例： 测试用例要用陈述性语句  一句话直指问题的核心</p><p>​          加法器输入框输入是非数字时，应弹出提示“请输入数字”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试用例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论05</title>
      <link href="/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA05/"/>
      <url>/2019/08/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA05/</url>
      
        <content type="html"><![CDATA[<h1 id="svn的使用"><a href="#svn的使用" class="headerlink" title="svn的使用"></a>svn的使用</h1><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（1）电脑发生故障，文件没有备份而丢失了</span><br><span class="line">由于人员离职，导致某些资料丢失了</span><br><span class="line">（2）我怎么知道手头的公共资料是不是最新版呢？</span><br><span class="line">（3）想要追溯几个月前的某个状态，却发现那个版本的文件已经被当作垃圾删除了</span><br><span class="line">（4）每天要花费很多时间来向别人提供需要共享的资料</span><br><span class="line">（5）相似的应用系统，每次都重复开发，难以复用</span><br><span class="line">（6）一个软件被用于多个项目，发现其中存在一个BUG，所有这些项目都要进行修复</span><br><span class="line">（7）人员分布在两地开发，版本如何同步</span><br><span class="line">甲乙两人为不同目的修改了同一份文件，乙的提交在甲提交之后，导致甲修改的内容丢失了</span><br></pre></td></tr></table></figure><h2 id="1、svn的简介"><a href="#1、svn的简介" class="headerlink" title="1、svn的简介"></a>1、svn的简介</h2><ul><li>一个开源的版本管理软件</li><li>可架设在Apache上，最常用的客户端为TortoiseSVN（简称TSVN）</li></ul><h2 id="2、应用环境"><a href="#2、应用环境" class="headerlink" title="2、应用环境"></a>2、应用环境</h2><ul><li>服务器端：CollabNet的SVN服务器端安装包（内含Apache2.2）</li><li>推荐使用TortoiseSVN（以下简称TSVN）</li><li>可通过TSVN进行读、写操作</li><li>可通过IE浏览器进行读操作</li><li>可通过各种插件与开发工具集成</li></ul><h2 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装文件：</span><br><span class="line">TSVN客户端：</span><br><span class="line">TortoiseSVN-1.6.8.19260-win32-svn-1.6.11.msi</span><br><span class="line">TSVN中文语言包：</span><br><span class="line">LanguagePack_1.6.8.19260-win32-zh_CN.msi</span><br><span class="line">全部选择默认安装，安装完成后重启电脑</span><br><span class="line">TSVN通过右键菜单与Windows资源管理器集成，没有自己的窗口界面</span><br></pre></td></tr></table></figure><h2 id="svn的使用-创建版本库"><a href="#svn的使用-创建版本库" class="headerlink" title="svn的使用-创建版本库"></a>svn的使用-创建版本库</h2><ul><li>在SVN服务器端操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在相应文件夹内新建一个文件夹，用于存储数据</span><br><span class="line">在新建文件夹上点右键，选择“TortoiseSVN－在此创建版本库”，TSVN会在此文件夹内建立若干控制文件。如图</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/111.png" alt="img"></p><h2 id="svn使用-检出"><a href="#svn使用-检出" class="headerlink" title="svn使用-检出"></a>svn使用-检出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“检出”用于客户端第一次从SVN服务器上下载版本库数据</span><br><span class="line">在客户端新建一个文件夹用于存放下载的数据</span><br><span class="line">在新建文件夹上点右键，选择“SVN检出…”</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/112.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在弹出窗口的“版本库URL”处填入版本库的访问地址，如：http://10.50.22.35:8080/svn/XXX部门/XXXX项目/</span><br><span class="line">点“确定”开始从SVN服务器下载数据</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/113.png" alt="img"></p><h2 id="svn使用-更新"><a href="#svn使用-更新" class="headerlink" title="svn使用-更新"></a>svn使用-更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“更新”用于客户端从SVN服务器下载最新版本</span><br><span class="line">在受SVN控制的某层文件夹上（或文件夹内空白处）点右键，选择“SVN更新”，TSVN自动比较该文件夹客户端与服务器的版本差异，并下载最新版本到客户端</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/114.png" alt="img"></p><h2 id="svn使用-提交"><a href="#svn使用-提交" class="headerlink" title="svn使用-提交"></a>svn使用-提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“提交”用于将客户端的改动上传到SVN服务器</span><br><span class="line">在受SVN控制的某层文件夹上（或文件夹内空白处，或某文件上）点右键，选择“SVN提交…”</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/115.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TSVN自动检查该文件夹客户端的改动，并将其列在弹出窗口的“变更列表”栏</span><br><span class="line">在弹出窗口的“信息”栏写上对此次提交的注释，以便将来追溯</span><br><span class="line">点击“确定”将客户端的改动上传到服务器</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/116.png" alt="img"></p><h2 id="svn使用-增加"><a href="#svn使用-增加" class="headerlink" title="svn使用-增加"></a>svn使用-增加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“增加”用于将新文件或文件夹纳入SVN的控制之下</span><br><span class="line">在受SVN控制的某层文件夹上（或文件夹内空白处，或新增的某文件上）点右键，选择“TortoiseSVN－增加”</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/117.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接在受svn控制的文件夹中添加想要上传的文件，然后右键选择“提交”即可；</span><br></pre></td></tr></table></figure><h2 id="svn使用-删除"><a href="#svn使用-删除" class="headerlink" title="svn使用-删除"></a>svn使用-删除</h2><ul><li>“删除”仅是对客户端的文件进行操作，并不改变服务器上的内容，需要执行“提交”操作才会将删除操作上传到服务器</li><li>将“删除”操作“提交”到服务器后，仅是从服务器的最新版本中删除了此文件或文件夹，在历史版本中仍可找回此文件或文件夹</li></ul><h2 id="svn使用-改名"><a href="#svn使用-改名" class="headerlink" title="svn使用-改名"></a>svn使用-改名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“改名”用于在受SVN控制的状态下，对文件或文件夹改名</span><br><span class="line">在受SVN控制的某层文件夹或文件上点右键，选择“TortoiseSVN－改名”</span><br></pre></td></tr></table></figure><ul><li>“改名”仅是对客户端的文件进行操作，并不改变服务器上的内容，需要执行“提交”操作才会将改名操作上传到服务器</li><li>不要用Windows“重命名”来实现改名，因为这个操作不受SVN控制，SVN会将其理解为删除原文件、增加一个新文件，从而导致文件改名后不能跟踪到改名前的状态</li></ul><h2 id="svn使用-移动"><a href="#svn使用-移动" class="headerlink" title="svn使用-移动"></a>svn使用-移动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“移动”用于在受SVN控制的状态下，移动文件或文件夹的位置</span><br><span class="line">在受SVN控制的某层文件夹或文件上点右键，选择“TortoiseSVN－版本库浏览器”</span><br><span class="line">在弹出窗口拖动文件夹或文件到需要的位置</span><br><span class="line">由于是对服务器版本库直接操作，移动后将自动执行一次“提交”操作</span><br><span class="line">移动完成后需要在客户端执行一次“更新”，以下载最新状态</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/118.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要用Windows的拖动操作或“剪切”、“粘贴”来实现移动，因为这些操作不受SVN控制，SVN会将其理解为在原位置删除文件、在新位置增加文件，从而导致文件移动后不能跟踪到移动前的状态</span><br></pre></td></tr></table></figure><h2 id="7、缺陷管理"><a href="#7、缺陷管理" class="headerlink" title="7、缺陷管理"></a>7、缺陷管理</h2><ul><li>管理员可通过修改服务器上的权限文件，实现对权限的控制</li><li>权限分为三种：无权限、只读权限和读写权限</li><li>权限的控制以文件夹为最小单位</li><li>可对单个用户的权限进行控制，也可以对用户组的权限进行控制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论04</title>
      <link href="/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA04/"/>
      <url>/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.软件缺陷</p><p>2.缺陷管理</p></blockquote><a id="more"></a><h1 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h1><h2 id="软件缺陷-1"><a href="#软件缺陷-1" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><h4 id="软件缺陷的定义"><a href="#软件缺陷的定义" class="headerlink" title="软件缺陷的定义"></a>软件缺陷的定义</h4><ul><li><p>IEEE 1983 of IEEE Standard 729中对软件缺陷作了一个标准的定义：</p><p>从产品内部看，软件缺陷是软件产品开发或维护过程中所存在的错误、毛病等各种问题； 从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。</p></li></ul><p>因此软件缺陷就是软件产品中所存在的问题，最终表现为用户所需要的功能没有完全实现，没有满足用户的需求。</p><ul><li><p>软件缺陷是指存在于软件（程序、数据、文档）中的那些不符合用户需求的问题。</p><ol><li><p>软件未达到需求规格说明书表明的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算器说明书一般声称该计算器将准确无误地进行加、减、乘、除运算。</span><br><span class="line">如果测试人员或用户选定了两个数值后，随意按下了“+”号键，结果没有任何反应。</span><br></pre></td></tr></table></figure></li><li><p>软件出现了需求规格说明书指明不会出现的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若在进行测试时，发现除了规定的加、减、乘、除功能之外，还能够进行求平方根的运算，</span><br><span class="line">而这一功能并没有在说明书的功能中规定。</span><br></pre></td></tr></table></figure></li><li><p>软件的功能超出了需求规格说明书指明的范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若在测试过程中发现，因为电池没电而导致了计算不正确，</span><br><span class="line">但软件需求规格说明书未能指出在此情况下应如何进行处理。</span><br></pre></td></tr></table></figure></li><li><p>软件未达到需求规格说明书虽未指明而应该达到的目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假如计算器说明书指明计算器不会出现崩溃、死锁或者停止反应，而在用户随意按、敲键盘后，</span><br><span class="line">计算器停止接受输入或没有了反应。</span><br></pre></td></tr></table></figure></li><li><p>软件测试人员认为软件难以理解、不易使用、运行速度慢、或者最终用户认为不好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试人员或最终用户发现计算器某些地方不好用，比如，按键太小、显示屏在亮光下无法看清等。</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="软件缺陷的表现形式"><a href="#软件缺陷的表现形式" class="headerlink" title="软件缺陷的表现形式"></a>软件缺陷的表现形式</h4><ul><li>功能、特性没有实现或部分实现。</li><li>设计不合理，功能特性不明确，逻辑不清楚或存在矛盾。</li><li>产品实际结果和所期望的结果不一致。</li><li>没有达到需求规格说明书所规定的性能指标等。</li><li>运行出错，包括运行中断、系统崩溃、界面混乱等。</li><li>数据不正确、精度不够、不完整或格式不统一。</li><li>用户不能接受的其他问题，如存取时间过长、界面不美观。</li><li>硬件或系统软件上存在的其他问题</li></ul><h4 id="软件缺陷产生的原因"><a href="#软件缺陷产生的原因" class="headerlink" title="软件缺陷产生的原因"></a>软件缺陷产生的原因</h4><p>软件缺陷产生是不可避免的，造成软件缺陷产生的原因主要归纳如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">需求解释或者记录错误  </span><br><span class="line">用户需求定义错误  </span><br><span class="line">设计说明存在错误  </span><br><span class="line">编码说明、程序代码有误  </span><br><span class="line">硬件或者软件系统上存在错误  </span><br><span class="line">其他，如文档错误、内容不正确或拼写错误</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/56.png" alt="img"></p><h4 id="软件缺陷产生的根源"><a href="#软件缺陷产生的根源" class="headerlink" title="软件缺陷产生的根源"></a>软件缺陷产生的根源</h4><ul><li><p>交流不充分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户与开发人员、开发人员与测试人员等</span><br></pre></td></tr></table></figure></li><li><p>软件的复杂性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能复杂、开发复杂、测试复杂</span><br></pre></td></tr></table></figure></li><li><p>开发人员的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对需求的理解、开发压力、能力与经验</span><br></pre></td></tr></table></figure></li><li><p>需求的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求说明书、设计文档、程序的变更</span><br></pre></td></tr></table></figure></li><li><p>进度压力</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目周期比较紧</span><br></pre></td></tr></table></figure></li><li><p>软件缺陷修复的费用</p></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/57.png" alt="img"></p><h2 id="软件缺陷的信息"><a href="#软件缺陷的信息" class="headerlink" title="软件缺陷的信息"></a>软件缺陷的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了便于缺陷的定位、跟踪和修改，要对所发现的缺陷，按照缺陷的严重程度、优先级、发现阶段、</span><br><span class="line">修复阶段、缺陷的性质、所属功能模块、系统环境等方面进行分类和统计。</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/59.png" alt="img"></p><ul><li>缺陷的状态</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/58.png" alt="img"></p><ul><li>缺陷的分类</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/60.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/61.png" alt="img"></p><ul><li>缺陷的严重程度</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/62.png" alt="img"></p><ul><li>缺陷的优先级</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/63.png" alt="img"></p><h2 id="软件缺陷修复相关"><a href="#软件缺陷修复相关" class="headerlink" title="软件缺陷修复相关"></a>软件缺陷修复相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并不是所有的缺陷，开发人员都会进行修复</span><br></pre></td></tr></table></figure><ul><li><p>开发人员拒绝修改的缺陷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序员无法重现或者现象难以捕捉  </span><br><span class="line">没有明确的报告以说明重现缺陷的步骤  </span><br><span class="line">程序员无法读懂的缺陷报告  </span><br><span class="line">用户很少使用或者不符合用户使用习惯的操作出错  </span><br><span class="line">由不受信任的测试人员提出</span><br></pre></td></tr></table></figure></li><li><p>不是所有缺陷都会修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">市场的压力使得产品最终发行有时间限制</span><br><span class="line">测试人员错误理解或者不正确操作引出的缺陷(FAQ)</span><br><span class="line">错误的修改影响的模块较多，带来的风险较大(遗留)</span><br><span class="line">修改性价比太低</span><br><span class="line">缺陷报告中提出的问题很难重现</span><br></pre></td></tr></table></figure></li></ul><h1 id="缺陷管理"><a href="#缺陷管理" class="headerlink" title="缺陷管理"></a>缺陷管理</h1><h3 id="1、-缺陷报告的重要性"><a href="#1、-缺陷报告的重要性" class="headerlink" title="1、 缺陷报告的重要性"></a>1、 缺陷报告的重要性</h3><ul><li>软件缺陷的描述是软件缺陷报告的基础部分，需要使用简单、准确、专业的术语来描述缺陷。否则，它就会含糊不清，可能会误导开发人员，影响开发人员的效率，也会影响测试人员自身的声誉，准确报告缺陷是非常重要的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">清晰准确的软件缺陷描述可以减少开发人员退回来的缺陷数量，可以节省开发人员和测试人员的时间。</span><br><span class="line">提高软件缺陷修复的速度，使项目组能够有效地工作。</span><br><span class="line">提高测试人员的可信任程度，可以得到开发人员对有效缺陷的及时响应。</span><br><span class="line">加强开发人员、测试人员和管理人员的协同工作，让他们更好的工作</span><br></pre></td></tr></table></figure><h3 id="2、-缺陷报告的注意事项"><a href="#2、-缺陷报告的注意事项" class="headerlink" title="2、 缺陷报告的注意事项"></a>2、 缺陷报告的注意事项</h3><ul><li><p>尽量确保缺陷可以重现</p><blockquote><p>如果提交的缺陷无法重现，会影响开发人员的工作效率。</p></blockquote></li><li><p>简洁、准确、完整</p><blockquote><p>测试人员在提交缺陷报告时，要站在开发人员的角度上思考问题，要确保开发人员能迅速定位问题，而不会产生理解上的歧义。</p></blockquote></li><li><p>一个缺陷一个报告</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　有的测试人员喜欢在一个缺陷报告里提交多个缺陷，这种习惯不提倡，原因有以下两点：</span><br><span class="line">不便于分配。</span><br><span class="line">　　比如缺陷报告有2个缺陷，分别属于不同的开发人员，到底该分配给谁呢？</span><br><span class="line">不便于验证。</span><br><span class="line">　　比如一个缺陷报告里面有2个缺陷，缺陷1已经解决，缺陷2还没有解决，那么这个缺陷报告该不该关闭呢？</span><br></pre></td></tr></table></figure><h3 id="3、-缺陷书写规范"><a href="#3、-缺陷书写规范" class="headerlink" title="3、 缺陷书写规范"></a>3、 缺陷书写规范</h3><ul><li>标题：应保持简短、准确，提供缺陷的本质信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尽量按缺陷发生的原因与结果的方式书写；</span><br><span class="line">避免使用模糊不清的词语，例如：“功能中断，功能不正确，行为不起作用”等。应该使用具体文字说明缺陷的症状；</span><br><span class="line">为了便于他人理解，避免使用俚语或过分具体的测试细节。</span><br></pre></td></tr></table></figure><ul><li>复现步骤：应包含如何使别人能够很容易的复现该缺陷的完整步骤。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了达到这个要求，复现步骤的信息必须是完整的、准确的、简明的、可复现的。常见问题：</span><br><span class="line">包含了过多的多余步骤，且句子结构混乱，可读性差，难以理解；</span><br><span class="line">包含的信息过少，丢失了操作的必要步骤；</span><br></pre></td></tr></table></figure><ul><li>复现步骤的正确书写方式:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">提供测试的环境信息；</span><br><span class="line">简单地一步步引导复现该缺陷，一个步骤包含的操作不要多；</span><br><span class="line">每个步骤前使用数字对步骤编号；</span><br><span class="line">尽量使用短语或短句，避免复杂句型句式；</span><br><span class="line">复现的步骤要完整、准确、简短；</span><br><span class="line">将常见步骤合并为较少步骤；</span><br><span class="line">按实际需要决定是否包含步骤执行后的结果。</span><br></pre></td></tr></table></figure><ul><li>实际结果: 是执行复现步骤后软件的现象和产生的行为。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际结果的描述应向标题信息那样，要列出具体的缺陷症状，而不是简单地指出“不正确”或“不起作用”。</span><br></pre></td></tr></table></figure><ul><li>期望结果:描述应与实际结果的描述方式相同。通常需要列出期望的结果是什么。</li><li>附件：对缺陷描述的补充说明，可以是以下一些类型：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缺陷症状的截图；</span><br><span class="line">测试使用的数据文件;</span><br></pre></td></tr></table></figure><ul><li>其他：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择合适的缺陷严重性属性；</span><br><span class="line">按相应的规定，填写相应的字段信息</span><br></pre></td></tr></table></figure><h4 id="3、1-避免常见错误"><a href="#3、1-避免常见错误" class="headerlink" title="3、1 避免常见错误"></a>3、1 避免常见错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">避免使用我、你等人称代词，可以直接使用动词或必要时使用“用户”代替</span><br><span class="line">避免使用情绪化的语言和强调符号；</span><br><span class="line">避免使用诸如“似乎”、“看上去可能”等含义模糊的词汇，而需要报告确定的缺陷结果；</span><br><span class="line">避免使用自认为比较幽默的语句，只需客观地描述缺陷的信息；</span><br><span class="line">避免提交不确定的测试问题，自己至少需要重现一次再提交。</span><br><span class="line">反面的示例：</span><br><span class="line">上海人：哪能查询到的结果和查询条件不搭噶的。</span><br><span class="line">北京人：哥们好不容易输入一堆个人详细信息后，点击保存后全瞎了</span><br></pre></td></tr></table></figure><h4 id="3、2-缺陷报告"><a href="#3、2-缺陷报告" class="headerlink" title="3、2 缺陷报告"></a>3、2 缺陷报告</h4><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/106.png" alt="img"></p><h4 id="3、3-缺陷处理流程"><a href="#3、3-缺陷处理流程" class="headerlink" title="3、3 缺陷处理流程"></a>3、3 缺陷处理流程</h4><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/107.png" alt="img"></p><h4 id="3、4-缺陷跟踪"><a href="#3、4-缺陷跟踪" class="headerlink" title="3、4 缺陷跟踪"></a>3、4 缺陷跟踪</h4><ul><li>新提交的缺陷为新建状态，确认有效后为打开状态，经开发人员修改后，缺陷变为已修复（待验证）状态。此时就需要测试人员对缺陷进行回归测试，验证问题是否修复。</li><li>如果问题仍然存在，则测试人员将该缺陷的状态修改为重新打开；</li><li>如果问题已经修复，则测试人员将该缺陷的状态置为关闭状态（验证通过），同时添加回测说明如“该缺陷已解决”。</li><li>还有一种情况：开发人员认为缺陷在当前版本可以暂不修改，而考虑在后续版本中再做修正，缺陷的对应状态为延期。</li><li>对于这种情况，项目负责人应召集开发人员、测试人员和其他项目相关人员进行讨论，如果讨论结果为同意则延期，如果不同意，则重新打开缺陷。</li></ul><h4 id="3、5-缺陷统计"><a href="#3、5-缺陷统计" class="headerlink" title="3、5 缺陷统计"></a>3、5 缺陷统计</h4><ul><li><p>缺陷按活动分布 <img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/108.png" alt="img"></p></li><li><p>缺陷按严重程度分布</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/109.png" alt="img"></p></li><li><p>缺陷按引入源分布</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/110.png" alt="img"></p></li></ul><h4 id="3、6-缺陷数据分析"><a href="#3、6-缺陷数据分析" class="headerlink" title="3、6 缺陷数据分析"></a>3、6 缺陷数据分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）缺陷数据分析关注的问题</span><br><span class="line">2）缺陷数据分析的重要性</span><br><span class="line">3）缺陷数据分析的数据指标</span><br></pre></td></tr></table></figure><h4 id="3、7-缺陷数据分析关注的问题"><a href="#3、7-缺陷数据分析关注的问题" class="headerlink" title="3、7 缺陷数据分析关注的问题"></a>3、7 缺陷数据分析关注的问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正在测试的软件哪个模块的问题最多</span><br><span class="line">测试人员中谁报告的软件缺陷最多</span><br><span class="line">各类缺陷所占的数量百分比分别是多少</span><br><span class="line">开发人员能及时修复软件缺陷吗</span><br><span class="line">开发人员一次正确修复缺陷的百分比是多少</span><br><span class="line">正在开发的软件能否在计划的时间内正常发布</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论03</title>
      <link href="/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA03/"/>
      <url>/2019/08/14/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA03/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h1><blockquote><p>1.场景法</p><p>2.流程图法</p><p>3.错误推测法</p><p>4.测试评审</p></blockquote><a id="more"></a><h1 id="测试用例设计方法—场景法"><a href="#测试用例设计方法—场景法" class="headerlink" title="测试用例设计方法—场景法"></a>测试用例设计方法—场景法</h1><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>场景法就是模拟用户操作软件时的场景，主要用于测试系统的业务流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当拿到一个测试任务时，我们并不是先关注某个控件的边界值、等价类是否满足要求，</span><br><span class="line">而是先要关注它的主要功能和业务流程是否正确实现，这就需要使用场景法来完成测试。</span><br><span class="line"></span><br><span class="line">当业务流程测试没有问题，也就是该软件的主要功能没有问题时，我们再重点从边界值、等价类等方面对控件进行测试</span><br></pre></td></tr></table></figure><p>在冒烟测试时也主要采用场景法进行测试</p><ul><li>为什么引入场景法</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/37.png" alt="img"></p><ul><li><p>场景法的定义</p><p>场景法中两个重要的概念</p><p>基本流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按照正确的业务流程来实现的一条操作路径（模拟正确的操作流程）</span><br></pre></td></tr></table></figure><p>备选流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导致程序出现错误的操作流程（模拟错误的操作流程）</span><br><span class="line">用例场景是用来描述流经用例路径的过程，这个过程从开始到结束遍历用例中所有基本流和备选流。</span><br></pre></td></tr></table></figure></li><li><p>场景法相关概念</p></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/38.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/39.png" alt="img"></p><ul><li>场景法测试用例</li></ul><h2 id="场景法案例"><a href="#场景法案例" class="headerlink" title="场景法案例"></a>场景法案例</h2><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/41.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/42.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/43.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/44.png" alt="img"></p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/45.png" alt="img"></p><h1 id="测试用例设计方法—流程图法"><a href="#测试用例设计方法—流程图法" class="headerlink" title="测试用例设计方法—流程图法"></a>测试用例设计方法—流程图法</h1><h2 id="流程图法"><a href="#流程图法" class="headerlink" title="流程图法"></a>流程图法</h2><p>流程分析法主要是针对测试场景类型属于流程测试场景的测试项下的测试子项进行设计。</p><ul><li>步骤</li></ul><p>第一步：详细了解需求；</p><p>第二步：根据需求说明或界面原型，找出业务流程的各个页面以及各页面之间的流转关系；</p><p><em>第三步：画出业务流程（产品经理使用Axure软件制作）</em>；</p><p>第四步：写用例，覆盖所有的路径分支。</p><h2 id="案例—使用ATM机取款"><a href="#案例—使用ATM机取款" class="headerlink" title="案例—使用ATM机取款"></a>案例—使用ATM机取款</h2><p>一、详细了解需求；</p><p>二、找出业务流程的各个页面以及各页面之间的流转关系；‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、用户向ATM取款机中插入银行卡……</span><br><span class="line">2、用户输入银行卡密码……</span><br><span class="line">3、用户输入取款金额……</span><br><span class="line">4、系统同步银行主机，点钞票，输出给用户并减去用户卡中相应数目的存款金额……</span><br><span class="line">5、用户取款，银行卡退卡……</span><br><span class="line">6、……</span><br></pre></td></tr></table></figure><p>三、画图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ATM机取款正常流程</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/46.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作流程</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/47.png" alt="img"></p><h1 id="测试用例设计方法—错误推测法"><a href="#测试用例设计方法—错误推测法" class="headerlink" title="测试用例设计方法—错误推测法"></a>测试用例设计方法—错误推测法</h1><h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>错误推测法是指利用直觉和经验猜测出出错的可能类型，有针对性列举出程序中所有可能的错误和容易发生错误的情况，它是测试经验丰富的测试人员喜欢使用的一种测试用例设计方法。</p><ul><li><p>基本思想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本思想是列举出可能犯的错误或错误易发生的清单，然后根据清单编写测试用例；  </span><br><span class="line">这种方法很大程度上是凭经验进行的，</span><br><span class="line">即凭人们对过去所作测试结果的分析，对所揭示缺陷的规律性作直觉的推测来发现缺陷。</span><br></pre></td></tr></table></figure></li><li><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">项目紧任务急、时间不够，这时就不要按部就班的测试了，</span><br><span class="line">根据之前项目的经验，找到之前出错过的类似模块进行重点测试；</span><br><span class="line">  </span><br><span class="line">所有正常测试结束后，通过错误推断法再测试一些之前出过问题的模块。</span><br></pre></td></tr></table></figure></li></ul><p>要素共有三点，分别为：经验、知识、直觉。关于如何使用的问题，我们提炼出两点：</p><p>　　1. 列举出程序中所有可能有的错误和容易发生错误的特殊情况； 　　2. 根据他们选择测试用例。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li><p>针对删除操作</p><p>1.选择需要删除的数据字段。有时候系统会根据ID来删除，有时候系统会根据名称来删除，测试的时候应该多注意，一般要求按照ID来删除，因为根据名称来删除，名称可能会存在重名问题</p><p>2.应该限制重复删除。具体操作：利用网络传输以及服务器的延迟，多次单击“删除”按钮，经常在数据库中发现重复提交的数据</p><p>3.当删除的数据还有文件时，需要去验证存在数据库中的数据，以及硬盘下的文件是否都被同时删除</p><p>4.当数据被删除成功或者失败后，要有响应的信息提示</p></li><li><p>针对页面操作</p><p>1.页面链接检查：每一个链接是否都有对应的页面，并且页面之间切换正确</p><p>2.相关性检查：删除/增加一项会不会对其他项产生影响，如果产生影响，这些影响是否都正确</p><p>3.检查按钮的功能是否正确：如增、删、改、查等功能是否正确</p><p>4.重复提交表单：一条已经成功提交的记录，用IE回退后再提交，看看系统是否做了处理</p><p>5.多次IE回退：检查多次使用IE回退的情况，在有回退的地方，回退，回到原来页面，再回退，重复多次，看是否出错</p><p>6.快捷键检查：是否支持常用快捷键，如Ctrl+C、Ctrl+V、Backspace等，对一些不允许输入信息的字段，如选人、选日期对快捷方式是否也做了限制</p><p>7.回车键检查：在输入结束后直接回车键，看系统处理如何，能否报错</p><p>8.上传下载文件检查：上传下载文件的功能是否实现，上传文件是否能打开，对上传文件的格式有何规定，系统是否有解释信息，并检查系统是否能否做到</p><p>9.其他验证：在页面上图片的大小不宜太大，需要第三方软件支持时，应该给出必要的信息，比如需要jre的支持，但用户机器还没有安装jre，那么此时在页面上应该有显著的标志来提醒用户进行安装</p></li></ul><h1 id="测试用例设计方法-小结"><a href="#测试用例设计方法-小结" class="headerlink" title="测试用例设计方法-小结"></a>测试用例设计方法-小结</h1><h2 id="通常在确定测试方法时，有以下几条参考原则："><a href="#通常在确定测试方法时，有以下几条参考原则：" class="headerlink" title="通常在确定测试方法时，有以下几条参考原则："></a>通常在确定测试方法时，有以下几条参考原则：</h2><p>（1）拿到一个测试任务时，先关注它的主要功能和业务流程、业务逻辑是否正确实现，考虑使用场景法。</p><p>（2）需要输入数据的地方，考虑采用等价类划分法，包括输入条件和输出条件的等价划分，将无限测试变成有限测试。</p><p>（3）在任何情况下都必须采用边界值分析法。这种方法设计出的测试用例发现程序错误的能力最强。</p><p>（4）如果程序的功能说明中含有输入条件的组合情况，则一开始就应考虑选用因果图和判定表法。</p><p>（5）对于参数配置类的软件，需要考虑参数之间的组合情况，考虑使用正交排列法选择较少的组合方式（最少的测试用例获得最大的的测试覆盖率）。</p><p>（6）对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度。如果没有达到要求的覆盖标准，则应当再补充更多的测试用例。</p><p>（7）采用错误推断法再追加测试用例——依靠测试工程师的经验和智慧。</p><h2 id="测试用例的评审"><a href="#测试用例的评审" class="headerlink" title="测试用例的评审"></a>测试用例的评审</h2><ul><li>同行评审</li></ul><p>测试用例的检查方式有很多，同行评审是其中最敏捷的一种。 “个体和交互比过程和工具更有价值”，这强调了测试用例设计者之间的思想碰撞，通过探讨、协作来完成测试用例的设计。</p><ul><li>用户评审</li></ul><p>“顾客的协作比合同谈判更有价值”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果测试是对产品的批判，则顾客应该指最终用户或顾客代表（在内部可以是市场调查人员或相关领域专家）；</span><br><span class="line">如果测试被定义为对开发提供帮助和支持，那么顾客就是程序员。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论02</title>
      <link href="/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA02/"/>
      <url>/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA02/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h1><blockquote><p>1.等价类划分法</p><p>2.边界值法</p><p>3.判定表法</p><p>4.因果图法</p></blockquote><a id="more"></a><h2 id="用例的设计方法"><a href="#用例的设计方法" class="headerlink" title="用例的设计方法"></a>用例的设计方法</h2><p>我们做为测试人员最核心的基本的工作就是根据业务来书写测试用例完成测试。</p><p>但是测试用例的书写是有相应的设计方法的( 有套路 )</p><p>常用的用例设计方法：划分等价类法 、边界值法、判定表法、正交实验法，还有因果图法、场景法、状态迁移法、错误推断法………</p><ul><li>案例</li></ul><p>需求：一个加法计算器，允许输入的数值范围为[1,100]。</p><p>如何测试？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算两个1---100之间整数的和:</span><br><span class="line">穷举测试：</span><br><span class="line">1+2=3  1+3=4  1+4=5  1+5=6  ······  1+100=101</span><br><span class="line">100+1=101  100+2=102   100+3=103  ······   100+100=200</span><br></pre></td></tr></table></figure><h2 id="1、-等价类划分法"><a href="#1、-等价类划分法" class="headerlink" title="1、 等价类划分法"></a>1、 等价类划分法</h2><ul><li>等价类划分是一种典型的黑盒测试设计方法，使用该方法主要对测试项进行测试规格分析，得到用例，而不用对系统内部处理进行深入了解，它也是目前测试用例设计过程中使用最普遍的一种方法，采用等价类划分，是将系统的输入内容划分为若干部分，然后对每个部分选取少数代表性数据进行测试，这样可以避免穷举法产生的大量用例</li><li>定义:等价类是指某个输入内容的所有数据的集合，将所有数据集合理划分为若干等价类，在每个等价类中取一个数据作为测试的输入数据。这样就可以用少量具有代表性的测试数据取得较好的测试效果</li><li>等价类划分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、有效等价类:是指对于系统的规格说明来说是合理的，有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能或者性能要求</span><br><span class="line">2、无效等价类:是指对于系统的规格说明来说是不合理或者无意义的输入数据所构成的集合</span><br><span class="line">注意：设计测试用例时，要同时考虑这两种等价类，因为软件不仅要能接收合理的数据，也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性</span><br></pre></td></tr></table></figure><ul><li><p>案例</p></li><li><p>计算两个1-100之间整数的和</p><h3 id="专业分析设计步骤："><a href="#专业分析设计步骤：" class="headerlink" title="专业分析设计步骤："></a>专业分析设计步骤：</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.明确需求----&gt;如果是文字描述，先将文字描述转为图形</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/119.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.确定界面包含多少个功能</span><br><span class="line">3.针对每个功能确定有多少个输入</span><br><span class="line">4.确定每个输入的规则:</span><br><span class="line">    类型---&gt;数字</span><br><span class="line">    长度----&gt;无</span><br><span class="line">    取值范围---&gt;[1-100]</span><br><span class="line">    是否为空---&gt;否</span><br><span class="line">    是否重复---&gt;是</span><br><span class="line">    组成规则----&gt;无</span><br><span class="line">5.针对每个输入规则构造测试数据,形成等价类数据表</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/120.png" alt="img"></p><h3 id="2、等价类操作步骤"><a href="#2、等价类操作步骤" class="headerlink" title="2、等价类操作步骤"></a>2、等价类操作步骤</h3><ul><li>1、明确需求（如果是文字，转化为图形）</li><li>2、明确界面包含功能个数</li><li>3、针对每一个功能，明确输入的个数</li><li>4、确定每个输入的规则（类型、长度、取值范围、是否可以为空、是否可以重复、组成规则）</li><li>5、针对每一个输入规则构造测试数据</li><li><p>6、编写测试用例</p></li><li><p>需求练习1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQ账号： 6---10位自然数</span><br></pre></td></tr></table></figure></li><li><p>需求练习2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现有一个档案管理系统，容许用户通过输入年月对档案文件进行检索，系统对查询条件年月的输入限定为1990年1月~2049年12月，并规定：</span><br><span class="line">  日期由6位数字字符组成，前四位表示年，后两位表示月。</span><br><span class="line">现用等价类划分法设计测试用例，来测试程序的“日期检查功能”。</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、等价类划分总结"><a href="#3、等价类划分总结" class="headerlink" title="3、等价类划分总结"></a>3、等价类划分总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">规则：</span><br><span class="line">1.一个有效数据的测试用例尽可能包含最多有效等价类</span><br><span class="line">2.一个无效数据的测试数据只能包含一个无效等价类</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">    1.简单、高效</span><br><span class="line">    2.快速评估测试用例的数量（有效测试用例数+无效测试用例数）</span><br><span class="line">    3不用熟悉业务可快速设计测试用例</span><br><span class="line">缺点：</span><br><span class="line">    1.只考虑了独立输入的有效和无效，没有考虑输入之间的组合</span><br><span class="line">    2.数据随机选取，不一定发现Bug</span><br><span class="line"></span><br><span class="line">适用范围：只要存在输入的功能</span><br></pre></td></tr></table></figure><h1 id="测试用例设计方法—边界值法"><a href="#测试用例设计方法—边界值法" class="headerlink" title="测试用例设计方法—边界值法"></a>测试用例设计方法—边界值法</h1><h3 id="1-什么是边界值分析法"><a href="#1-什么是边界值分析法" class="headerlink" title="1.什么是边界值分析法"></a>1.什么是边界值分析法</h3><ul><li>边界值分析也是一种黑盒测试方法，是对等价类划分法的一种补充，由长期的测试工作经验得知，大量的错误是发生在输入或者输出的边界上。因此针对各种边界情况设计测试用例，可以查出更多的错误。</li><li>边界分析方法的理论基础，是假定大多数的错误是发生在各种输入条件的边界上，如果在边界附件的取值不会导致程序出错，那么其他的取值导致程序错误的可能性也很小</li><li>边界值分析使用的条件： 输入内容明确了取值范围、或者规定了值得个数</li></ul><p>思考：输入一个大于0小于100的整数，边界值在哪里？</p><ul><li><p>边值点定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、上点：边界上的点，如果域的边界是封闭的，上点就在域范围内，如果域的边界是开放的，上点在域范围外。</span><br><span class="line">2、离点：就是离上点最近的一个点，如果域的边界是封闭的，离点就在域范围外，如果域的边界是开放的，离点就在域范围内</span><br><span class="line">3、内点：顾名思义，就是在域范围内的任意一个点</span><br></pre></td></tr></table></figure></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/122.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上点、离点的确定和这个域的边界是开放还是封闭有关，不论边界是开放还是封闭，上点和离点总有一个在域内，另外一个在域外</span><br><span class="line">假设a是整数，a的边界描述是a大于0，是开放的，那么上点是0，离点是1，如果边界描述的是a&gt;=0，是封闭的，上点仍然是0，离点是-1</span><br></pre></td></tr></table></figure><ul><li>案例</li><li>计算两个1-100之间整数的和</li></ul><h3 id="2-专业分析设计步骤："><a href="#2-专业分析设计步骤：" class="headerlink" title="2.专业分析设计步骤："></a>2.专业分析设计步骤：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.明确需求----&gt;如果是文字描述，先将文字描述转为图形</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/119.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.确定界面包含多少个功能</span><br><span class="line">3.针对每个功能确定有多少个输入</span><br><span class="line">4.确定每个输入的规则:</span><br><span class="line">    类型---&gt;数字</span><br><span class="line">    长度----&gt;无</span><br><span class="line">    取值范围---&gt;[1-100]</span><br><span class="line">    是否为空---&gt;否</span><br><span class="line">    是否重复---&gt;是</span><br><span class="line">    组成规则----&gt;无</span><br><span class="line">5.针对每个输入规则构造测试数据,形成等价类数据表,追加边界数据（上点、离点）</span><br></pre></td></tr></table></figure><ul><li><p>需求练习1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQ账号： 6---10位自然数</span><br></pre></td></tr></table></figure></li><li><p>需求练习2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现有一个档案管理系统，容许用户通过输入年月对档案文件进行检索，系统对查询条件年月的输入限定为1990年1月~2049年12月，并规定：</span><br><span class="line">  日期由6位数字字符组成，前四位表示年，后两位表示月。</span><br><span class="line">现用等价类划分法设计测试用例，来测试程序的“日期检查功能”。</span><br></pre></td></tr></table></figure></li><li><p>需求练习3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对下图的用户名和密码写出所有的边界值</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/123.png" alt="img"></p></li></ul><h3 id="3-边界值法总结"><a href="#3-边界值法总结" class="headerlink" title="3.边界值法总结"></a>3.边界值法总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">1.边界上的缺陷更容易被发现</span><br><span class="line">2.不用熟悉业务可快速设计测试用例</span><br><span class="line">缺点：</span><br><span class="line">1.存在边界时才能使用</span><br><span class="line">使用范围：</span><br><span class="line">1.有输入参数，且输入类型或范围长度有边界时</span><br><span class="line">2.和等价类一起使用</span><br></pre></td></tr></table></figure><h1 id="测试用例设计方法—判定表法"><a href="#测试用例设计方法—判定表法" class="headerlink" title="测试用例设计方法—判定表法"></a>测试用例设计方法—判定表法</h1><h3 id="1-什么是判定表法"><a href="#1-什么是判定表法" class="headerlink" title="1.什么是判定表法"></a>1.什么是判定表法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">判定表示分析和表达多种输入条件下系统执行不同动作的工具。</span><br><span class="line">在程序设计发展初期，判定表就已经被当做编写程序的辅助工具了，它可以把</span><br><span class="line">复杂的逻辑关系和多种条件组合的情况表达的既具体又明确</span><br><span class="line"></span><br><span class="line">判断表通常由四个部分组成，如下图：</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/124.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.条件桩：列出了系统的所有输入，列出的输入次序无关紧要</span><br><span class="line">2.动作桩：列出了系统可能采取的操作，这些操作的排列顺序没有约束</span><br><span class="line">3.条件项：列出针对它左列输入的取值，在所有可能情况下的真假值</span><br><span class="line">4.动作项：列出在输入项的各种取值情况下应该采取的动作</span><br><span class="line">5.动作项和条件项一起，指出了在条件项的各种取值情况下应该采取的动作，在判定表中贯穿条件项和动作项的一列就是</span><br><span class="line">  一条规则，可以针对每个合法输入组合的规则设计用例进行测试</span><br><span class="line"></span><br><span class="line">对于判定表可以进行化简操作，化简工作是以合并相似规则为目标的。如果表中有两条或者多条规则具有相同的动作，</span><br><span class="line">并且其条件项之间存在极为相似的关系（只有一个不同时，说明不管该输入取任何值，输出都是一样的），我们可以</span><br><span class="line">将其合并，如下图</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/126.png" alt="img"></p><p><img src="../assets/126.png" alt="img"></p><ul><li><p>案例</p><ul><li>举例：若用户欠费或者停机，则不允许主被叫，表示为判定表如下：</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/127.png" alt="img"></p></li></ul><p>针对该判定表可以化简，第1列数据和第2列数据的动作完全相同，条件桩中只有条件2的取值不同，因此 可将第1/2列数据合并起来，化简后结果如下，每列数据就是一条测试用例，这样一共是3条测试用例</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/128.png" alt="img"></p><h3 id="2-判定表法设计步骤"><a href="#2-判定表法设计步骤" class="headerlink" title="2.判定表法设计步骤"></a>2.判定表法设计步骤</h3><ul><li>1、明确条件桩</li><li>2、明确动作桩</li><li>3、对条件桩进行全组合</li><li>4、明确每个组合对应的动作桩</li><li><p>5、设计测试用例，每列数据对应一条测试用例</p></li><li><p>需求练习1:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">订购单的检查，如果金额大于500元，又未过期，则发出批准单和提货单；</span><br><span class="line">如果金额大于500元，但过期了，则不发批准单；如果金额小于等于500元</span><br><span class="line">则不论是否过期都发出批准单和提货单，在过期的情况下还需要发出通知单。</span><br><span class="line"></span><br><span class="line">    请用判定表的方法对测试用例 进行设计</span><br></pre></td></tr></table></figure><ul><li>需求练习2:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果想对文件进行修改，输入的第一列字符必须是A/B,第二例字符必须是一个数字，如果</span><br><span class="line">第一列字符不正确，则给出信息L，如果第二列字符不正确，则给出信息M</span><br></pre></td></tr></table></figure><h3 id="3-判定表法总结："><a href="#3-判定表法总结：" class="headerlink" title="3.判定表法总结："></a>3.判定表法总结：</h3><p>\<figure class="highlight plain"><figcaption><span>1.充分考虑了输入条件间的组合，对组合情况覆盖充分</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>缺点：<br>1.条件过多时，造成判定表的规模庞大</p><p>适用范围：<br>1.输入之间有逻辑关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 测试用例设计方法---因果图法法</span><br><span class="line"></span><br><span class="line">### 1.什么是因果图法</span><br></pre></td></tr></table></figure></p><p>因果图用于描述系统的输入输出、以及输入和输出之间的因果关系、输入和输入之间的约束关系。<br>因果图和判定表两种方法在实际使用中结合紧密，往往同时使用，对于一些简单的系统或者输入<br>与输出已经非常明确的系统，判定表可以单独使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 因果关系</span><br></pre></td></tr></table></figure></p><pre><code>拿破仑说：“  失一个钉子，坏了一只蹄铁；   坏了一只蹄铁，折了一匹战马；   折了一匹战马，伤了一位骑士；  伤了一位骑士，输了一场战斗；  输了一场战斗，亡了一个帝国。””</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  **这就是因果关系**</span><br><span class="line"></span><br><span class="line">- 实际测试工作中因果关系是描述的以下关系</span><br><span class="line"></span><br><span class="line">  1. 输入与输出之间的因果关系---&gt;因果图的表示中输入与输出间的因果关系有四种</span><br><span class="line"></span><br><span class="line">     1) 恒等关系：当输入内容时，会产生对应输出，当不输入或者输入不发生时，不会有输出</span><br><span class="line"></span><br><span class="line">     2）非关系：与恒等关系相反</span><br><span class="line"></span><br><span class="line">     3）或者关系：输入的内容有多个时，只要一个输入发生，就会有输出</span><br><span class="line"></span><br><span class="line">     4）与关系：输入的内容有多个时，只有所有输入都发生时，才会有对应输出</span><br><span class="line"></span><br><span class="line">     用图形表示以上四种关系如下：</span><br><span class="line"></span><br><span class="line">  ![img](file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/129.png)</span><br><span class="line"></span><br><span class="line">  1. 输入与输入之间的约束关系-----&gt;因果图的表示中输入与输入之间的约束关系也有四种</span><br><span class="line"></span><br><span class="line">     1）异：所有输入中最多一个输入发生</span><br><span class="line"></span><br><span class="line">     2）或：所有输入中至少一个输入发生</span><br><span class="line"></span><br><span class="line">     3）唯一：所有输入中有且只有一个输入条件发生</span><br><span class="line"></span><br><span class="line">     4）要求：所有输入中只要有一个输入发生，则其他输入也会发生</span><br><span class="line"></span><br><span class="line">     用图形表示以上四种关系如下：</span><br><span class="line"></span><br><span class="line">  ![img](file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/130.png)</span><br><span class="line"></span><br><span class="line">### 2.使用因果图法设计测试用例</span><br><span class="line"></span><br><span class="line">- 步骤1：标识输入和输出</span><br></pre></td></tr></table></figure><pre><code>分析测试内容，找出其中的输入和输出并标识出来，其中要注意以下几点：    1）输入只涉及2种取值的，可以只作为一个标识出来，如果输入项涉及多种取值的，每个取值需要作为一个输入标识出来    2）标识可以自己确定，但是输入和输出需要独立的标识</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 步骤2：画出因果图</span><br></pre></td></tr></table></figure><pre><code>分析输入和输出之间的因果关系，输入和输入之间的约束关系，根据这些关系，画出因果图</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 步骤3：将因果图转换为判定表</span><br></pre></td></tr></table></figure><pre><code>1.将输入和输出分别写入条件桩和动作桩，并在条件项中填写输入的组合2.根据因果图中的输入条件约束关系，对不可能出现的输入组合，在动作项上作出删除标记3.根据因果图中的输入与输出的因果关系，在动作项上标出对应的动作结果</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 步骤4：生产测试用例</span><br><span class="line"></span><br><span class="line">### 3.因果图设计用例案例</span><br></pre></td></tr></table></figure><p>根据上面的测试基本步骤，对下面的例子进行因果图测试<br>        如想对文件进行修改，输入的第一列字符必须是A或者B，第二列字符必须是一个数字，如果 第一列字符不正确<br>        则给出信息L，如果第二列字符不正确，则给出信息M<br><code>`</code></p><ul><li>使用因果图对该题分析步骤：</li></ul><p>第一步：标识输入和输出—–&gt;分析以上需求后，可以明确的把原因和结果分开（或者说输入和输出） 原因： 结果 1.第一列字符为A 21.修改文件 2.第一列字符为B 22.给出信息L 3.第二列字符为一个数字 23.给出信息M</p><p>第二步：画因果图—-&gt;需求中很明确的给出原因和结果之间的对应关系，将原因和结果根据他们之间的对应关系用逻辑符号连接起来，如下图所示,左边表示原因，右边表示结果，编号11的节点是导出结果的进一步原因</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/131.png" alt="img"></p><p>第三步：考虑到输入1和输入2不可能同时为Y（即第一列不能同时为A和B），我们在图上需要对其添加E约束，这样就有了具有约束的因果图，如下图所示</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/132.png" alt="img"></p><p>第四步：把因果图转换成判定表如下：</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/133.png" alt="img">由于原因1和原因2不可能同时为Y，故第1、2属于不可能发生的组合，所以编写测试用例时可以不用考虑</p><p>第五步：编写测试用例即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试理论01</title>
      <link href="/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA01/"/>
      <url>/2019/08/13/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1.软件测试的基础理论</p><p>2.软件质量</p><p>3.常见软件架构</p><p>4.软件开发过程模型</p><p>5.测试模型</p><p>6.软件测试分类</p><p>7.测试用例</p></blockquote><a id="more"></a><h1 id="软件测试的基础理论"><a href="#软件测试的基础理论" class="headerlink" title="软件测试的基础理论"></a>软件测试的基础理论</h1><h2 id="软件测试的目的："><a href="#软件测试的目的：" class="headerlink" title="软件测试的目的："></a>软件测试的目的：</h2><p>是想以最少的人力，物力和时间找出软件中潜在的各种错误与缺陷，通过修正各种错误和缺陷提高软件质量， 回避软件发布后由于潜在的软件缺陷和错误造成的隐患以及带来的商业风险。</p><p>简单的说，软件测试是为了找到软件中隐藏起来的bug，修复之后避免商业风险。</p><h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>使用人工和自动手段来运行或测试某个系统的过程，其目的在于</p><p><strong>检验它是否满足规定的需求</strong>或<strong>弄清楚预期结果与实际结果之间的差别</strong>。</p><h2 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h2><h4 id="软件测试的原则："><a href="#软件测试的原则：" class="headerlink" title="软件测试的原则："></a>软件测试的原则：</h4><ol><li>测试证明软件存在缺陷：我们的测试工作只能证明当前软件是有缺陷而不能证明它没有缺陷</li><li>不能执行穷尽测试：具体的测试操作不可能将所有的情况都一一逻列出来，所以测试工作肯定有终止的时候</li><li>测试应当尽早介入：一般不要在开发完成之后才执行测试，这样不利于缺陷的尽早发现</li><li>缺陷存在群集现象：对于一款软件来说核心的功能只占20%，所以在测试的时候我们会花更多的时间去专门测试这些功能，因此它里面缺陷暴露的可能就会更大一些，我们就称之为缺陷群集</li><li>测试操作依赖于某于测试环境</li><li>杀虫剂现象：不要过多使用同一条测试案例来对软件进行问题查找 ，因为软件会产生“抗 性”</li><li>不存在缺陷的谬论：任何的软件不可能是完美的。</li></ol><h2 id="软件测试的基本流程"><a href="#软件测试的基本流程" class="headerlink" title="软件测试的基本流程"></a>软件测试的基本流程</h2><h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h4><ul><li>这个步骤的核心就是理清楚我们需要测试的点是什么。</li><li>需求的来源：需求规格说明书 、同类产品分析、API文档、个人经验</li></ul><h4 id="2-设计用例"><a href="#2-设计用例" class="headerlink" title="2. 设计用例"></a>2. 设计用例</h4><ul><li>用例：具体的我们就可以理解为是用户对于软件使用的一个完整操作流程，里面会包括测试什么 和 怎么样去测 （ …… ）</li></ul><h4 id="3-评审用例-将我们设计好的用例进行适当的删除或者增。"><a href="#3-评审用例-将我们设计好的用例进行适当的删除或者增。" class="headerlink" title="3. 评审用例: 将我们设计好的用例进行适当的删除或者增。"></a>3. 评审用例: 将我们设计好的用例进行适当的删除或者增。</h4><h4 id="4-配置环境"><a href="#4-配置环境" class="headerlink" title="4. 配置环境"></a>4. 配置环境</h4><ul><li>所谓的环境指的就是软件运行需要依赖的环境。要求测试人员都需要具备配环境的能力。</li><li>这里的环境我们一般包括四个方法：操作系统 数据库 服务器软件 当前软件底层代码执行所需要的环境( python java c php js html……【对于环境配置来说网上有N种一键式集成开发环境包】 )</li></ul><h4 id="5-执行用例："><a href="#5-执行用例：" class="headerlink" title="5. 执行用例："></a>5. 执行用例：</h4><ul><li>在执行用例之初我们会做一个冒烟测试。所谓的冒烟测试指的就是在最快的时间内对软件的最基本功能和整体流程进行验证。</li><li>如果冒烟测试通过验让那么我们才会具体详细的展示全面测试，如果不通过那么就会直接返给开发重新等待提交下一个版本。</li></ul><h4 id="6-缺陷跟踪和回归测试"><a href="#6-缺陷跟踪和回归测试" class="headerlink" title="6. 缺陷跟踪和回归测试"></a>6. 缺陷跟踪和回归测试</h4><ul><li>当我们通过测试操作发现一个缺陷之后我们将它交给相应的人员进行处理，此后我们需要对它进行跟踪，当修复完成之后我们还需要对这个结果行验证测试，称之为回归测试</li></ul><h4 id="7-输出测试报告"><a href="#7-输出测试报告" class="headerlink" title="7. 输出测试报告"></a>7. 输出测试报告</h4><ul><li>将整个测试过程当中产生的相关数据通过可视化的格式输出方便别人查看</li></ul><h4 id="8-测试结束"><a href="#8-测试结束" class="headerlink" title="8. 测试结束"></a>8. 测试结束</h4><ul><li>将整个测试流程中产生的文档或者数据进行整理和保存</li></ul><h1 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h1><h4 id="所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由-ISO-国际标准化组织-标准制定组织规定了一套质量标准，其中有六大特性"><a href="#所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由-ISO-国际标准化组织-标准制定组织规定了一套质量标准，其中有六大特性" class="headerlink" title="所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由 ISO(国际标准化组织) 标准制定组织规定了一套质量标准，其中有六大特性"></a>所谓的软件质量我们就认为是用来衡量一个软件好与坏的标准，目前来说在我们的测试行业就一个由 ISO(国际标准化组织) 标准制定组织规定了一套质量标准，其中有六大特性</h4><ul><li>功能性：软件具有满足用户显示或者隐式功能的能力。</li><li>可靠性：软件实现了自已规定的功能</li><li>易用性：软件在使用上容易上手 易于学习 吸引用户的能力</li><li>效率性：类似于软件的性能考虑</li><li>可维护性：在规定条件和规定时间内使用规定的工具修改规定功能的能力。</li><li>可移植性：要求软件具有可以从一个平台移动到另外一个平台上使用的能力</li></ul><h1 id="常见软件架构"><a href="#常见软件架构" class="headerlink" title="常见软件架构"></a>常见软件架构</h1><h4 id="当前市面上流行的二种架构分别是-B-S-C-S-【-browser-clientsr-server-】"><a href="#当前市面上流行的二种架构分别是-B-S-C-S-【-browser-clientsr-server-】" class="headerlink" title="当前市面上流行的二种架构分别是 B/S C/S 【 browser clientsr server 】"></a>当前市面上流行的二种架构分别是 B/S C/S 【 browser clientsr server 】</h4><ul><li>Bs:就是浏览器—服务器模型 cs: 就是客户端—服务器模型</li></ul><h4 id="bs-和-cs-比较"><a href="#bs-和-cs-比较" class="headerlink" title="bs 和 cs 比较"></a>bs 和 cs 比较</h4><ul><li>标准：对于 BS架构来说无论是浏览器还是服务器都是现成的软件供我们去使用，而CS架构中的客户端一般都由开发者自定义生成，所以相对来说 BS开发要标准一些。</li><li>效率：因为BS架构当中所有的数据处理操作都发生服务器端而CS 的客户端是可以来分担一些服务器数据存放的，因此相对来说 CS 的处理效率会高一些</li><li>升级：BS架构只需要将服务器进行更新那么前台页面会自动的刷新而CS架构如果想要升级就必须将二端都重新制定，下载安装才可以使用。</li><li>安全性：相对于CS架构来说 BS 的安全性会低一些。</li><li>开发成本：因为浏览器不需要我们开发，所以我们认为 CS的开发成本相对较高。</li></ul><p>注：常见主流浏览器有火狐Firefox、谷歌Chrome、IE浏览器、Safari浏览器、opera欧朋浏览器</p><h1 id="软件开发过程模型"><a href="#软件开发过程模型" class="headerlink" title="软件开发过程模型"></a>软件开发过程模型</h1><h2 id="什么是开发过程模型"><a href="#什么是开发过程模型" class="headerlink" title="什么是开发过程模型"></a>什么是开发过程模型</h2><ul><li>在软件开发的几十年实践中，人们总结了很多软件开发模型用来描述和表示一个复杂的开发过程，如：瀑布模型、快速原型模型等</li><li>软件测试与软件的开发模式有着紧密的联系，作为一名测试人员，应该充分理解软件的开发模式，一遍找准自己在其中的位置，从而发挥自身的价值。</li></ul><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)、是线性模型的一种，在所有模型中占有重要地位，是所有其他模型的一个基础</span><br><span class="line"></span><br><span class="line">(2)、每一个阶段执行一次，按线性顺序进行软件开发。</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/2.png" alt="img"></p><ul><li>注意: 测试的切入点：</li><li>测试阶段处于软件实现后，必须在代码完成后留出足够的时间给测试活动，否则将导致测试不充分，很多问题到项目后期才暴露。</li></ul><h4 id="瀑布模型的优缺点"><a href="#瀑布模型的优缺点" class="headerlink" title="瀑布模型的优缺点"></a>瀑布模型的优缺点</h4><p>瀑布模式<strong>所有一切都有完整细致的说明</strong>。当软件提交到测试小组时，所有细节都已确定并有文档记录，而且实现在软件之中。由此，测试小组得以制定精确的计划和进度。 然而，这个优点也带来一个巨大的缺点。因为<strong>测试仅在最后进行</strong>，所以一些根本性问题可能出现在早期，但是直到准备发布产品时才可能发现。</p><ul><li><p>简单的总结下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">(1)、开发的各个阶段比较清晰。</span><br><span class="line">(2)、当前一阶段完成后，只需关注后续阶段。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缺点：</span><br><span class="line">(1) 依赖于早期的需求调查，不适应需求的变化。</span><br><span class="line">(2) 风险往往延至后期才显露，失去及早纠正的机会。</span><br><span class="line">(3) 前面未发现的错误会传递并扩散到后面的阶段，可能导致项目失败。</span><br></pre></td></tr></table></figure><p>采用瀑布模式的项目从最初的构思到最终产品要经过一系列步骤。每一个步骤结束时，项目小组组织审查，并决定是否进入下一步。如果项目未准备好进入下一步，就停滞下来直到准备好。 关于瀑布模式有三点需要强调：</p><p>瀑布模式非常【强调产品的定义】。注意，开发或者代码编制阶段只是其中单独的一块。 瀑布模式【各步骤是分立的、没有交叉】。 瀑布模式【无法回溯】。一旦进入某一步骤，就要完成该步骤的任务，然后才能向下继续—无法回溯。</p></li></ul><h2 id="快速原型模型-了解"><a href="#快速原型模型-了解" class="headerlink" title="快速原型模型(了解)"></a>快速原型模型(了解)</h2><ul><li><p>在开发真实系统之前，构造一个原型，在该原型的基础上，逐渐完成整个系统的开发工作。</p></li><li><p>第一步是建造一个快速原型，实现用户与系统的交互，用户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足用户的要求，开发人员可以确定用户的真正需求是什么。</p></li><li><p>第二步是在第一步的基础上开发出用户满意的软件产品。</p></li><li><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/3.png" alt="img"></p><p>例如，客户需要一个ATM机软件，可以先设计一个仅包含刷卡、密码检测、数据输入和账单打印的原型软件提供给客户，此时还不包括网络处理与数据库存取以及数据应急、故障处理等服务。</p></li></ul><h4 id="快速原型模型的优缺点"><a href="#快速原型模型的优缺点" class="headerlink" title="快速原型模型的优缺点"></a>快速原型模型的优缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">(1)克服瀑布模型的缺点，更好地满足用户的需求并减少由于软件需求不明确带来的项目开发风险。</span><br><span class="line">缺点:</span><br><span class="line">(1)不适合大型系统的开发(适合开发小型的、灵活性高的系统)。</span><br><span class="line">(2)前提要有一个展示型的产品原型，因此在一定程度上可能会限制开发人员的创新。</span><br></pre></td></tr></table></figure><h1 id="软件测试-amp-软件工程"><a href="#软件测试-amp-软件工程" class="headerlink" title="软件测试&amp;软件工程"></a>软件测试&amp;软件工程</h1><p>软件测试与软件工程息息相关，软件测试是软件工程组成中不可或缺的一部分。</p><p>在软件工程、项目管理、质量管理得到规范化应用的企业，软件测试也会进行得比较顺利，软件测试发挥的价值也会更大。</p><p>要关注软件工程、质量管理以及配置管理与软件测试的关系；在不同的开发模式下，如何进行软件测试。</p><h2 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h2><h2 id="什么是测试模型"><a href="#什么是测试模型" class="headerlink" title="什么是测试模型"></a>什么是测试模型</h2><ul><li>随着测试过程的管理和发展，测试人员通过大量的实践，从而总结出了不少测试模型，如常见的V模型，W模型，H模型等。这些模型与开发紧密结合，对测试活动进行了抽象，成为了测试过程管理的重要参考依据。</li></ul><h2 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h2><p>V模型是最具有代表意义的测试模型，最早是由Paul Rook在20世纪80年代后期提出，由英国国家计算机中心文献中发布，旨在改进软件开发的效率和效果；</p><p>V模型推出之前，人们通常把测试过程作为在需求分析、概要设计、详细设计、编码全部完成之后的一个阶段，V模型在这个时候推出，就是为了改变之前行业的普遍认识。</p><p>V模型本身是软件开发中瀑布模型的变种，它反映了测试活动与分析和设计的关系。</p><p>V模型标明了测试过程中本身存在的不同阶段，从左到右，描述了开发过程和测试过程间的阶段对应关系。</p><ul><li>V模型示意图： <img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/5.png" alt="img"></li></ul><h4 id="V模型每个阶段含义"><a href="#V模型每个阶段含义" class="headerlink" title="V模型每个阶段含义"></a>V模型每个阶段含义</h4><ul><li>需求分析：用户需求、业务需求、需求规格说明书</li><li>概要设计：系统架构、模块划分、模块与模块之间的接口。</li><li>详细设计：模块内部实现的逻辑和方法</li><li>编码：实现上面的设计</li><li>单元测试：检测代码的开发是否符合详细设计的要求。</li><li>集成测试：检测此前测试过的各组成部分是否能完好地结合到一起。</li><li>系统测试：拿到产品后，检测一下最基本的功能和业务流程是否能走通，检测产品的安全性和性能等方面的测试</li><li>验收测试：检测产品是否符合最终用户的需求</li></ul><h3 id="V模型的优缺点"><a href="#V模型的优缺点" class="headerlink" title="V模型的优缺点"></a>V模型的优缺点</h3><p>优点:</p><p>(1)测试V模型即包含了底层测试又包含了高层测试；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">底层测试：检验源代码质量的测试，如：单元测试；</span><br><span class="line">高层测试：检验整个系统的需要，如：系统测试；</span><br></pre></td></tr></table></figure><p>(2)V模型清楚地标识出了软件开发的阶段。</p><p>(3)它采用自顶向下逐步求精的方式把整个开发过程分成不同的阶段，每个阶段的工作都很明确，因此便于控制开发过程。</p><p>缺点:</p><p>(1)V模型一大缺点正是它自身的顺序性所导致的。到了测试阶段，程序已经完成，错误已经产生，很多前期的错误一直到测试阶段才发现，甚至无法发现，往往无从修改了。 (2)同时实际的开发过程中，在需求阶段很难把用户的需求完全明确下来，因此，当需求变更时将会导致阶段反复，而且都要重复需求、设计、编码、测试等过程，返工量非常大，模型灵活性比较低。</p><h2 id="认识W模型"><a href="#认识W模型" class="headerlink" title="认识W模型"></a>认识W模型</h2><ul><li>IEEE std1012-1998《软件验证和确认（V&amp;V）》的原则中提出了在软件的需求和设计阶段也应有测试活动，并且提出了相应的原则；</li><li>W模型由Evolutif公司提出：开发一个V，测试一个V，组合的W模型；</li><li>测试伴随着整个软件开发周期，并且测试的对象不仅仅是程序，需求和设计同样要测试。</li><li>W模型示意图 <img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/6.png" alt="img"></li></ul><h3 id="W模型的优缺点"><a href="#W模型的优缺点" class="headerlink" title="W模型的优缺点"></a>W模型的优缺点</h3><p>优点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)开发强调测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求和概要设计同样要测试；</span><br><span class="line">(2)更早地接入测试，可以发现开发初期的缺陷，那么可以用更加低的成本进行缺陷修复。</span><br><span class="line">(3)同样是分阶段的工作，便于控制项目过程。</span><br></pre></td></tr></table></figure><p>缺点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)对于当前很多项目，在执行的过程中根本不产生文档，那么W模型基本无法适用；</span><br><span class="line">(2)使用起来技术复杂度很高，对于需求和设计的测试要求很高，实践起来困难。</span><br></pre></td></tr></table></figure><h2 id="认识H模型（了解）"><a href="#认识H模型（了解）" class="headerlink" title="认识H模型（了解）"></a>认识H模型（了解）</h2><ul><li>H模型诞生背景</li></ul><p>人们发现虽然软件开发中需求、设计、编码等活动被分阶段执行、但是实践中，他们并不是完全串行的，它们之间更多时候是交叉进行的，更多的是迭代执行。 为了解决上面的问题，有专家专门提出了H模型，它将测试活动完全独立出来，形成一个完全独立的流程，同时将测试准备和测试执行也清晰表现出来。</p><h3 id="H模型测试流程"><a href="#H模型测试流程" class="headerlink" title="H模型测试流程"></a>H模型测试流程</h3><p>(1)测试准备:所有测试执行活动的准备；判断是否到测试就绪点； (2)测试就绪点:测试准入准则，即是否可以开始执行测试的条件； (3)测试执行:具体的执行测试的程序。</p><ul><li><p>其他流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体开发中的流程,如：设计流程</span><br></pre></td></tr></table></figure></li><li><p>H模型示意图</p></li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/7.png" alt="img"></p><h3 id="H模型优缺点"><a href="#H模型优缺点" class="headerlink" title="H模型优缺点"></a>H模型优缺点</h3><p>优点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)开发的H模型揭示了软件测试除测试执行外，还有很多工作；</span><br><span class="line"></span><br><span class="line">(2)软件测试完全独立，贯穿整个生命周期，且与其他流程并发进行；</span><br><span class="line"></span><br><span class="line">(3)软件测试活动可以尽早准备、尽早执行，具有很强的灵活性；</span><br><span class="line"></span><br><span class="line">(4)软件测试可以根据被测物的不同而分层次、分阶段、分次序的执行，同时也是可以被迭代的。</span><br></pre></td></tr></table></figure><p>缺点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)管理型要求高：由于模型很灵活，必须要定义清晰的规则和管理制度，否则测试过程将非常难以管理和控制；</span><br><span class="line"></span><br><span class="line">(2)技能要求高：H模型要求能够很好的定义每个迭代的规模，不能太大也不能太小；</span><br><span class="line"></span><br><span class="line">(3)测试就绪点分析困难：测试很多时候，你并不知道测试准备到什么时候是合适的，</span><br><span class="line">    就绪点在哪里，就绪点的标准是什么，这就对后续的测试执行的启动带来很大困难；</span><br><span class="line"></span><br><span class="line">(4)对于整个项目组的人员要求非常高：在很好的规范制度下，大家都能高效的工作，否则容易混乱。</span><br><span class="line">    例如：你分了一个小的迭代，但是因为人员技能不足，使得无法有效完成，那么整个项目就会受到很大的干扰。</span><br></pre></td></tr></table></figure><h1 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h1><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/8.png" alt="img"></p><h2 id="按测试阶段分类"><a href="#按测试阶段分类" class="headerlink" title="按测试阶段分类"></a>按测试阶段分类</h2><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>又称模块测试，针对软件设计中的最小单位-程序模块，进行正确性检查的测试工作。单元测试需要从程序内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</li><li>单元定义:C中指一个函数，Java中指一个类，在图形化的软件中，单元一般指一个窗口，1个菜单。</li></ul><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/9.png" alt="img"></p><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p>又叫组装测试，通常在单元测试的基础上，将所有程序模块进行有序的、递增的测试。重点测试不同模块的接口部分。</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/10.png" alt="img"></p><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul><li>指的是将整个软件系统看为一个整体进行测试，包括对功能、性能、以及软件所运行的软硬件环境进行测试。</li><li>系统测试在系统集成完毕后进行测试，前期主要测试系统的功能是否满足需求，后期主要测试系统运行的性能是否满足需求，以及系统在不同的软硬件环境中的兼容性等。</li></ul><h2 id="按是否查看源代码"><a href="#按是否查看源代码" class="headerlink" title="按是否查看源代码"></a>按是否查看源代码</h2><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><ul><li>又称数据驱动测试，完全不考虑程序内部结构和内部特性，注重于测试软件的功能需求，只关心软件的输入数据和输出数据。</li><li><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/11.png" alt="img"></li></ul><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>指的是把盒子打开，去研究里面的源代码和程序结构。</p><ul><li><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/12.png" alt="img"></li></ul><h4 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h4><p>灰盒测试，是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p><h2 id="详细了解黑盒测试"><a href="#详细了解黑盒测试" class="headerlink" title="详细了解黑盒测试"></a>详细了解黑盒测试</h2><h4 id="黑盒测试的分类"><a href="#黑盒测试的分类" class="headerlink" title="黑盒测试的分类"></a>黑盒测试的分类</h4><ul><li>功能测试</li></ul><blockquote><p>是黑盒测试的一方面，它检查实际软件的功能是否符合用户的需求。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">逻辑功能测试</span><br><span class="line">界面测试</span><br><span class="line">易用性测试</span><br><span class="line">安装测试</span><br><span class="line">兼容性测试</span><br></pre></td></tr></table></figure><ul><li>性能测试</li></ul><blockquote><p>是软件测试的高端领域，性能测试工程师的待遇和白盒测试工程师不相上下，通常我们所说的高级软件测试工程师一般就是指性能测试或是白盒测试工程师。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间性能（事务响应时间等）</span><br><span class="line">空间性能（系统资源消耗）</span><br><span class="line">一般性能测试</span><br><span class="line">稳定性测试</span><br><span class="line">负载测试：通过负载测试来确定在各种工作负载下，系统各项性能指标的变化情况。</span><br><span class="line">压力测试：通过确定一个系统的瓶颈或者刚好不能接受的性能点，来获得系统能够提供的最大服务级别。</span><br></pre></td></tr></table></figure><ul><li>黑盒测试能发现以下几类错误:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">功能不对或功能遗漏。</span><br><span class="line">界面错误。</span><br><span class="line">数据库访问或者处理错误。</span><br><span class="line">性能问题。</span><br><span class="line">黑盒测试的优点:</span><br><span class="line">简单高效</span><br><span class="line">适用于任何项目</span><br><span class="line">黑盒测试的缺点:</span><br><span class="line">介入时间晚</span><br></pre></td></tr></table></figure><h2 id="按是否运行分类"><a href="#按是否运行分类" class="headerlink" title="按是否运行分类"></a>按是否运行分类</h2><h4 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h4><ul><li>指不实际运行被测软件，而只是静态地检查程序代码、界面或文档中可能存在的错误过程。</li></ul><h4 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h4><ul><li>是指实际运行被测程序，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程。</li></ul><h2 id="验收测试（其他分类）"><a href="#验收测试（其他分类）" class="headerlink" title="验收测试（其他分类）"></a>验收测试（其他分类）</h2><ul><li>α测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alpha 是内测版本，即现在所说的CB，此版本表示该软件仅仅是一个初步完成品, </span><br><span class="line">通常只在软件开发者内部交流, 也有很少一部分发布给专业测试人员。</span><br><span class="line">一般而言, 该版本软件的bug 较多, 普通用户最好不要安装。</span><br></pre></td></tr></table></figure><ul><li>β测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Beta是公测版本，是对所有用户开放的测试版本。该版本相对于α 版已有了很大的改进,消除了严重的错误, 但还是存在着一些缺陷,需要经过大规模的发布测试来进一步消除。</span><br><span class="line">这一版本通常由软件公司免费发布, 用户可从相关的站点下载。</span><br><span class="line">通过一些专业爱好者的测试, 将结果反馈给开发者, 开发者们再进行有针对性的修改。该版本也不适合一般用户安装。</span><br></pre></td></tr></table></figure><ul><li>γ测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gamma版本，指的是软件版本正式发行的候选版。</span><br><span class="line">该版本已经相当成熟了, 与即将发行的正式版相差无几, 成为正式发布的候选版本。</span><br></pre></td></tr></table></figure><ul><li>软件正式版本推出之前的几个版本, 需要有人测试一下, 看看是不是有问题。在开发该软件的公司内部的由该公司内部人员测试的称为: Alpha 测试, Alpha 测试主要看有没有功能缺失或系统错误, Alpha 测试完后一般不会有大问题了。然后把软件拿给用户测试,称为: beta 测试, 主要是看用户对软件外观、使用方便等的反应。这么多的测试版一方面为了最终产品尽可能地满足用户的需要, 另一方面也尽量减少了软件中的bug。然后做过一些修改, 成为正式发布的候选版本时, 叫做gamma( 现在叫做RC - Release Candidate) 。</li><li>简单来说，阿尔法测试主要是测试人员在开发环境下的测试，贝塔测试是在实际环境中的测试，或者公司内部人员在模拟真实环境中的测试。</li></ul><h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h2><h4 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。</span><br></pre></td></tr></table></figure><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">软件回归：回归测试是指在发生修改之后重新测试先前的测试以保证修改的正确性</span><br><span class="line">缺陷回归：开发人员修复测试人员提交的缺陷之后测试人员进行回归测试，确认缺陷是否被成功修复</span><br></pre></td></tr></table></figure><h4 id="随机测试-探索性测试"><a href="#随机测试-探索性测试" class="headerlink" title="随机测试(探索性测试)"></a>随机测试(探索性测试)</h4><p>随机测试主要是对被测软件的一些重要功能进行复测，也包括测试那些当前的测试用例没有覆盖到的部分。另外，对于软件更新和新增加的功能要重点测试。重点对一些特殊点情况点、特殊的使用环境、并发性、进行检查。尤其对以前测试发现的重大Bug，进行再次测试，可以结合回归测试一起进行。</p><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><p>QQ我们经常在用，那么如果让我们来测试QQ的登录界面，如何去测试呢？</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/13.png" alt="img"></p><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><p>将软件测试的行为活动，作为一个科学化的组织规划。<br>为实施测试而向被测试系统提供的<strong>输入数据、操作或各种环境设置以及期望结果</strong>的一个特定的集合。<br>解决<strong>要测什么、怎么测和如何衡量</strong>的问题</p><p>元素： 用例编号、用例标题、预置条件、 优先级、详细步骤、输入数据、预期结果、实际结果等</p><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/14.png" alt="img"></p><h4 id="测试用例编号"><a href="#测试用例编号" class="headerlink" title="测试用例编号"></a>测试用例编号</h4><p>字符和数字组合成的字符串，用例编号应具有唯一性、易识别 没有统一的命名规则，每家企业会有所不同 可以用A-B-C-D的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A：项目名称</span><br><span class="line">B：功能名称</span><br><span class="line">C：测试类型</span><br><span class="line">D：编号</span><br></pre></td></tr></table></figure><p>例：QQ-登录-系统测试-001</p><h4 id="用例的元素"><a href="#用例的元素" class="headerlink" title="用例的元素"></a>用例的元素</h4><ul><li><p>必要元素</p><p>用例标题：说明该条用例测试哪个点，要测什么</p><p>优先级：用来标识当前的用例执行的优先级。</p><p>操作步骤：执行当前测试用例需要经过的操作步骤，需要明确的给出一个步骤的描述，测试用例执行人员可以根据该步骤完成测试用例执行。</p><p>预期结果：当前测试用例的预期输出结果，包括返回值内容，界面的响应结果，输出结果的规则符合度等。</p></li><li><p>非必要元素</p><p>预置条件：执行当前测试用例需要的前提条件，如果这些前提条件不满足，则后面测试步骤无法进行或无法得到预期结果。</p><p>实际结果：在用例设计阶段不写</p><p>设计者：设计测试用例的人</p><p>设计时间：设计的日期</p><p>执行状态：未执行、执行失败、执行通过、未执行完毕、无效的等</p></li></ul><h4 id="测试用例的优缺点"><a href="#测试用例的优缺点" class="headerlink" title="测试用例的优缺点"></a>测试用例的优缺点</h4><p>优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">组织性:避免盲目测试，提高测试效率</span><br><span class="line">功能覆盖：确保客户需要的功能不被遗漏</span><br><span class="line">重复性 ：不同版本软件重复使用 </span><br><span class="line">跟踪 ：统计测试用例，通过和失败的比例，跟踪缺陷多的模块</span><br><span class="line">测试确认 ：高风险程序，确认测试按照计划进行</span><br></pre></td></tr></table></figure><p>缺点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">没有清晰的和简明的规格，测试用例是很难设计的   </span><br><span class="line">测试人员容易被测试用例的规范步骤误导，思维受限  </span><br><span class="line">需求变更后用例难于及时更新，从而影响覆盖率，维护成本加大  </span><br><span class="line">为了能构建高规格的测试用例，太过醉心用例设计  </span><br><span class="line">用例需要不断维护，复用成本加大</span><br></pre></td></tr></table></figure><h4 id="用例的设计原则"><a href="#用例的设计原则" class="headerlink" title="用例的设计原则"></a>用例的设计原则</h4><p>唯一性：要求用例的描述明确目的唯一，任何人通过当前用例得到的结果应该是唯一的。</p><p>简洁性：用例的描述需要简洁明了不要使用模糊性话语。</p><p>单一性：一条用例只测一个点。</p><h2 id="用例案例：手机充电"><a href="#用例案例：手机充电" class="headerlink" title="用例案例：手机充电"></a>用例案例：手机充电</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不一定要拘泥于一种用例模板格式</span><br><span class="line">可以采用简单的数据表的格式来编写</span><br></pre></td></tr></table></figure><p><img src="file:///D:/software%20test/%E4%BC%A0%E6%99%BA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%951%E6%9C%9F/%E5%9F%BA%E7%A1%80%E7%8F%AD/%E7%AC%AC%E4%BA%8C%E9%83%A8%EF%BC%88%E5%85%A8%EF%BC%89/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AF%BE%E4%BB%B6/3-1%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%201-%E8%B5%84%E6%96%99/1-%E8%AF%BE%E5%A0%82%E8%B5%84%E6%96%9917/_book/assets/16.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试基础02-1</title>
      <link href="/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8002-1/"/>
      <url>/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8002-1/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试基础——软件测试简介"><a href="#软件测试基础——软件测试简介" class="headerlink" title="软件测试基础——软件测试简介"></a>软件测试基础——软件测试简介</h1><blockquote><p>软件测试行业基本介绍、软件测试基本介绍、测试对象介绍、测试级别、系统测试分类、常见的系统测试方法、软件质量、软件测试流程、软件架构、浏览器基本介绍、常见的图片类型</p></blockquote><a id="more"></a><h2 id="软件测试行业基本介绍"><a href="#软件测试行业基本介绍" class="headerlink" title="软件测试行业基本介绍"></a>软件测试行业基本介绍</h2><p>一、为什么需要软件测试</p><ol><li><p>一款软件从无到有会经历很多的开发阶段由不同的人来参与开发，所以最终产出的软件功能可能会存在问题。因此为了保证软件的功能是可用的，我们必须要进行测试。</p></li><li><p>当前的软件件行业已经不在是功能为王了，用户不仅仅只盯着软件的功能是否满足需求，还会对软件是否容易上手，执行效率是否OK …..等一系列其它体验都有了更高的要求，所以这也需要我们对软件进行大量的测试。</p></li></ol><p>二、为什么选择软件测试</p><ol><li><p>国内的软件行业对于专业的软件测试人员需求是慢慢变大。</p></li><li><p>有些人喜欢创造世界所以他们做了开发，而我们就是希望这个世界变得更加美好所以做了测试。</p></li></ol><p>三、为什么不让开发自已做测试</p><ol><li><p>当前行业有许多的测试从业人员本身之前都是开发岗。</p></li><li><p>专业度：软件测试和软件开发分别属于软件行业当中二个不同的技术方向。所以让专人做专事对于质量更加有保证。</p></li><li><p>思维定式：在软件的开发周期中 对于程序员来说他们大多数的时间都是在思考如何实现具体的软件功能，而不会去从用户的角度考虑如何去”奇葩“的使用这些功能。</p></li><li><p>测试力度： 相对于开发来说，产器就相当于是他们的“孩子”。所以“下手”就不会那么狠。</p></li></ol><h2 id="软件测试基本介绍"><a href="#软件测试基本介绍" class="headerlink" title="软件测试基本介绍"></a>软件测试基本介绍</h2><p>一、软件测试定义</p><p>通过手工或者工具对 “被测对象”进行测试操作，从而验证实际结与预期结果之间是否存在差异。</p><p>二、软件测试的作用</p><ol><li><p>通过测试工作可以发现并修复软件当中存在的缺陷，从而提高用户对产品的使用信心。</p></li><li><p>测试可以记录软件运行过程中产生的一些数据，从而为决策提供数据支持。</p></li><li><p>测试可以降低同类型产品开发遇到问题的风险。</p></li></ol><p>三、测试原则：</p><p>所谓的测试原则指的就是我们在执行测试工作时必须要遵守的一些规则。</p><ol><li><p>测试证明软件存在缺陷：无论执行什么样的测试操作都保能证明当前软件是有缺陷的。</p></li><li><p>不能执行穷尽测试：有些功能是没有办法将所有的测试情况都逻列出来，所以任何的测试操作都有结束的时间。</p></li><li><p>缺陷存在群集现象：对于软件功能说，核心功能占20%，非核心是80%。在实际工作中我们会集中测试20%的核心功能，所以这个部分发现缺陷的几率就会高于80%。因此我们我们就会遇到缺陷都集中在 20% 功能模块里的现象。</p></li><li><p>某些测试需要依赖特殊的环境</p></li><li>测试应尽早介入：为了更多的发现和更好的解决软件中的缺陷，我们追求测试工作尽早的开展。</li><li><p>杀虫剂现象：同样的一个测试用例不能重的执行多次，因为软件会对它产生免疫。</p></li><li><p>不存在缺陷谬论：任何软件不可能是完美的。</p></li></ol><h2 id="测试对象介绍"><a href="#测试对象介绍" class="headerlink" title="测试对象介绍"></a>测试对象介绍</h2><p>对于当前的测试行业来说我们最经常测试的主体就是 软件( 主体功能 )，但是需要我们明白是一个软件也不仅仅只有功能需要测试。我们可以将软件分为三个部分组成：功能集合+使用说明书 + 配置数据。</p><p>对于一款软件来说从无到有需要不同的过程，我们可以将这个过程分为不同阶段，然后每个阶段都会相应有测试对象</p><ol><li><p>需求分析阶段：各种需求规格说明书。</p></li><li><p>软件架构设计：API接口文档( 接口测试 )</p></li><li><p>编码实现阶段：源代码（ 白盒测试、单元测试 ）</p></li><li><p>系统功能使用：软件功能主体（ 当前行业做的最多的一种测试 ）</p></li></ol><h2 id="测试级别"><a href="#测试级别" class="headerlink" title="测试级别"></a>测试级别</h2><p>软件的开发都会依据相应的<strong>开发模型</strong>，则测试级别指的就在这个模型当中我们人为定义的开发步骤。其中对于测试来说我们最常见的一种级别分类如下：</p><ol><li><p>单元测试[ UT unit test ]：在软件测试中单元指的就是组成软件最小的底层代码结构，一般就是类、函数、组件（ 当下的软件测试行业，不会刻意要求测试人员对源代码进行测试 ）。</p></li><li><p>集成测试( IT system ingertaion test ):将多个单元模块组合在一起，然后验证它们之间沟通的“桥梁”是否能正常工作( 接口测试 )</p></li><li><p>系统测试( ST system test ):这是当前行业做的最多的一种测试。由测试人员充当用户然后对软件的功能主体进行测试。</p></li><li><p>验收测试:</p></li></ol><p>(1)     α测试 —- 内测</p><p>(2)     β测试 —–公测</p><p>(3)     UAT( user acceptance test )测试—- 由客户派出对于业务非常精通的人员来使用该软件，从而对功能进行测试。</p><p>(4)     验收测试的核心就是让用户为当前软件 “买单”</p><h2 id="系统测试分类"><a href="#系统测试分类" class="headerlink" title="系统测试分类"></a>系统测试分类</h2><ol><li><p>功能测试：验证当前的软件主体功能是否可用。</p></li><li><p>兼容性测试：验证当前软件在不同的环境下是否还可以使用。</p></li><li><p>安全测试：验证软件是否只是能授权用户提供功能使用。</p></li><li><p>性能测试：相对于当前软件消耗的资源 它的产出能力。</p></li></ol><h2 id="常见的系统测试方法"><a href="#常见的系统测试方法" class="headerlink" title="常见的系统测试方法"></a>常见的系统测试方法</h2><p>一、按测试对象进行分类</p><ol><li><p>白盒测试：这种测试的主体就是软件的底层代码，不会在意外在的界面是否OK ，只要求底层功能实现，同时逻辑正确。</p></li><li><p>黑盒测试：这种测试就是指测试软件外在主体功能是否可用。</p></li><li><p>灰盒测试：介于二者之间（ 接口测试 ）</p></li><li><p>上述三种方法当中的 “盒” 指的就是被测对象。</p></li></ol><p>二、按测试对象是否执行分类</p><ol><li><p>静态测试：指的就是测试不执行。</p></li><li><p>动态测试：将软件运行在真实的使用环境中进行测试。</p></li></ol><p>三、按测试手段进行分类</p><ol><li><p>手工测试：由测试人员手动的对被测对象进行验证，优点就是可以灵活的改变测试操作及环境。</p></li><li><p>自动化测试：所谓自动化主要有二种形，一种是自已写测试脚本，另外一种就是通过第三方的工具对被测对象进行测试。优点就是可以高效率的去执行一些人工无法实现的操作。</p></li></ol><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>描述当前软件是否好用，在当前的软件行业里我们所采用的一套标准是基于 ISO 组织制定的。需要我们记忆的就是软件质量的六大特性：</p><ol><li><p>功能性：软件需要满足用户显式或者稳式的功能。</p></li><li><p>易用性：软件易于学习 和上手使用。</p></li><li><p>可靠性：指的就是软件必须实现需求当中指明的具体功能。</p></li><li><p>效率性：类似于软件的性能。</p></li><li><p>可维护性：要求软件具有将某个功能修复之后继续使用的能力。</p></li><li><p>可移植性：当前软件可以从一个平台移植到另一个平台上去使用的能力。</p></li></ol><p>【 功能靠用，效率可“以” 】</p><h2 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h2><ol><li>需求分析</li></ol><p>(1) 当前阶段的核心目的就是梳理清楚我们需要设计的点是什么。</p><p>(2) 需求的来源：需求规格说明书、API文档、竟品分析、个人经验</p><ol start="2"><li>设计用例：</li></ol><p>(1) 用例就是用户为了测试软件的某个功能而执行的操作过程。</p><p>(2) 设计用例是有方法的（ 等价类、边界值、判定表…… ）</p><ol start="3"><li><p>评审用例:对当前的用例进行添加或者删除。</p></li><li><p>配置环境</p></li></ol><p>(1) 环境：指的就是当前被测对象运行所需要的执行环境，做为测试人员需要具备配环境的能力。【 一般情况下都会使用一键安装的集成环境 】</p><p>(2) 环境分类：操作系统 +  服务器软件 +  数据库  +  软件底层代码的执行环境。</p><ol start="5"><li>执行用例</li></ol><p>(1) 一般在执行用例之前我们会做一个冒烟测试。这种测试的核心就是快速的对当前软件的核心功能或者主体执行流程进行验证。如果冒烟测试阶段有问题，则可以将此版本回退给开发。</p><p>(2) 如果冒烟测试通过那么才会开展示全面的测试。</p><ol start="6"><li>回归测试及缺陷跟踪</li></ol><p>(1) 回归测试指的就是当我们将某个缺陷提交给开发之后，由它们进行修复，修复完成之后需要测试认员再次对其进行测试【回归测试】</p><p>(2) 缺陷跟踪：指的就是当测试人员发现某个缺陷之后需要一直对其进行状态的跟踪。</p><ol start="7"><li>输出测试报告</li></ol><p>将当前的测试过程中产生的数据进行可视化的输出。方便其它人去查看。</p><ol start="8"><li>测试结束</li></ol><p>当将整个测试过程中产生的一些文档进行整理归档，方便后续版本使用。</p><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>所谓的软件架构我们可以理解为是用来指导我们软件开发的一种思想。目前来说最常见的二种架构模式就是 B/S  C/S</p><p>B—browser 浏览器</p><p>C—clent 客户端</p><p>S—server 服务端</p><p>一、二种架构的比较</p><ol><li><p>标准：相对于 CS 架构来说 BS架构的二端都是在使用现成的成熟产品。所以BS会显示的标准一些。</p></li><li><p>效率：相对于BS架构来说 CS中的客户端可以分担一些数据的处理，因此执行效率会高一些。</p></li><li><p>安全：B S架构当中的数据传输都是以 HTTP协议进行的输出，而 HTTP协议又是明文输出。可以被抓包，所以相对于 CS 架构来说 BS 就显得不那么安全【相对的】</p></li><li><p>升级：BS架构只需要在服务器端将数据进地更新，前台只需要刷新页面就可以完成升级，而CS架构当中必须要将二端都进行更新。</p></li><li><p>开发成本：相对于 BS架构来说 CS当中的客户端需要自已开发，所以相对于来说成本会高一些。</p></li></ol><h2 id="浏览器基本介绍"><a href="#浏览器基本介绍" class="headerlink" title="浏览器基本介绍"></a>浏览器基本介绍</h2><p>一、浏览器是什么</p><p>浏览器本质就是一款软件，安装在操作系统之上。一般给用户提供浏览网页的服务。目前来说我们会人为的将所有浏览器总结出一个所谓的五大生产厂商。【 对于浏览器来说最核心技术就是内核 】</p><p>二、五大浏览器生产厂商</p><ol><li><p>IE( 微软 )—–trident </p></li><li><p>Chrome ( 谷歌 )—-blink</p></li><li><p>Firefox( 火狐 )—–gecko</p></li><li><p>Safari( 苹果 )—–webkit</p></li><li><p>Opera( 欧朋 )—-presto【 现在已经放弃自已东西完全向 chrome 】</p></li></ol><h2 id="常见的图片类型"><a href="#常见的图片类型" class="headerlink" title="常见的图片类型"></a>常见的图片类型</h2><ol><li><p>Jpg(jpeg) :这是一种可以高度保留图片色彩信息的格式。</p></li><li><p>Png：该类型的图片可以实现透明。</p></li><li><p>Gif：图片所占体积小，可以实现动图</p></li><li><p>Psd：它是一种分层的图片。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试基础01-2</title>
      <link href="/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-2/"/>
      <url>/2019/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础02"><a href="#计算机基础02" class="headerlink" title="计算机基础02"></a>计算机基础02</h1><blockquote><p>常见的数学进制、进制转换、编码、数据计量单位、编程语言、常见的DOS命令</p></blockquote><a id="more"></a><h2 id="常见的数学进制"><a href="#常见的数学进制" class="headerlink" title="常见的数学进制"></a>常见的数学进制</h2><p>1 二进制：基数就是0 1 ，逢二进1</p><p>2 八进制：基数就是0-7 ，逢八进1</p><p>3 十进制：基数就是0-9 ，逢十进1</p><p>4 十六进制：基本数就是0-9 A B C D E F, 逢十六进1</p><p>一、用二进制数数</p><p>0   1  10  11  100  101  110  111  1000</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><a href="http://tool.oschina.net/hexconvert/" target="_blank" rel="noopener">http://tool.oschina.net/hexconvert/</a> 【 在线的进制转换工具地址 】</p><p>一、其它进制转十进制：</p><p>1．先确定当前数字的位数，然后从右向左数，依次认为是低位到高位。</p><p>2．记下每位数字所在的位数N( N不是一个固定的数字，由当前所在位数决定 )</p><p>3．取出每一位上的数字 m ，然后用这个m 去乘以当前进制的N-1次方。( m也不是固定的，它就是当前位上所具有的数字 )</p><p>4．将每位上的相乘结果进行相加，最后的和就是该数值所对应的十进制值。</p><p>二、其它进制转二进制</p><p>1．十进制转二进制</p><p>（1）用这个十进制的数字除以2 ，得到商和余数。</p><p>（2）判断商是否为0，如果不是0则继续用这个商除去2</p><p>（3）直到某一次商为0时结束，将这个除法过程中产生的余数反向排列</p><p>（4）最终的排列结果就是当前这个十进制转成二进制后的数值</p><p>2．8进制/16进制转二进制</p><p>（1）将八进制或十六制中的所有“基数”都转成二进制。（需要注意的就是八进制转二进制要写成三位，而十六进制要写在四位）</p><p>（2）有了上述的二进制基数转换之后，当我们拿到一个具体的八进制或者十六进制数值之后我们只需要将其进行拼接就可以。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>一、编码是什么</p><p>所谓的编码指的就是将我们人类可以理解的语言编译成计算机可以执行的语言。</p><p>二、编码的思想</p><p>将我们人类中的自然语言人为的按照一种规则与一个二进制的数值做对应。当这种对应关系越来越多的时候，就会形成一张表，我们将这个表称之为叫编码表。</p><p>三、ascii 码表</p><p>1．它是全世界第一张通用单字节编码表。</p><p>2．它分成三个部分，一共有256个字符。</p><p>3．当我们没有使用正确的编码来处理汉字的时候在网页展示就会乱码。</p><p>4．对于中文汉字来说，我们目前使用最多的一种编码标准就是 UTF8 编码。</p><h2 id="数据计量单位"><a href="#数据计量单位" class="headerlink" title="数据计量单位"></a>数据计量单位</h2><p>一、为什么需要计量单位</p><p>计算机是用来处理数据的，当数据积累到一定的量级之后就会需要有相应的单位来对它们进行衡量。</p><p>二、最基本的计量单位</p><p>1．比特( bit/ 位 )：它被认为是计算机当中最小的一个单位。</p><p>2．字节( bytes ): 它比 位要大一些，人为规定 1字节=8位</p><p>三、常见的单位及转换关系</p><p>1．1B = 8b</p><p>2．1KB = 1024B  [文档和小图片]</p><p>3．1MB = 1024KB【 大图片，或者音乐 】</p><p>4．1GB = 1024MB【 高清的电影 】</p><p>5．1TB = 1024GB</p><p>6．1PB = 1024TB</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>由人类来设计的一种计算机可以理解的语言</p><p>一、编程语言发展历史</p><p>1．机器语言</p><p>机器语言就是纯二进制，将我们人类想让计算机完成的事情都直接用01 来表示。</p><p>2．汇编语言</p><p>汇编语言就是在机器语言的基础之上将一些常用的操作直接规定成人类的一些语句来表达，但是随着计算机要做的事情越来越多，同时生产计算要的厂商也越来越多，我们不能保证所有的硬件都能很好支持我们的二进制。</p><p>3．高级编程语言</p><p>它就是一种类似于人类的自然语言，人类很容易理解，同时又不用担心计算机如何识别。当前全世界大概有（600）多种编程语言</p><p>二、常见的编程语言</p><p>1．C语言： 我们认为c 是高级编程语言的鼻祖。</p><p>2．C++ ：它就是在 C语言的基础上做了减化。更利于我们学习，c 和 c++ 都是由 贝尔实验室 推出。</p><p>3．Java : 由 sun 公司在1995推出，最大的点是跨平台。( jvm 虚拟机 )</p><p>4．C# : 由微软推出的一个语言。</p><p>5．Python : 一种数学计算能力很强的语言。</p><p>6．Php ：这门语言在出生的时候最大的特点就是用来做web 网站。</p><p>7．Javascript：当前最流行的一种前端脚本语言</p><p>8．Nodejs ： 全栈型语言，前后端都可以写。</p><p>9．Go ： 由谷歌公推出的一门语言。</p><h2 id="常见的DOS命令"><a href="#常见的DOS命令" class="headerlink" title="常见的DOS命令"></a>常见的DOS命令</h2><p>一、DOS 是什么</p><p>DOS 是一个操作系统，属于windows ，和我们现在用的 win7 8 10 去比较其实差别就在于 ，我们现在用的是图形桌面系统，而DOS 是一个命令行执行的操作系统。</p><p>二、如何使用DOS </p><p>1．进入终端：win + r 调出运行面板</p><p>2．在运行中输入 cmd 进入终端</p><p>3．在终端面板中书写 DOS 命令 ，然后回执行。</p><p>三、常见的命令</p><p>1．Time 显示当前计算机的本地时间</p><p>2．Ctrl+ c 退出当前正在执行的命令</p><p>3．Shutdown /s /t 时间(秒) :设置在多少时间后自动关机【 中间有空格 】</p><p>4．Shutdown /a 取消之前设置的自动关机</p><p>5．Cls  清空当前正在编辑的屏幕</p><p>6．Ping 网址</p><p>（1）可以检查当前的网络是否是通的</p><p>（2）可以得到当前被访问网页的IP地址</p><p>7．Ipconfig -all </p><p>（1）可以将当前计算机当中的所有网卡信息都列出来。</p><p>（2）Ip 地址：这个地址一般是用来在网络上唯一标识计算机。（ 一台机器的IP地址可以变 ）</p><p>（3）Mac 地址：也叫物理地址，它是被写入 ROM 的。理论上每台计算机的mac地址是唯一的。</p><p>8．上下键 ：调用我们之前使用过的命令，上键就是往回找，下键就是往下找。</p><p>四、切换盘符</p><p>具体盘符名称:  </p><p>五、返回上一级或根目</p><p>Cd ..  返回上一级</p><p>Cd / 返回根目录</p><p>注意：</p><p>01 cd 就是change directory 的首字母缩写，表示切换目录的意思。</p><p>02 cd 命令不可以切换盘符</p><p>03 根目录指的就是某个盘符的一级目录</p><p>04 命令语句一定都是在英文输入法下面书写的，命令和参数之间往往都用空格隔开</p><p>六、列表示展示某个目录下的内容</p><p>Dir </p><p>七、目录及文件相关操作</p><p>1．新建目录： md 路径</p><p>2．新建文件： echo “内容”&gt;文件名称，通过这种方法间接得到一个文件</p><p>3．删除目录： rd 路径 【默认情况下只能删除空目录，如果想连带它里的文件一起删除则需要设置 /s 参数】</p><p>4．删除文件： del 文件名称 </p><p>注：</p><p>A. md 只能新建目录</p><p>B. Rd 默认只能删除空目录</p><p>C. 参与与命令之间一定要用空格</p><p>D. 如果del 后面直接写的不是文件，而是一个目录，那么它就会将这个目录下的所有文件都删除（ 前提是我们选择 Y  ）</p><p>八、文件复制和剪切命令</p><p>Copy 被复制文件路径  将这个文件复制到哪里</p><p>Copy aa/aa.txt c:\test\bb.txt [ 将目录aa下在的aa.txt 文件，复制到 c 盘test目录下，同时将名称修改为 bb ]</p><p>注：</p><p>01 复制操作语句，我们可以分为三段，第一段就是命令 copy ，第二段就是被复制文件的在地，第三段可以指明将当前文件复制到哪里，三段之间都要用空格隔开</p><p>02 第三段可以省略，省略之后的结果就是会将相应的文件直接复制到我们的当前所在位置。</p><p><img src="file:///C:/Users/28715/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"></p><p>Move 被剪切文件所在地 将这个文件剪切到哪里</p><p>注：</p><p>01 对于剪切操作来说 必须要进入到想要操作文件所在目录去执行命令</p><p>02 第三段用来指明目标所在地的部分不能省略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试——测试基础01_1</title>
      <link href="/2019/08/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-1/"/>
      <url>/2019/08/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%8001-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础01"><a href="#计算机基础01" class="headerlink" title="计算机基础01"></a>计算机基础01</h1><blockquote><p>“计算机”基本介绍、硬件系统、软件系统、二进制基本介绍</p></blockquote><a id="more"></a><h2 id="“计算机”基本介绍"><a href="#“计算机”基本介绍" class="headerlink" title="“计算机”基本介绍"></a>“计算机”基本介绍</h2><p>一、为什么需要计算机</p><p>对于现在的我们来说，每天要处理的信息量是巨大的，所以如果还是人工的来对这些数据进行处理，那么效率是很低的。此时计算机的出现就可以帮助我们的来提高处理数据的速度。</p><p>二、计算机是什么</p><p>计算机就是一台可以自动高效完成计算的电子设备，我们俗称叫 电脑( PC )</p><p>三、计算机的特点</p><p>1．计算机可以进行数学和逻辑运算。（ 逻辑运算可以实现在接收到不同操作指令的时候做出不同的响应 ）</p><p>2．计算机可以对数据进行记忆和存储。( 数据不仅仅只是数字，图片 文字 声音 视频…. )</p><p>3．计算机可以在程序的指令下自动高效的完成计算。</p><p>四、计算机组成</p><p>1．从大的系统分类上我们将计算机的组成分为：软件系统+硬件系统</p><p>2．硬件：我们就可以认为是组成计算机的那些物理设备（ 看得见 摸得着 ）</p><p>3．软件：所谓的软件就是安装在计算机上供用户使用的操作指令集合。</p><h2 id="硬件系统"><a href="#硬件系统" class="headerlink" title="硬件系统"></a>硬件系统</h2><p>一、为什么需要硬件</p><p>任何的计算操作，最终都需要通过相应的硬件来完成。</p><p>二、硬件的组成</p><p>1．现代的电子计算机我们依据 “冯诺依曼” 理论将它的硬件分成五个级成部分。</p><p>2．输入设备：核心作用就是给计算输入不同格式的数据。</p><p>3．输出设备：作用就是将计算机处理之后的数据以不同的形式展示给用户。</p><p>4．控制器+处理器：这二个部分合在一起就是我们所说的中央处理器( CPU )</p><p>5．存储设备:我们将计算机当中的存储器分为内存和外存二种，无论是哪一种，它的作用都是对数据进行存储。</p><p>三、内存与外存</p><p>1．内存：就是我平所说的内存条，它的大小一般在（ 4G-16G ）</p><p>2．外存：外存的表现形式很多，例如硬盘（ 128G-1T ）</p><p>四、内存与外存比较</p><p>1．内存的运算速度要快去外存</p><p>2．内存当中的数据断电之后会消失，而外存不会。</p><p>3．内存本身我们又分为只读内存( ROM )和随机内存( RAM )</p><h2 id="软件系统"><a href="#软件系统" class="headerlink" title="软件系统"></a>软件系统</h2><p>一、为什么需要软件</p><p>如果计算要没有软件系统那么它里面的硬件就不知道如何进行工作。</p><p>二、软件系统介绍</p><p>1．我们人为的将软件系统分为二类：系统软件 + 应用软件</p><p>2．系统分类( 操作系统软件 )：</p><p>（1）桌面操作系统：</p><p>Windows: 由微软推出，用户量很大。分很多系列</p><p>MacOs:苹果公司，本质其实也是一个 Linux 分支。</p><p>Linux:核心内容是由 李纳斯 编写，应用软件少。</p><p>（2）移动设备操作系统</p><p> IOS</p><p> Androids :底层就是一款小型的 Linux </p><p>（3）服务器操作系统 </p><p> Windows server ：由微软件推出，是收费的。</p><p> Linux：开源 稳定</p><p> 服务器：所谓的服务器我们就可以理解为是一台给用户提供相应的服务的机器。（文件上传下载服务，视频上传下载服务…..）只不过，这台机器的处理能力要远远大于我们的个人电脑。</p><p>服务器操作系统查询地址：<a href="https://toolbar.netcraft.com/site_report?url=http:/www.taobao.com" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url=http://www.taobao.com</a></p><p>3 应用软件：我们就将那些可以安装在操作系统之上的第三方软件。( 微信  QQ ….. )</p><h2 id="二进制基本介绍"><a href="#二进制基本介绍" class="headerlink" title="二进制基本介绍"></a>二进制基本介绍</h2><p>一、<strong>二进制是什么</strong></p><p>1．进制: 就是一种人为规定的计数规则。</p><p>2．二进制：它就是逢二进1 的一种计算规则。</p><p><strong>二、**</strong>二进制介绍**</p><p>1．在二进制里“基数”只有 0 和 1 </p><p>2．二进制当前被广泛的应用于计算机当中。( 计算机底层只能读懂0 和 1 )</p><p>三、<strong>计算机如何理解0</strong> <strong>和 1</strong> </p><p>现代的计算机都是通电进行工作，当电流走过设备的时候必然会产生电压。此时前辈们就人为的设定规则，取了一个电压值，比这个值大的叫高电位。用数字1 表示，比这个值小的叫低电位。用数字0 表示。基于这种原理，此时的计算机就可以认识0 和 1 了。刚好0 与1 又是二进制当中的基数。（ 计算机应用了二进制 ）</p><p>四、计算机采用二进制的好处</p><p>1．二进制技术实现简单，状态稳定。</p><p>2．二进制里只有0 和 1 二个基数，刚好与程序语言当中的 真和假对应。【全世界都人为的认为 1 可以代表程序语言中真，0 就可以代表程序语言中的假】</p><p>3．二进制数值可以很容易的转成十进制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的FileReader</title>
      <link href="/2019/08/09/HTML5%E7%9A%84FileReader/"/>
      <url>/2019/08/09/HTML5%E7%9A%84FileReader/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5的FileReader"><a href="#HTML5的FileReader" class="headerlink" title="HTML5的FileReader"></a>HTML5的FileReader</h1><a id="more"></a><h2 id="FileReader-读取文件内容"><a href="#FileReader-读取文件内容" class="headerlink" title="FileReader:读取文件内容"></a>FileReader:读取文件内容</h2><ol><li>readAsText():读取文本文件（可以使用Txt）打开的文件，返回文本字符串，默认编码是utf-8</li><li>readAsBinaryString():读取任意类型的文件。返回二进制字符串。这个方法不是用来读取文件给用户看，而是存储文件。例如:读取文件的内容，获取二进制数据，传递给后台，后台接收了数据之后，再将数据存储。</li><li>readAsDataURL():读取文件获取一段以data开头的字符串，这字符串的本质就是DataURL.dataURL是一种将文件(这个文件一般就是指图像或能嵌入到文档的文件格式）嵌入到文档的方案。DataURL是将资源转换为base64的字符串形式，并且将这些内容直接存储在url，优化网站的加载速度和执行效率。</li></ol><h2 id="img的src解析"><a href="#img的src解析" class="headerlink" title="img的src解析"></a>img的src解析</h2><ol><li>src：制定路径（资源定位–url):src请求的是外部文件，一般来说是服务器资源。意味着它需要向服务器发送请求，它占服务器资源</li></ol><h2 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h2><ol><li>abort()终端读取</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote><p>需求</p><p>即时预览</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"myFile"</span> <span class="attr">id</span>=<span class="string">"myFile"</span> <span class="attr">onchange</span>=<span class="string">"getFIleContent()"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span></span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFileContent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//1.创建文件读取对象</span></span><br><span class="line">    <span class="keyword">var</span> reader=<span class="keyword">new</span> FileReader();</span><br><span class="line">    <span class="comment">//2.读取文件，获取DataURL</span></span><br><span class="line">        <span class="comment">//2.1.说明没有任何的返回值：void:但是读取完文件之后，他会将读取的结果存储在文件读取对象的result。</span></span><br><span class="line">        <span class="comment">//2.2.需要传递一个参数binary large object：文件（图片或者其他可以嵌入到文档的类型）</span></span><br><span class="line">        <span class="comment">//2.3.文件存储在file表单元素的files属性，它是一个数组   </span></span><br><span class="line">        <span class="keyword">var</span> file = <span class="built_in">document</span>.querySelector(<span class="string">"#myFile"</span>).files;</span><br><span class="line">reader.readAsDataURL(file[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">/*获取数据*/</span></span><br><span class="line"><span class="comment">/*FileReader提供一个完整的时间模型，用来补货读取文件时的状态</span></span><br><span class="line"><span class="comment">onabort:读取文件中断片时触发</span></span><br><span class="line"><span class="comment">onerror:读取错误时触发</span></span><br><span class="line"><span class="comment">onload:文件读取成功完成时触发</span></span><br><span class="line"><span class="comment">onloadend:读取完成时触发，物流成功还是失败</span></span><br><span class="line"><span class="comment">onloadstart:开始读取时触发</span></span><br><span class="line"><span class="comment">onprogress:读取文件过程中持续触发</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reader.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"img"</span>).src=reader.result;</span><br><span class="line">    &#125;</span><br><span class="line">reader.onprogress=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> percent=e.loaded/e.total*<span class="number">100</span>+<span class="string">"%"</span>;</span><br><span class="line">        div.style.width=percent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5地理定位接口</title>
      <link href="/2019/08/09/HTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/08/09/HTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5地理定位接口"><a href="#HTML5地理定位接口" class="headerlink" title="HTML5地理定位接口"></a>HTML5地理定位接口</h1><a id="more"></a><ol><li><p>获取地理信息成功之后的回调</p></li><li><p>获取地理信息失败之后的回调</p></li><li><p>调整获取当前地理信息的方式</p></li><li><p>navigator.geolocation.getCurrentPosition(success,error,option)；</p></li><li><p>enableHighAccuracy:true/false:是否使用高精度</p></li><li><p>timeout:设置超时时间，单位ms</p></li><li><p>maxiumAge:可以设置浏览器重新获取地理信息的时间间隔，单位是ms</p></li><li><p>如果成功获取地理信息成功，会将获取到的地理信息传递给成功之后的回调</p><p>position.coords.latitude 维度</p><p>position.corrds.longitude 经度</p><p>position.corrds.accuracy 精度</p><p>position.corrds.altitude 海拔</p></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.de</span>&#123;</span></span><br><span class="line"><span class="undefined">            width: 300px;</span></span><br><span class="line"><span class="undefined">            height: 300px;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ddd</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"de"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var x=document.getElementById("demo");</span></span><br><span class="line"><span class="undefined">    function getLocation()</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        /*能力测试*/</span></span><br><span class="line"><span class="undefined">        if (navigator.geolocation)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">            /*1.获取地理信息成功之后的回调</span></span><br><span class="line"><span class="undefined">            * 2.获取地理信息失败之后的回调</span></span><br><span class="line"><span class="undefined">            * 3.调整获取当前地进信息的方式*/</span></span><br><span class="line"><span class="undefined">            //navigator.geolocation.getCurrentPosition(success,error,option);</span></span><br><span class="line"><span class="undefined">            /*option:可以设置获取数据的方式</span></span><br><span class="line"><span class="undefined">            * enableHighAccuracy:true/false:是否使用高精度</span></span><br><span class="line"><span class="undefined">            * timeout:设置超时时间，单位ms</span></span><br><span class="line"><span class="undefined">            * maximumAge:可以设置浏览器重新获取地理信息的时间间隔，单位是ms*/</span></span><br><span class="line"><span class="undefined">            navigator.geolocation.getCurrentPosition(showPosition,showError,&#123;</span></span><br><span class="line"><span class="undefined">                /*enableHighAccuracy:true,</span></span><br><span class="line"><span class="undefined">                timeout:3000*/</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        else&#123;</span></span><br><span class="line"><span class="undefined">            x.innerHTML="Geolocation is not supported by this browser.";</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    /*成功获取定位之后的回调*/</span></span><br><span class="line"><span class="undefined">    /*如果获取地理信息成功，会将获取到的地理信息传递给成功之后的回调*/</span></span><br><span class="line"><span class="undefined">    // position.coords.latitude 纬度</span></span><br><span class="line"><span class="undefined">    // position.coords.longitude 经度</span></span><br><span class="line"><span class="undefined">    // position.coords.accuracy 精度</span></span><br><span class="line"><span class="undefined">    // position.coords.altitude 海拔高度</span></span><br><span class="line"><span class="undefined">    function showPosition(position)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        x.innerHTML="Latitude: " + position.coords.latitude +</span></span><br><span class="line"><span class="xml">                "<span class="tag">&lt;<span class="name">br</span> /&gt;</span>Longitude: " + position.coords.longitude;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    /*获取定位失败之后的回调*/</span></span><br><span class="line"><span class="undefined">    function showError(error)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        switch(error.code)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">            case error.PERMISSION_DENIED:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="User denied the request for Geolocation."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">            case error.POSITION_UNAVAILABLE:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="Location information is unavailable."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">            case error.TIMEOUT:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="The request to get user location timed out."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">            case error.UNKNOWN_ERROR:</span></span><br><span class="line"><span class="undefined">                x.innerHTML="An unknown error occurred."</span></span><br><span class="line"><span class="undefined">                break;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    getLocation();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="百度地图的案例"><a href="#百度地图的案例" class="headerlink" title="百度地图的案例"></a>百度地图的案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>普通地图&amp;全景图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://api.map.baidu.com/api?v=2.0&amp;ak=DarF2LCCGzn6T16zgy8ZPkvYYE5CT6fu"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>, <span class="selector-tag">html</span>&#123;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">overflow</span>: hidden;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">font-family</span>:<span class="string">"微软雅黑"</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#panorama</span> &#123;<span class="attribute">height</span>: <span class="number">50%</span>;<span class="attribute">overflow</span>: hidden;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#normal_map</span> &#123;<span class="attribute">height</span>:<span class="number">50%</span>;<span class="attribute">overflow</span>: hidden;&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panorama"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"normal_map"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    //全景图展示</span></span><br><span class="line"><span class="undefined">    var panorama = new BMap.Panorama('panorama');</span></span><br><span class="line"><span class="undefined">    panorama.setPosition(new BMap.Point(116.404125,39.91405)); //根据经纬度坐标展示全景图</span></span><br><span class="line"><span class="undefined">    panorama.setPov(&#123;heading: -40, pitch: 6&#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    panorama.addEventListener('position_changed', function(e)&#123; //全景图位置改变后，普通地图中心点也随之改变</span></span><br><span class="line"><span class="undefined">        var pos = panorama.getPosition();</span></span><br><span class="line"><span class="undefined">        map.setCenter(new BMap.Point(pos.lng, pos.lat));</span></span><br><span class="line"><span class="undefined">        marker.setPosition(pos);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">    //普通地图展示</span></span><br><span class="line"><span class="undefined">    var mapOption = &#123;</span></span><br><span class="line"><span class="undefined">        mapType: BMAP_NORMAL_MAP,</span></span><br><span class="line"><span class="undefined">        maxZoom: 18,</span></span><br><span class="line"><span class="undefined">        drawMargin:0,</span></span><br><span class="line"><span class="undefined">        enableFulltimeSpotClick: true,</span></span><br><span class="line"><span class="undefined">        enableHighResolution:true</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    var map = new BMap.Map("normal_map", mapOption);</span></span><br><span class="line"><span class="undefined">    var testpoint = new BMap.Point(116.404125,39.91405);</span></span><br><span class="line"><span class="undefined">    map.centerAndZoom(testpoint, 18);</span></span><br><span class="line"><span class="undefined">    var marker=new BMap.Marker(testpoint);</span></span><br><span class="line"><span class="undefined">    marker.enableDragging();</span></span><br><span class="line"><span class="undefined">    map.addOverlay(marker);</span></span><br><span class="line"><span class="undefined">    map.enableScrollWheelZoom(true);</span></span><br><span class="line"><span class="undefined">    map.addControl(new BMap.MapTypeControl());</span></span><br><span class="line"><span class="undefined">    marker.addEventListener('dragend',function(e)&#123;</span></span><br><span class="line"><span class="undefined">        panorama.setPosition(e.point); //拖动marker后，全景图位置也随着改变</span></span><br><span class="line"><span class="undefined">        panorama.setPov(&#123;heading: -40, pitch: 6&#125;);&#125;</span></span><br><span class="line"><span class="undefined">    );</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的拖拽</title>
      <link href="/2019/08/09/HTML5%E7%9A%84%E6%8B%96%E6%8B%BD/"/>
      <url>/2019/08/09/HTML5%E7%9A%84%E6%8B%96%E6%8B%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5的拖拽"><a href="#HTML5的拖拽" class="headerlink" title="HTML5的拖拽"></a>HTML5的拖拽</h1><a id="more"></a><ol><li><p>学习拖拽，主要就是学习拖拽时间</p><blockquote><p>拖拽元素的事件</p><p>ondrag:应用于拖拽元素，整个拖拽过程都会调用</p><p>ondragstart：应用于拖拽元素，当拖拽开始时调用</p><p>ondragleave:应用于拖拽元素，当鼠标离开拖拽元素时调用</p><p>ondraend:应用于拖拽元素，拖拽结束调用</p></blockquote></li></ol><p>2.<strong>测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;div1&quot; id=&quot;div1&quot;&gt;</span><br><span class="line">&lt;p id=&quot;pe&quot; draggable=&quot;true&quot;&gt;test&lt;/p&gt;</span><br><span class="line">&lt;p id=&quot;pe1&quot; draggable=&quot;true&quot;&gt;test1&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid green;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>:orange;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">"#pe"</span>);</span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.querySelector(<span class="string">"#div2"</span>);</span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.querySelector(<span class="string">"#div1"</span>);</span><br><span class="line">p.ondragstart=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondragstart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">p.ondragend=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondragend"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">p.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"元素：ondragleave"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">p.ondrag=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondrag"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">div2.ondragenter=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondragenter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">div2.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*如果想要触发ondrop事件，就要在这里阻止浏览器的默认行为*/</span></span><br><span class="line">e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*浏览器默认会阻止ondrop事件：我们必须在ondragover阻止浏览器的默认行为*/</span></span><br><span class="line">div2.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ondrop"</span>);</span><br><span class="line">        div2.appendChild(p);</span><br><span class="line">    &#125;</span><br><span class="line">div2.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"目标元素：ondragleave"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">div1.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">        <span class="comment">/*如果想要触发ondrop事件，那么就必须在这个位置阻止浏览器阻止拖拽的行为*/</span></span><br><span class="line">    &#125;</span><br><span class="line">div1.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">div1.appendChild(p);    </span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>应用于目标元素的事件</li></ol><blockquote><p>ondragenter：应用于目标元素，当拖拽元素到达时调用</p><p>ondragover: 应用于目标元素，当停留在目标元素时调用</p><p>ondrop:应用于目标元素，当在目标元素放下元素时调用</p><p>ondragleave:应用于目标元素，当鼠标离开目标元素时调用</p></blockquote><ol start="4"><li>若要将元素可以拖拽到多个div，而不是需要为每一个div都设置事件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="literal">null</span>;<span class="comment">//当前被拖拽的地元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragstart=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*通过事件捕获来获取当前被拖拽的子元素*/</span></span><br><span class="line">    e.target.style.opacity=<span class="number">0.5</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"5px"</span>;</span><br><span class="line">    obj= e.target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragend=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.target.style.opacity=<span class="number">1</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"1px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrag=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragenter=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*添加元素*/</span></span><br><span class="line">    <span class="comment">//e.target.appendChild(obj);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>datatransfer</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragstart=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.target.style.opacity=<span class="number">0.5</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"5px"</span>;</span><br><span class="line">    obj= e.target;</span><br><span class="line">    <span class="comment">/*通过dataTransfer来实现数据的存储与获取</span></span><br><span class="line"><span class="comment">    * setData(format,data):</span></span><br><span class="line"><span class="comment">    * format:数据的类型：text/html   text/uri-list</span></span><br><span class="line"><span class="comment">    * Data:数据:一般来说是字符串值*/</span></span><br><span class="line">    e.dataTransfer.setData(<span class="string">"text/html"</span>, e.target.id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragend=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.target.style.opacity=<span class="number">1</span>;</span><br><span class="line">    e.target.parentNode.style.borderWidth=<span class="string">"1px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrag=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.ondragenter=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragover=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondrop=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*添加元素*/</span></span><br><span class="line">    <span class="comment">//e.target.appendChild(obj);</span></span><br><span class="line">    <span class="comment">/*通过e.dataTransfer.setData存储的数据，只能在drop事件中获取*/</span></span><br><span class="line">    <span class="keyword">var</span> id=e.dataTransfer.getData(<span class="string">"text/html"</span>);</span><br><span class="line">    <span class="comment">/*console.log("id="+id);*/</span></span><br><span class="line">    e.target.appendChild(<span class="built_in">document</span>.getElementById(id));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.ondragleave=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS复习内容01</title>
      <link href="/2019/04/03/CSS%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B901/"/>
      <url>/2019/04/03/CSS%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B901/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS复习笔记01"><a href="#CSS复习笔记01" class="headerlink" title="CSS复习笔记01"></a>CSS复习笔记01</h3><a id="more"></a><h1 id="引入CSS样式表"><a href="#引入CSS样式表" class="headerlink" title="引入CSS样式表"></a>引入CSS样式表</h1><p>CSS可以写到那个位置？ 是不是一定写到html文件里面呢？</p><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><p>内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/CSS"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。</p><p>type=”text/CSS”  在html5中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。</p><h2 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h2><p>内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span> <span class="attr">style</span>=<span class="string">"属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"</span>&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。</p><h2 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h2><p>链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"CSS文件的路径"</span>  <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：  link 是个单标签</p><p>该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</span><br><span class="line">type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。</span><br><span class="line">rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</span><br></pre></td></tr></table></figure><h2 id="三种样式表总结（位置）"><a href="#三种样式表总结（位置）" class="headerlink" title="三种样式表总结（位置）"></a>三种样式表总结（位置）</h2><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>没有实现样式和结构相分离</td><td>较少</td><td>控制一个标签（少）</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面（中）</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多，强烈推荐</td><td>控制整个站点（多）</td></tr></tbody></table><h1 id="CSS样式规则"><a href="#CSS样式规则" class="headerlink" title="CSS样式规则"></a>CSS样式规则</h1><p>使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。</span><br><span class="line">2.属性和属性值以“键值对”的形式出现。</span><br><span class="line">3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</span><br><span class="line">4.属性和属性值之间用英文“:”连接。</span><br><span class="line">5.多个“键值对”之间用英文“;”进行区分。</span><br><span class="line">可以用段落 和 表格的对齐的演示。</span><br></pre></td></tr></table></figure><h1 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h1><h2 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h2><p>标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;  或者</span><br><span class="line">元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。</p><p>标签选择器 可以把某一类标签全部选择出来  div  span  </p><h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签调用的时候用 class=“类名”  即可。</span><br></pre></td></tr></table></figure><p>类选择器最大的优势是可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 </p><p>小技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.长名称或词组可以使用中横线来为选择器命名。</span><br><span class="line">2.不建议使用“_”下划线来命名CSS选择器。</span><br></pre></td></tr></table></figure><p>​    输入的时候少按一个shift键;<br>　浏览器兼容问题 (比如使用<em>tips的选择器命名，在IE6是无效的)<br>　能良好区分JavaScript变量命名(JS变量命名是用“</em>”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.不要纯数字、中文等命名， 尽量使用英文字母来表示。</span><br></pre></td></tr></table></figure><h2 id="多类名选择器"><a href="#多类名选择器" class="headerlink" title="多类名选择器"></a>多类名选择器</h2><p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。</span><br><span class="line">2. 各个类名中间用空格隔开。</span><br></pre></td></tr></table></figure><p>多类名选择器在后期布局比较复杂的情况下，还是较多使用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pink fontWeight font20"</span>&gt;</span>亚瑟<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font20"</span>&gt;</span>刘备<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font14 pink"</span>&gt;</span>安其拉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font14"</span>&gt;</span>貂蝉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。</p><p>用法基本和类选择器相同。</p><h2 id="id选择器和类选择器区别"><a href="#id选择器和类选择器区别" class="headerlink" title="id选择器和类选择器区别"></a>id选择器和类选择器区别</h2><p>W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。</p><p>类选择器（class） 好比人的名字，  是可以多次重复使用的， 比如  张伟  王伟  李伟  李娜</p><p>id选择器     好比人的身份证号码，  全中国是唯一的， 不得重复。 只能使用一次。</p><p><strong><em>id选择器和类选择器最大的不同在于 使用次数上。</em></strong></p><h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><p>通配符   选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;                    <span class="comment">/* 定义外边距*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;                   <span class="comment">/* 定义内边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>——转学习黑马过程中的笔记——</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6学习笔记2</title>
      <link href="/2019/03/23/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2019/03/23/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="es6学习笔记2"><a href="#es6学习笔记2" class="headerlink" title="es6学习笔记2"></a>es6学习笔记2</h1><a id="more"></a><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="字符串的Unicode码表示"><a href="#字符串的Unicode码表示" class="headerlink" title="字符串的Unicode码表示"></a>字符串的Unicode码表示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原本的JavaScript只能支持\u0000-\uffff的码点，超出这个范围就不能正确解析，在es6中只要将码点放到大括号就能正确解析</span><br></pre></td></tr></table></figure><h3 id="codePointAt-字符串编码"><a href="#codePointAt-字符串编码" class="headerlink" title="codePointAt()字符串编码"></a>codePointAt()字符串编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一般默认的字符是2个字节存储，对于多于\u0000-\uffff的字符，这个存储需要四个字节，因此JavaScript会将其理解为两个字符，这样的话chatAt()就无法读取正确的值，charCodeAt()读取到的也是2个字节的十进制码</span><br><span class="line">所以为了能够正确解读，便可以采用codePointAt()方法</span><br><span class="line">这个方法返回的是UTF-16的十进制码点，如果需要转化可以使用toString</span><br><span class="line">s.codePointAt().toString(16)</span><br></pre></td></tr></table></figure><h3 id="String-formCodePoint"><a href="#String-formCodePoint" class="headerlink" title="String.formCodePoint()"></a>String.formCodePoint()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaScript提供了一种方法formCharCode(),用于将码点转化成为字符串，但是无法转化UTF-16的字符，即不在\u0000-\uffff范围的字符串无法解析</span><br><span class="line">因此es6提供了一种forCharCode()方法，用于转换这些字符</span><br><span class="line">这个字符串可以有多个参数，返回的时候将这几个参数转化后形成字符串返回</span><br></pre></td></tr></table></figure><h3 id="字符串的遍历接口"><a href="#字符串的遍历接口" class="headerlink" title="字符串的遍历接口"></a>字符串的遍历接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在es6可以使用for of语句去遍历字符串</span><br><span class="line">for (let codePoint of &apos;foo&apos;) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line">// &quot;f&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line">但是用for语句就不能遍历UTF-16的编码字符，因为会误以为一个字符是两个字符</span><br></pre></td></tr></table></figure><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在JavaScript提供合成语调符号和字符的方法合成Ǒ（\u004F\u030C）</span><br><span class="line">但是这种方式无法让JavaScript识别，就是说Unicode本身提供的语调字符和合成之后的字符无法===</span><br><span class="line">但是如果使用了normalize就可以===</span><br><span class="line">&apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize()//true</span><br></pre></td></tr></table></figure><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">includes()：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line">startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line">endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br><span class="line"></span><br><span class="line">let s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;Hello&apos;) // true</span><br><span class="line">s.endsWith(&apos;!&apos;) // true</span><br><span class="line">s.includes(&apos;o&apos;) // true</span><br><span class="line"></span><br><span class="line">可以传参数，表示开始查找的位置</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat方法返回一个新字符串，表示将原字符串重复n次。</span><br><span class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</span><br><span class="line">&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;</span><br><span class="line">&apos;na&apos;.repeat(0) // &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd"></a>padStart()，padEnd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">padStart()用于头部补全，padEnd()用于尾部补全</span><br><span class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</span><br><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line"></span><br><span class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br><span class="line">如果第一个参数小于x的长度，则返回原字符串</span><br><span class="line">可用于补全字节</span><br></pre></td></tr></table></figure><h3 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matchAll方法返回一个正则表达式在当前字符串的所有匹配</span><br></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JavaScript的模板需要写的格式比较麻烦，一般用+ +来写</span><br><span class="line">eg:</span><br><span class="line">$(&apos;#result&apos;).append(</span><br><span class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</span><br><span class="line">  &apos;items in your basket, &apos; +</span><br><span class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</span><br><span class="line">  &apos;&lt;/em&gt; are on sale!&apos;</span><br><span class="line">);</span><br><span class="line">但是es6引入了模板字符串</span><br><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br><span class="line">主要使用``来写还有$&#123;&#125;来拼</span><br><span class="line">当在模板字符串需要使用``时则需要使用转义符</span><br><span class="line">如果$&#123;&#125;使用的变量没有定义的话就会报错的</span><br><span class="line">用模板字符串所写的模板空格会保留，如果想要去掉空格，需要使用trim()方法</span><br><span class="line">模板字符串还可以用来嵌套</span><br><span class="line">const tmpl = addrs =&gt; `</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">  $&#123;addrs.map(addr =&gt; `</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">  `).join(&apos;&apos;)&#125;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲5</title>
      <link href="/2019/03/22/angular%E7%B2%BE%E8%AE%B25/"/>
      <url>/2019/03/22/angular%E7%B2%BE%E8%AE%B25/</url>
      
        <content type="html"><![CDATA[<p>#Angular路由精讲5，主要讲的是服务的依赖注入</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">angular框架就是一个IOC容器(实现了控制反转的容器)</span><br></pre></td></tr></table></figure><h4 id="使用依赖注入的好处"><a href="#使用依赖注入的好处" class="headerlink" title="使用依赖注入的好处"></a>使用依赖注入的好处</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使得代码松耦合、提高代码的复用性(有点类似于在某处看过的服务啊，不知道是不是一个东西)补充：好像就是服务</span><br><span class="line">提高可测试</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1553221665384.png" alt="1553221665384"></p><h4 id="注入器"><a href="#注入器" class="headerlink" title="注入器"></a>注入器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个组件都有一个注入器，负责注入组件需要的对象，自动调用构造函数去实例化</span><br><span class="line">constructor(private productService:ProductService:ProductService)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="提供器"><a href="#提供器" class="headerlink" title="提供器"></a>提供器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//为了让注入器知道如何实例化</span><br><span class="line">providers:[ProductService]</span><br><span class="line">// 即providers:[&#123;provide:ProductService,useClass:ProductService&#125;]简写版</span><br><span class="line">//providers:[&#123;provider:ProductService,useClass:AnotherProductService&#125;]</span><br><span class="line">//providers:[&#123;provide:ProductService,useFactory:()=&gt;&#123;……&#125;&#125;]</span><br></pre></td></tr></table></figure><h3 id="写个程序吧"><a href="#写个程序吧" class="headerlink" title="写个程序吧"></a>写个程序吧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不用之前的项目了，我们新建一个项目吧</span><br><span class="line">ng new &quot;project&quot;</span><br><span class="line">然后建个组件</span><br><span class="line">ng g c product1</span><br><span class="line">然后来建一个服务，具体服务是什么我这步学习中没讲，不过之前看过另一个课程，有兴趣的可以去专门学习一下什么是服务</span><br><span class="line">ng g service shared/product//这是可以在多个组件中共享的东西，相当于封装函数</span><br><span class="line">现在建立了一个组件和一个服务，这个时候服务还没有注入</span><br></pre></td></tr></table></figure><p>找到product.service.ts</p><p>可以看到基本的服务结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular&apos;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class ProductService&#123;</span><br><span class="line">constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们使用这个服务是用来获取商品信息的，所以我们需要在服务中声明一个Product来封装产品信息的类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class Product&#123;</span><br><span class="line">    constructor(//用构造函数来声明字段</span><br><span class="line">    public id:number,</span><br><span class="line">    public title:string,</span><br><span class="line">    public price:number;</span><br><span class="line">    public desc:string;</span><br><span class="line">    )&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明类之后我们需要在ProductService类声明一个方法去返回刚刚建的对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getProduct():Product&#123;//这里就不查询数据库了，就直接new一个product</span><br><span class="line">   return new Product(0,&quot;iPhone7&quot;,5899,&quot;最新苹果手机&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>现在服务的版本就说完了</li></ol><p>然后需要模块的声明</p><p>找到app.module.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">providers:[ProductService],//一般会自动引</span><br></pre></td></tr></table></figure><ol start="4"><li>改造product.component.ts，这里涉及依赖注入</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在组件的类声明一个product：Product；用来接收从服务获取的数据</span><br><span class="line">然后在构造函数以依赖注入的方式，声明服务</span><br><span class="line">constructor(private productService:ProductService)&#123;&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.product=this.productService.getProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>写组件的模板,只需要展示商品信息即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;商品详情&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;名称：&#123;&#123;product.title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;价格：&#123;&#123;product.price&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;描述：&#123;&#123;product.desc&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样模板就写完了</p><ol start="6"><li>然后我们来写一下app.component.ts的模板，来使用刚刚写的组件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;基本的依赖注入&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;app-product1&gt;&lt;/app-product1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样就写完了，就是服务，借用商品组件的构造函数，注入到商品组件，然后使用服务的getProduct方法获取所有的值，然后赋值给组件的一个变量，然后在模板写变量数据</p><p>这个例子我们将服务声明在了模块当中，提供器也可以声明在组件</p><h4 id="我们建一个组件"><a href="#我们建一个组件" class="headerlink" title="我们建一个组件"></a>我们建一个组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng g c product2</span><br><span class="line">//建一个服务</span><br><span class="line">ng g service shared/anotherProduct</span><br></pre></td></tr></table></figure><ol><li>写服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">需要用这个服务来实现刚刚写的product的service</span><br><span class="line">import &#123;Injectable&#125; from &apos;@angular&apos;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class AnotherProductService implements ProductService&#123;</span><br><span class="line">getProduct():Product&#123;//实现就要继承刚刚的方法</span><br><span class="line">return new Product(1,&quot;iPhone8&quot;,6000,&quot;最新苹果手机&quot;)</span><br><span class="line">//这里也直接返回一个商品对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后写一下Product2.component.ts</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//控制器的代码和Product1的相似</span><br><span class="line">在组件的类声明一个product：Product；用来接收从服务获取的数据</span><br><span class="line">然后在构造函数以依赖注入的方式，声明服务</span><br><span class="line">constructor(private productService:ProductService)&#123;&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.product=this.productService.getProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分和Product1.component.ts的不同就是要在这里去依赖注入服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在@Component(&#123;&#125;)写</span><br><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,useClass:AnotherProductService</span><br><span class="line">&#125;]//这时就像刚刚讲的，你虽然是同一个实例名称，但已经是实例化的另外一个服务了，当然之前的那个实例也不会修改，ProductService称为token</span><br></pre></td></tr></table></figure><ol start="3"><li>然后直接将Product1的模板拿过来</li><li>修改app.component.html，使用新组件</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>当一个提供器声明正在模块时，所有组件都可见，虽然product1这个组件没有声明product1这个注入器，但是是可以使用模块所注入的服务的 </li><li>当一个提供器声明在组件中时，只对声明的组件及其子组件可见，其他组件不可以注入</li><li>当声明在模块中和组件中的提供器具有相同的token时，组件的提供器会覆盖模块的提供器，所以Product2的组件会使用AnotherProductService这个服务</li><li>一般情况下，优先声明咋模块，只有规定其他模块不可见时，才能声明在组件(不常用)</li><li>在Product.service.ts的类写了一个@Injectable()的装饰器，是说这个ProductService也可以构造函数注入其他服务，意思是，这个构造器可以把其他服务放到这个服务来，但是不能整到其他地方，这个服务能不能注到其他组件是由在模块是否声明来决定的，</li></ol><h4 id="服务之间如何相互注入"><a href="#服务之间如何相互注入" class="headerlink" title="服务之间如何相互注入"></a>服务之间如何相互注入</h4><p>新建一个服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ng g service share/logger</span><br><span class="line">在类写</span><br><span class="line">log(message:string)&#123;</span><br><span class="line">console.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Product.service的构造函数去注入刚刚的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular&apos;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class ProductService&#123;</span><br><span class="line">constructor(public logger:LoggerService)&#123;&#125;</span><br><span class="line">getProduct():Product&#123;</span><br><span class="line">this.logger.log(&quot;调用方法&quot;)；</span><br><span class="line">//现在运行肯定不能打印</span><br><span class="line">需要在模块中将这个服务声明一下</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法或值对象来声明提供器"><a href="#工厂方法或值对象来声明提供器" class="headerlink" title="工厂方法或值对象来声明提供器"></a>工厂方法或值对象来声明提供器</h3><h4 id="使用工厂函数来声明提供器"><a href="#使用工厂函数来声明提供器" class="headerlink" title="使用工厂函数来声明提供器"></a>使用工厂函数来声明提供器</h4><p>根据随机数来确定是实例化哪个服务</p><ol><li>先去掉product2.component.ts的providers声明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//现在product1.和product2都使用模块的provider提供器</span><br><span class="line">把模块的提供器声明改成这样</span><br><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,</span><br><span class="line">    useFactory:()=&gt;&#123;</span><br><span class="line">        let logger=new LoggerService();</span><br><span class="line">        let dev=Math.random()&gt;0.5;</span><br><span class="line">        if(dev)&#123;</span><br><span class="line">return new ProductService(logger);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return new AnotherProductService(logger)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;，loggerService],</span><br></pre></td></tr></table></figure><p>然后把anotherProduct.service.ts的构造器改一下</p><p>constructor(public logger:Logger){}//讲真这步还没整懂，哦，看懂了，上一步忘了写了而已</p><p>然后在刷新，显示的两个组件就有两个组件，但是两个组件都是相同的，所以工厂方法的对象都是同一个对象。</p><p>我们在方法手工实例化了一个LoggerService,这意味着我们的对象与LoggerService的耦合度很高，实际上我们已经声明了LoggerService的提供器，那如何在工厂方法使用声明过的提供器呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,</span><br><span class="line">    useFactory:(logger:LoggerService)=&gt;&#123;//这步改这里</span><br><span class="line">        let dev=Math.random()&gt;0.5;</span><br><span class="line">        if(dev)&#123;</span><br><span class="line">return new ProductService(logger);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return new AnotherProductService(logger)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deps:[LoggerService]</span><br><span class="line">&#125;，loggerService],</span><br></pre></td></tr></table></figure><ol start="2"><li>实例化哪个对象是由随机数决定的，开发的时候是不能这样写的，开发可能需要一个变量，那变量是否可以像服务一样注入呢？看代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">加一个提供器</span><br><span class="line">&#123;</span><br><span class="line">provide：&quot;IS_DEV_ENV&quot;,</span><br><span class="line">useValue:false;//要注入的东西就是一个值false</span><br><span class="line">&#125;</span><br><span class="line">//然后在useFactory那家另一个参数isDev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">providers:[&#123;</span><br><span class="line">    provide:ProductService,</span><br><span class="line">    useFactory:(logger:LoggerService,isDev)=&gt;&#123;//这步改这里</span><br><span class="line">      </span><br><span class="line">        if(isdev)&#123;</span><br><span class="line">return new ProductService(logger);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return new AnotherProductService(logger)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deps:[LoggerService,IS_DEV_ENV]</span><br><span class="line">&#125;，loggerService],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//也可以改造变量注入</span><br><span class="line">&#123;</span><br><span class="line">provide：&quot;IS_DEV_ENV&quot;,</span><br><span class="line">useValue:&#123;isDev:false&#125;;//要注入的东西就是一个值false</span><br><span class="line">&#125;</span><br><span class="line">这样判断的时候就是isdev.isDev</span><br></pre></td></tr></table></figure><h3 id="注入器的层级关系"><a href="#注入器的层级关系" class="headerlink" title="注入器的层级关系"></a>注入器的层级关系</h3><p>项目启动，angular就会创建一个应用级注入器，将模块的提供器都注册到注入器，注册地提供器包含声明的和依赖的其他模块的提供器都会注册，然后angular会创建启动模块指着的主组件，也就是app.component,同时应用级注入器会为组件创建一个主组件注入器，然后将组件声明的提供器注册到这个注入器，然后在组件模板会引其他子组件，子组件创建时，也会为子组件创建一个注入器，然后将在子组件声明的提供器注册。</p><p><code>注入只在构造函数</code></p><h3 id="改造我们的竞拍商城"><a href="#改造我们的竞拍商城" class="headerlink" title="改造我们的竞拍商城"></a>改造我们的竞拍商城</h3><ol><li>编写ProductService包含三个方法：getProducts()，getProduct(id),getCommentForProduct(id)</li><li>修改路由配置，在从商品列表到达商品详情时不再传递商品名称，改为传递商品id</li><li>注入ProductService使用服务</li></ol><p><img src="C:\Users\28715\AppData\Local\Temp\1553246262003.png" alt="1553246262003"></p><p><img src="C:\Users\28715\AppData\Local\Temp\1553246273205.png" alt="1553246273205"></p><p><img src="C:\Users\28715\AppData\Local\Temp\1553246333057.png" alt="1553246333057"></p><p><img src="C:\Users\28715\AppData\Local\Temp\1553247208269.png" alt="1553247208269"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3学习笔记2</title>
      <link href="/2019/03/21/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2019/03/21/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<p>CSS3学习笔记02</p><a id="more"></a><h2 id="CSS3过渡"><a href="#CSS3过渡" class="headerlink" title="CSS3过渡"></a>CSS3过渡</h2><p>过渡是指元素从一种样式逐渐改变为另外一种样式</p><p>重点在于设置时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如给div设置一个：hover的width，height的样式，然后在div的样式哪里设置时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transition//过渡属性，简写</span><br><span class="line">transition-property//指CSS属性的名称</span><br><span class="line">transition-duration//过渡效果需要的时间</span><br><span class="line">transition-timing-function//liner匀速</span><br><span class="line">transition-delay//过渡效果延迟时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transition-property: width;</span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以选择简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transition: width 1s linear 2s;</span><br><span class="line">/* Firefox 4 */</span><br><span class="line">-moz-transition:width 1s linear 2s;</span><br><span class="line">/* Safari and Chrome */</span><br><span class="line">-webkit-transition:width 1s linear 2s;</span><br><span class="line">/* Opera */</span><br><span class="line">-o-transition:width 1s linear 2s;</span><br><span class="line">&#125;//顺便了解一下不同浏览器的方式</span><br></pre></td></tr></table></figure><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><ol><li>CSS动画需要创建@keyframe</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@keyframes test&#123;//指定动画名称</span><br><span class="line">from &#123;background: red;&#125;</span><br><span class="line">to &#123;background: yellow;&#125;</span><br><span class="line">//如果需要多个效果则可以使用</span><br><span class="line">//20%，40%，60%……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes test2&#123;</span><br><span class="line">0% &#123;background:red;left:0px;top:0px;&#125;</span><br><span class="line">25% &#123;background:yellow;left:200px;top:0px;&#125;</span><br><span class="line">50% &#123;background:blue;left:200px;top:200px;&#125;</span><br><span class="line">75% &#123;background:green;left:0px;top:200px;&#125;</span><br><span class="line">100% &#123;background:red;left:0px;top:0px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>将这个动画绑定到相关元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">animation:test 5s;//设置动画执行时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="CSS3动画属性"><a href="#CSS3动画属性" class="headerlink" title="CSS3动画属性"></a>CSS3动画属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">animation//设置动画属性的简写</span><br><span class="line">animation-name//设置动画名称</span><br><span class="line">animation-duration//设置动画执行时间</span><br><span class="line">animation-timing-function://设置动画的执行速率，liner为匀速，ease为匀加速</span><br><span class="line">animation-delay//设置动画的什么时候执行</span><br><span class="line">animation-iteration-count//设置动画执行次数</span><br><span class="line">animation-direction//设置动画的方向 normal，alternate</span><br><span class="line">animation-play-state//设置动画是否正在执行</span><br><span class="line">animation-fill-mode//设置动画时间之外forwards保持最后的属性，backwards返回开始属性</span><br></pre></td></tr></table></figure><h2 id="CSS3多列"><a href="#CSS3多列" class="headerlink" title="CSS3多列"></a>CSS3多列</h2><p>感觉像是将一个div当成三个div来用</p><h3 id="column-count用于设置列数"><a href="#column-count用于设置列数" class="headerlink" title="column-count用于设置列数"></a>column-count用于设置列数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">column-count:3;//将一个div分成了三个部分，如果是文字的话就会出现3列文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="column-gap用于设置列间隔"><a href="#column-gap用于设置列间隔" class="headerlink" title="column-gap用于设置列间隔"></a>column-gap用于设置列间隔</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">column-gap:40px;//用于规定列之间的间隔，间隔大的话，列就窄</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="column-rule用于设置列之间的宽度、样式和颜色"><a href="#column-rule用于设置列之间的宽度、样式和颜色" class="headerlink" title="column-rule用于设置列之间的宽度、样式和颜色"></a>column-rule用于设置列之间的宽度、样式和颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">column-rule:3px outset #ff0000;//就是在列之间加线的演示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多列属性"><a href="#多列属性" class="headerlink" title="多列属性"></a>多列属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">column-count:number|auto;//多少列|由属性例如column-width决定列数</span><br><span class="line">column-fill：balance|auto;//按照文字多少每列分配多少字符|按顺序分配字符</span><br><span class="line">column-gap:length|normal;//指定宽度|默认1em</span><br><span class="line">column-rule//设置样式，可单独设置column-rule-width</span><br><span class="line">column-span:1|all//设置元素横跨的列数</span><br><span class="line">column-width:auto|length;//由浏览器设置列宽|设置列的宽度</span><br><span class="line">column：column-width column-count;//简写</span><br></pre></td></tr></table></figure><h2 id="CSS3用户界面"><a href="#CSS3用户界面" class="headerlink" title="CSS3用户界面"></a>CSS3用户界面</h2><h3 id="CSS3-Resizing"><a href="#CSS3-Resizing" class="headerlink" title="CSS3 Resizing"></a>CSS3 Resizing</h3><p>用于规定元素是否可由用户调整大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">resize:both;</span><br><span class="line">overflow:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>用于设置以确切的方式设置某个区域的具体content</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    box-sizing:border-box;</span><br><span class="line">    width:50%;</span><br><span class="line">    float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing:content-box;//宽度和高度应用于内容框。在宽度和高度外设置编剧和边框</span><br><span class="line">box-sizing:border-box;//元素的高度宽度包含边距和边框</span><br></pre></td></tr></table></figure><h3 id="outline-offset"><a href="#outline-offset" class="headerlink" title="outline offset"></a>outline offset</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">border:2px solid black;</span><br><span class="line">outline:2px solid red;</span><br><span class="line">outline-offset:15px;</span><br><span class="line">&#125;//为元素设置外部轮廓</span><br></pre></td></tr></table></figure><h3 id="用户界面属性"><a href="#用户界面属性" class="headerlink" title="用户界面属性"></a>用户界面属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appearance:button|normal|icon|window|menu|field;</span><br><span class="line">  按钮样式|普通元素|图标|视窗|选项|字段</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲4</title>
      <link href="/2019/03/21/angular%E7%B2%BE%E8%AE%B24/"/>
      <url>/2019/03/21/angular%E7%B2%BE%E8%AE%B24/</url>
      
        <content type="html"><![CDATA[<h1 id="angular精讲4"><a href="#angular精讲4" class="headerlink" title="angular精讲4"></a>angular精讲4</h1><a id="more"></a><h3 id="接下来我们完善一下之前做的商品竞拍案例，添加路由"><a href="#接下来我们完善一下之前做的商品竞拍案例，添加路由" class="headerlink" title="接下来我们完善一下之前做的商品竞拍案例，添加路由"></a>接下来我们完善一下之前做的商品竞拍案例，添加路由</h3><p>当用户点击某个商品时，商品区域应该替换掉，显示商品的详情</p><ol><li>创建一个商品详情组件，显示商品的图片和标题</li><li>重构代码，把轮播图组件和商品列表组件封装到一个新的Home组件</li><li>配置路由，在导航到商品详情组件时传递商品的标题参数</li><li>修改APP组件，根据路由显示home组件或商品详情组件</li><li>修改商品的列表组件，给商品标题添加routeLink指令，从而指向路由</li></ol><ol><li><p>创建一个商品详情组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c product-detail</span><br></pre></td></tr></table></figure><p>因为商品标题是外部组件传过来的，所以需要声明一个标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">productTitle:string;</span><br><span class="line">//既然要接受外面穿过来的参数，则</span><br><span class="line">constructor(private routeInfo:ActivateRoute)&#123;&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productTitle=this.routeInfo.snapshot.params[&quot;prodTitle];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器写完啦</p><p>写商品详情组件模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;img src=&quot;http://placehold.it/820x230&quot;&gt;</span><br><span class="line">&lt;h4&gt;&lt;&#123;&#123;productTitle&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建home组件，封装轮播图以及商品商品组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ng g c home</span><br><span class="line">//然后在home组件的模板</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;//这片区域分成两个行</span><br><span class="line">&lt;app-carousel&gt;&lt;/app-carousel&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;app-product&gt;&lt;/app-product&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">将两个组件放到这一个组件即可</span><br><span class="line">相应的要把组件的css文件也要粘贴过来</span><br></pre></td></tr></table></figure></li><li><p>增加路由</p><p>在app.module.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const routeConfig:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component:&apos;HomeComponent&apos;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product/prodTitle&apos;,</span><br><span class="line">component:ProductDetailComponet</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">记得在import属性添加这个路由配置</span><br><span class="line">写上RouterMoudule.forRoot(routeConfig)</span><br><span class="line">//子模块路由需要写forChild</span><br></pre></td></tr></table></figure></li><li><p>在之前显示轮播图和商品组件的位置放置占位符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br></pre></td></tr></table></figure></li><li><p>增加路由链接</p><p>在商品组件的模板，给路由标题添加路由链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;&lt;a routerLink=[&apos;/product&apos;,product.title&gt;&#123;&#123;product.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;</span><br></pre></td></tr></table></figure><p>基本的改造就完成了</p></li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>angular自动处理对象的创建过程</p><p>每个angular程序都是组件、指令和依赖的类的集合，虽然每个组件都可以实例化依赖，但是angular提供了一种依赖注入模式去实例化</p><h3 id="依赖注入模式要解决的问题"><a href="#依赖注入模式要解决的问题" class="headerlink" title="依赖注入模式要解决的问题"></a>依赖注入模式要解决的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">依赖注入：DI,假设你写了一个方法，这个方法的参数是一个对象，当你调用这个对象时你需要实例化这个对象，而且将其传递给方法，也就是将参数注入给这个方法</span><br><span class="line"></span><br><span class="line">如果一个对象A要依赖一个类型为B的一个对象，那么A不需要明确的以new的方式去实例化B,B会由外部机制去注入，对象A只需要喊话：我需要一个B类型的对象，有没有人能给我一个。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制反转IOC</span><br><span class="line">这是一个经常与依赖注入同时出现的另外一个说法</span><br><span class="line">是指将依赖的控制权将从代码内部，转到外部</span><br><span class="line">例如</span><br><span class="line">var product = new Prouct()//这是内部决定，决定product依赖Product,如果想要依赖别的那我需要改掉这一行代码，而如果控制反转，则内部代码只需要喊话，我需要porduct，至于传过来的是Product还是别的实例化的，是由代码外部决定的。这时候依赖的控制权就转移到了外部。</span><br></pre></td></tr></table></figure><p>这两个说法表达的是一个思想，控制反转侧重于表达一个目的，即转移代码控制权</p><p>而依赖注入描述手段，即如何来实现控制反转，使用的手段叫做，依赖注入</p>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3学习笔记</title>
      <link href="/2019/03/20/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/20/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>css3学习笔记01</p><a id="more"></a><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="CSS3边框"><a href="#CSS3边框" class="headerlink" title="CSS3边框"></a>CSS3边框</h2><p>关键词</p><ul><li>border-radius//支持当前主流浏览器</li><li>box-shadow//支持当前主流浏览器</li><li>border-image//不支持ie</li></ul><h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键指令：border-radius</span><br></pre></td></tr></table></figure><h3 id="边框shadow"><a href="#边框shadow" class="headerlink" title="边框shadow"></a>边框shadow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键指令box-shadow</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">div&#123;</span><br><span class="line">box-shadow:10px 10px 5pa #888888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">border-image:url(border.png) 30 30 round;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3背景"><a href="#CSS3背景" class="headerlink" title="CSS3背景"></a>CSS3背景</h2><h3 id="background-size属性"><a href="#background-size属性" class="headerlink" title="background-size属性"></a>background-size属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前背景图片的大小都是根据图片实际尺寸决定的，CSS3中可规定</span><br></pre></td></tr></table></figure><h3 id="background-origin属性"><a href="#background-origin属性" class="headerlink" title="background-origin属性"></a>background-origin属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来规定背景图片的定位区域</span><br><span class="line">background-origin：content-box;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1553075366907.png" alt="1553075366907"></p><h3 id="CSS3多重背景图片"><a href="#CSS3多重背景图片" class="headerlink" title="CSS3多重背景图片"></a>CSS3多重背景图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">&#123; </span><br><span class="line">background-image:url(bg_flower.gif),url(bg_flower_2.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背景的绘制区域"><a href="#背景的绘制区域" class="headerlink" title="背景的绘制区域"></a>背景的绘制区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">background-color:yellow;//这个属性重在绘制</span><br><span class="line">background-clip:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3文本效果"><a href="#CSS3文本效果" class="headerlink" title="CSS3文本效果"></a>CSS3文本效果</h2><h3 id="Text-shadow"><a href="#Text-shadow" class="headerlink" title="Text-shadow"></a>Text-shadow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">    text-shadow:5px 5px 5px #FF0000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本换行"><a href="#文本换行" class="headerlink" title="文本换行"></a>文本换行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">word-wrap:break-word;//当单词长度超出div时自动拆分</span><br><span class="line">&#125;</span><br><span class="line">//normal使用浏览器默认换行规则</span><br><span class="line">//break-all允许在单词内换行</span><br><span class="line">//keep-all只能再半角空格或者字符串换行</span><br></pre></td></tr></table></figure><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//normal使用浏览器默认换行规则</span><br><span class="line">//break-all允许在单词内换行</span><br><span class="line">//keep-all只能再半角空格或者字符串换行</span><br></pre></td></tr></table></figure><h3 id="省略符号text-overflow属性"><a href="#省略符号text-overflow属性" class="headerlink" title="省略符号text-overflow属性"></a>省略符号text-overflow属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.test</span><br><span class="line">&#123;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">&#125;</span><br><span class="line">//当属性为clip时，直接修建文本</span><br><span class="line">//当属性为string时，使用字符串来代替修剪的文本</span><br></pre></td></tr></table></figure><h2 id="CSS3字体"><a href="#CSS3字体" class="headerlink" title="CSS3字体"></a>CSS3字体</h2><h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不仅使用自己电脑字体还可以使用喜欢的任何字体</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; </span><br><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">font-family: myFirstFont;</span><br><span class="line">src: url(&apos;Sansation_Light.ttf&apos;),</span><br><span class="line">     url(&apos;Sansation_Light.eot&apos;); /* IE9+ */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">font-family:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>若需要字体改变例如bold</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">font-family: myFirstFont;</span><br><span class="line">src: url(&apos;Sansation_Bold.ttf&apos;),</span><br><span class="line">     url(&apos;Sansation_Bold.eot&apos;); /* IE9+ */</span><br><span class="line">font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">translate()</span><br><span class="line">rotate()</span><br><span class="line">scale()</span><br><span class="line">skew()</span><br><span class="line">matrix()</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">transform:rotate(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="translate-方法移动"><a href="#translate-方法移动" class="headerlink" title="translate()方法移动"></a>translate()方法移动</h3><p>用于元素的移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: translate(50px,100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotate旋转"><a href="#rotate旋转" class="headerlink" title="rotate旋转"></a>rotate旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//div顺时针旋转30度</span><br></pre></td></tr></table></figure><h3 id="scale转换元素大小"><a href="#scale转换元素大小" class="headerlink" title="scale转换元素大小"></a>scale转换元素大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户转换元素大小</span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: scale(2,4);</span><br><span class="line">&#125;</span><br><span class="line">值 scale(2,4) 把宽度转换为原始的 2 倍，把高度转换为原始高度的 4 倍。</span><br></pre></td></tr></table></figure><h3 id="Skew（3D旋转）"><a href="#Skew（3D旋转）" class="headerlink" title="Skew（3D旋转）"></a>Skew（3D旋转）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//按照水平X轴和垂直线Y轴去旋转元素</span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: skew(30deg,20deg);</span><br><span class="line">&#125;</span><br><span class="line">值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。</span><br><span class="line">//skweX(angle)</span><br><span class="line">//skweY(angle)</span><br></pre></td></tr></table></figure><h3 id="matrix-转化效果集成"><a href="#matrix-转化效果集成" class="headerlink" title="matrix()转化效果集成"></a>matrix()转化效果集成</h3><p>matrix() 方法把所有 2D 转换方法组合在一起。</p><p>matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p>//用于定位旋转的基点位置</p><h2 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h2><h3 id="rotateX-元素围绕x轴以度数去旋转"><a href="#rotateX-元素围绕x轴以度数去旋转" class="headerlink" title="rotateX()元素围绕x轴以度数去旋转"></a>rotateX()元素围绕x轴以度数去旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: rotateX(120deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rotateY-元素围绕Y轴以度数去旋转"><a href="#rotateY-元素围绕Y轴以度数去旋转" class="headerlink" title="rotateY()元素围绕Y轴以度数去旋转"></a>rotateY()元素围绕Y轴以度数去旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: rotateY(120deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3D与2D"><a href="#3D与2D" class="headerlink" title="3D与2D"></a>3D与2D</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2D转换方法除了skew之外，加上X,Y就变成了3D</span><br><span class="line">不加的情况下，直接在方法后写3D就行了，eg:translate3D</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲3</title>
      <link href="/2019/03/20/angular%E7%B2%BE%E8%AE%B23/"/>
      <url>/2019/03/20/angular%E7%B2%BE%E8%AE%B23/</url>
      
        <content type="html"><![CDATA[<h1 id="angular精讲3"><a href="#angular精讲3" class="headerlink" title="angular精讲3"></a>angular精讲3</h1><a id="more"></a><h4 id="辅助路由"><a href="#辅助路由" class="headerlink" title="辅助路由"></a>辅助路由</h4><p>若要使用辅助路由，在模板位置除了需要声明普通占位符外，还需要别的声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br><span class="line">&lt;router-outlet name=&quot;aux&quot;&gt;&lt;/router-outlet&gt;//带有name属性的占位符</span><br></pre></td></tr></table></figure><p>在路由的配置时需要这样的路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:&apos;xxx&apos;,</span><br><span class="line">    component:XxxComponent,</span><br><span class="line">    outlet:&quot;aux&quot;</span><br><span class="line">&#125;//声明在名字为aux的占位符的位置可以显示声明组件</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">    path:&apos;yyy&apos;,</span><br><span class="line">    component:yyyComponent,</span><br><span class="line">    outlet:&quot;aux&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在路由调用时需要这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,&#123;outlets:&#123;ayx:&apos;xxx&apos;&#125;&#125;]&quot;&gt;xxx&lt;/a&gt;</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;,&#123;outlets:&#123;ayx:&apos;yyy&apos;&#125;&#125;]&quot;&gt;yyy&lt;/a&gt;</span><br><span class="line">//表示在点击链接显示一个大组件和另一个组件，二者相对独立</span><br></pre></td></tr></table></figure><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ol><li>在app组件模板写一个占位符来显示聊天面板</li><li>单独开发一个聊天室组件，只定义在新的占位符</li><li>以路由参数来控制是否使用聊天面板</li></ol><ol><li><p>首先在APP的模板添加一个辅助占位符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet name=&quot;aux&quot;&gt;&lt;/router-outlet&gt;</span><br></pre></td></tr></table></figure></li><li><p>新建聊天组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c chat</span><br></pre></td></tr></table></figure><p>写组件模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea placeholder=&quot;请输入聊天内容&quot; class=&quot;chat&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>写样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.chat&#123;</span><br><span class="line">    background:blue;</span><br><span class="line">    height:100px;</span><br><span class="line">    width:30%;</span><br><span class="line">    float:left；</span><br><span class="line">    box-sizing:border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要将之前的Product的模板样式也做调整，这个看自己的需要，和angular关系不大</p></li><li><p>增加路由配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:&apos;chat&apos;,</span><br><span class="line">    component:ChatComponent,</span><br><span class="line">    outlet:&apos;aux&apos;</span><br><span class="line">&#125;这个路由会显示在名字为aux的占位符</span><br></pre></td></tr></table></figure><p>然后在app.html文件新增两个链接用来指向聊天的路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:&apos;chat&apos;&#125;&#125;]&quot;&gt;开始聊天&lt;/a&gt;</span><br><span class="line">&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:null&#125;&#125;]&quot;&gt;结束聊天&lt;/a&gt;//这样组件就不显示了</span><br></pre></td></tr></table></figure></li></ol><p>如果希望当路由在点击开始聊天链接时跳到home路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&#123;outlets:&#123;primary:&apos;home&apos;,aux:&apos;chat&apos;&#125;&#125;]&quot;&gt;开始聊天&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><ol><li>当用户已登录或拥有某些权限的时候才能使用某些路由</li><li>一个由多个表单组件组成的向导，例如注册流程，用户只有在当前路由的组件填写了满足要求的信息才能指向下一个路由</li><li>当用户没有执行保存而试图离开路由时提醒路由</li></ol><p>angular路由提供了一些钩子，实现这样的功能，这又称为路由守卫</p><h5 id="包括三种"><a href="#包括三种" class="headerlink" title="包括三种"></a>包括三种</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CanActivate：处理导航到某路由的情况，当不能满足要求不能使用路由</span><br><span class="line">CanDeactivate：处理从当前路由离开的情况，如果不能满足本路由要求就不能离开或提升</span><br><span class="line">Resolve：在激活路由前获取路由数据，在到达路由时就将数据展示给用户</span><br></pre></td></tr></table></figure><h5 id="使用：只让登录用户能够查看产品信息路由"><a href="#使用：只让登录用户能够查看产品信息路由" class="headerlink" title="使用：只让登录用户能够查看产品信息路由"></a>使用：只让登录用户能够查看产品信息路由</h5><ol><li>首先在app建一个目录，称为guard(守卫)</li><li>在目录建一个ts文件，login.guard.ts</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export class LoginGuard implements CanActivate&#123;</span><br><span class="line">CanActivate()&#123;//一些参数目前还用不到</span><br><span class="line">//angular会根据这个方法返回的是true还是false去判断是否执行路由</span><br><span class="line">let loggedIn:boolean=Math.random()&lt;0.5;</span><br><span class="line">//在这里使用随机数是否大于0.5来模拟用户是否登录</span><br><span class="line">if(!loggedIn)&#123;</span><br><span class="line">            console.log(&quot;用户未登录&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return loggedIn；</span><br><span class="line">&#125;</span><br><span class="line">//CanActivate只有这一个方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个登录守卫</p><p>此时需要修改路由配置，将其加到路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加子路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">children:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;&apos;,</span><br><span class="line">                component:ProductDescComponent</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;seller/:id&apos;,</span><br><span class="line">                component:SellerInfoComponent</span><br><span class="line">            &#125;</span><br><span class="line">],canActivate:[LoginGuard]//可以在这里设置多个路由守卫，这些守卫会依次调用，如果一个为false那就不能使用路由</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们可以看到LoginGuard类没有实例化，那谁来实例化呢，可以使用依赖注入机制去实例化，详细稍后讲</span><br></pre></td></tr></table></figure><p>在@NgModule的provider:[]写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">providers:[LoginGuard]//这样就可以守卫商品信息路由了</span><br></pre></td></tr></table></figure><p>这样就写好了路由守卫</p><h5 id="写一个离开路由的守卫"><a href="#写一个离开路由的守卫" class="headerlink" title="写一个离开路由的守卫"></a>写一个离开路由的守卫</h5><p>在guard文件夹新建一个save.component.ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class save implements CanDeactivate&lt;ProductCompoent&gt;&#123;</span><br><span class="line">//写在括号的组件是指要保护的组件是这个组件</span><br><span class="line">CanDeactivate(component:ProductComponent&#125;)&#123;</span><br><span class="line">//根据组件的状态和属性去判断用户是否可以离开</span><br><span class="line">return window.confirm(&quot;你还没有保存，确定不保存吗&quot;);</span><br><span class="line">//用来模拟</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把守卫加到路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加子路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,</span><br><span class="line">component：ProductComponent,</span><br><span class="line">children:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;&apos;,</span><br><span class="line">                component:ProductDescComponent</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;seller/:id&apos;,</span><br><span class="line">                component:SellerInfoComponent</span><br><span class="line">            &#125;</span><br><span class="line">],</span><br><span class="line">canActivate:[LoginGuard],</span><br><span class="line">canDeactivate:[save]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在providers也记得加</p><h4 id="resolve守卫"><a href="#resolve守卫" class="headerlink" title="resolve守卫"></a>resolve守卫</h4><p>可用路由守卫传递数据，那就是使用resolve守卫</p><p>当想要到一个路由时，一般传统做法是，比如带着一个参数过去，但是在真正发送http请求时会有很大延迟，那你再页面获取的数据就会是空的，这样用户体验不好，resolve就是解决这个问题，</p><p>resolve是在到达路由之前就读取数据，之后带着数据到达路由，直接使用这些数据</p><p>在guard守卫文件夹再建一个product.resolve.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()//只有这个装饰器装饰了Router才能成功依赖注入，组件不用是因为组件已经集成了</span><br><span class="line">export class ProductResolve implements Resolve&lt;Product&gt;&#123;</span><br><span class="line">    //此处想要解析一个商品信息的数据集就传一个Product</span><br><span class="line">    constructor(private router:Router)</span><br><span class="line">    resolve(route：ActivatedRouteSnapshot,state:RouterStateSnapshot):Observable&lt;product&gt;|Promise&lt;Product&gt;|Product&#123;</span><br><span class="line">    let id:number=route.params[&quot;id&quot;];</span><br><span class="line">    if(productId==1)&#123;</span><br><span class="line">return new Product(1.&quot;iPhone7&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">this.router.navigate([&apos;/home&apos;])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//记得引包，需要Resolve和Product</span><br></pre></td></tr></table></figure><p>需要在product组件的ts文件去声明一个Product类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class Product&#123;</span><br><span class="line">constructor(public id:number,public name:string)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的路由建好之后要加到路由配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">    product:ProductResolve</span><br><span class="line">&#125;</span><br><span class="line">在providers也要加</span><br></pre></td></tr></table></figure><p>因为对象一个是id一个是name</p><p>商品属性只设置了id，所以要在商品的ts文件中再声明一个name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private productName:string;</span><br><span class="line">这时不是订阅params，而是订阅传递的数据，ngOnInit块写,</span><br><span class="line">this.routeInfo.data.subscribe（(data:&#123;product:Product&#125;)=&#123;</span><br><span class="line">   this.productId=data.product.id; </span><br><span class="line">   this.productName=data.product.name; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>记得在商品模板添加商品名称</p>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6学习笔记01</title>
      <link href="/2019/03/19/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/19/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="es6-阮一峰教程学习笔记"><a href="#es6-阮一峰教程学习笔记" class="headerlink" title="es6(阮一峰教程学习笔记)"></a>es6(阮一峰教程学习笔记)</h1><a id="more"></a><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><h3 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h3><h4 id="普通解构"><a href="#普通解构" class="headerlink" title="普通解构"></a>普通解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">普通解构</span><br><span class="line">//es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这称为结构</span><br><span class="line">let [a,b,c]=[1,2,3]//a,b,c分别等于1,2,3</span><br><span class="line">//这种方法本质属于模式匹配</span><br></pre></td></tr></table></figure><h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">嵌套解构</span><br><span class="line">let [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">此时可解构为</span><br><span class="line">foo=1;</span><br><span class="line">bar=2;</span><br><span class="line">baz=3;</span><br></pre></td></tr></table></figure><h4 id="非对称解构"><a href="#非对称解构" class="headerlink" title="非对称解构"></a>非对称解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">非对称结构</span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">third=baz;</span><br><span class="line"></span><br><span class="line">let [x, , y]=[1,2,3]</span><br><span class="line">x=1;</span><br><span class="line">y=3;</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head=1；</span><br><span class="line">tail=[2, 3, 4]；</span><br><span class="line">//按照我的理解，...tail本身就应该是属于代表一个数组</span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;];</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br><span class="line">//但是如果前面的数据比后面多，那变量值就是undefined</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果等式右边不是可遍历的结构那么报错</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解构赋值允许使用默认值</span><br><span class="line">let [foo=true]=[];</span><br><span class="line">foo=true;</span><br><span class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br><span class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br><span class="line"></span><br><span class="line">//注意：等式右边的权重更大一点，但是右边如果是undefined，那么就取默认值</span><br><span class="line"></span><br><span class="line">//除此之外，默认值还可以使用已经赋值的其他变量，但是变量必须已声明</span><br><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><h4 id="与数组的不同"><a href="#与数组的不同" class="headerlink" title="与数组的不同"></a>与数组的不同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//数组的取值关系是按照排列顺序位置决定的，但是对象是按照属性的名字决定的取值。</span><br><span class="line">//那么这种情况下，变量名如果和属性名不一样的处理方式是，先在等式左边将变量名赋予属性名。</span><br><span class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &apos;hello&apos;</span><br><span class="line">l // &apos;world</span><br><span class="line"></span><br><span class="line">//所以真正赋值的是与属性名同名的变量罢了</span><br></pre></td></tr></table></figure><h4 id="嵌套解构-1"><a href="#嵌套解构-1" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;p: [&apos;Hello&apos;,&#123; y: &apos;World&apos; &#125;]&#125;;</span><br><span class="line">let &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br><span class="line"></span><br><span class="line">//这时p是模式，不是变量如果p也需要赋值的话</span><br><span class="line">let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br><span class="line">p // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span><br><span class="line"></span><br><span class="line">eg2：</span><br><span class="line">const node = &#123;loc: &#123;start: &#123;line: 1,column: 5&#125;&#125;&#125;;</span><br><span class="line">let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // Object &#123;start: Object&#125;</span><br><span class="line">start // Object &#123;line: 1, column: 5&#125;</span><br></pre></td></tr></table></figure><p>对象的解构也可以设置默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x: y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line">默认值的条件是右边对象的属性值严格等于undefined</span><br><span class="line">undefined就会触发函数参数的默认值。</span><br><span class="line">[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);</span><br><span class="line">// [ 1, &apos;yes&apos;, 3 ]</span><br></pre></td></tr></table></figure><h4 id="已声明的变量解构"><a href="#已声明的变量解构" class="headerlink" title="已声明的变量解构"></a>已声明的变量解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">let x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">let x;</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br><span class="line"></span><br><span class="line">//这是为了避免JavaScript将&#123;x&#125;当成一个代码块</span><br></pre></td></tr></table></figure><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//对字符串直接进行转化成数组赋值，同时也可以对字符串的属性进行赋值</span><br><span class="line">//字符串赋值</span><br><span class="line">const [a, b, c, d, e] = &apos;hello&apos;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br><span class="line"></span><br><span class="line">//属性赋值</span><br><span class="line">let &#123;length : len&#125; = &apos;hello&apos;;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure><h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//如果是数值和布尔值，那么先转成对象，但是undefined和null无法转化对象，就会报错</span><br><span class="line">let &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // true</span><br><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = true;</span><br><span class="line">s === Boolean.prototype.toString // true</span><br></pre></td></tr></table></figure><h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//相当于以解构赋值的方式传参</span><br><span class="line">function add([x, y])&#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br><span class="line"></span><br><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br></pre></td></tr></table></figure><p>map()拓展：</p><p><strong>map定义和方法</strong>  map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值。  map()方法按照原始数组元素顺序依次处理元素。 </p><h4 id="不得使用圆括号的情况"><a href="#不得使用圆括号的情况" class="headerlink" title="不得使用圆括号的情况"></a>不得使用圆括号的情况</h4><p>对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 </p><h5 id="变量声明语句"><a href="#变量声明语句" class="headerlink" title="变量声明语句"></a>变量声明语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">let [(a)] = [1];</span><br><span class="line"></span><br><span class="line">let &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line">let (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line">let &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">let &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure><h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f([(z)]) &#123; return z; &#125;</span><br><span class="line">// 报错</span><br><span class="line">function f([z,(x)]) &#123; return x; &#125;</span><br></pre></td></tr></table></figure><h5 id="赋值语句的模式"><a href="#赋值语句的模式" class="headerlink" title="赋值语句的模式"></a>赋值语句的模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>赋值语句的非模式部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。 </p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li><p>用于交换变量值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li><li><p>从函数返回多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = example();</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>函数参数的定义</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br></pre></td></tr></table></figure><ol><li>提取JSON数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br></pre></td></tr></table></figure><ol><li><p>给予参数的默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function () &#123;&#125;,</span><br><span class="line">  cache = true,</span><br><span class="line">  complete = function () &#123;&#125;,</span><br><span class="line">  crossDomain = false,</span><br><span class="line">  global = true,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>遍历Map结构</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</span><br><span class="line">map.set(&apos;second&apos;, &apos;world&apos;);</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key + &quot; is &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取键名</span><br><span class="line">for (let [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// 获取键值</span><br><span class="line">for (let [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>输入模块的指定方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲2</title>
      <link href="/2019/03/19/angular%E7%B2%BE%E8%AE%B22/"/>
      <url>/2019/03/19/angular%E7%B2%BE%E8%AE%B22/</url>
      
        <content type="html"><![CDATA[<p>#angular精讲2</p><a id="more"></a><h4 id="轮播图组件"><a href="#轮播图组件" class="headerlink" title="轮播图组件"></a>轮播图组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li class=&quot;active&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&lt;div class=&quot;carousel-inner&quot;&gt;</span><br><span class="line">&lt;div class=&quot;item active&quot;&gt;</span><br><span class="line">&lt;img class=&quot;slide-image&quot; src=&quot;http://placehold.it/800x300&quot; alt=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">&lt;img class=&quot;slide-image&quot; src=&quot;http://placehold.it/800x300&quot; alt=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">&lt;img class=&quot;slide-image&quot; src=&quot;http://placehold.it/800x300&quot; alt=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;a class=&quot;left carousel-control&quot; href=&quot;javascript:$(&apos;.carousel&apos;).carousel(&apos;prev&apos;)&quot;&gt;</span><br><span class="line">&lt;span class=&quot;glyphicon glyphicon-chevron-left&gt;&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;a class=&quot;rightcarousel-control&quot; href=&quot;javascript:$(&apos;.carousel&apos;).carousel(&apos;next&apos;)&quot;&gt;</span><br><span class="line">&lt;span class=&quot;glyphicon glyphicon-chevron-right&gt;&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">//这两个样式可以实现点击切换效果</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//写个slide-image的样式</span><br><span class="line">.slide-image&#123;</span><br><span class="line">width:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="商品列表组件（这个涉及angular）"><a href="#商品列表组件（这个涉及angular）" class="headerlink" title="商品列表组件（这个涉及angular）"></a>商品列表组件（这个涉及angular）</h4><ol><li><p>在产品组件中新建一个Product对象，存储产品信息，在product.component.ts直接新建一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">export class Product&#123;</span><br><span class="line">constructor(</span><br><span class="line">public id:number,</span><br><span class="line">public title:string,</span><br><span class="line">public price:number,</span><br><span class="line">public rating:number,</span><br><span class="line">public desc:string,</span><br><span class="line">public categories:Array&lt;string&gt;</span><br><span class="line">)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">然后在ProductComponent控制器声明一个数组，存储页面将要展示的商品信息数据</span><br><span class="line">export class ProductComponent implements OnInit&#123;</span><br><span class="line">private products:Array&lt;Product&gt;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.products:[//初始化数组</span><br><span class="line">new Product(1,&quot;第一个商品&quot;,1.99,3.5,&quot;这是一个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(2,&quot;第一个商品&quot;,1.99,2.5,&quot;这是二个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(3,&quot;第一个商品&quot;,1.99,1.5,&quot;这是三个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(4,&quot;第一个商品&quot;,1.99,4.5,&quot;这是四个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(5,&quot;第一个商品&quot;,1.99,3.5,&quot;这是五个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">new Product(6,&quot;第一个商品&quot;,1.99,5,&quot;这是六个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]),</span><br><span class="line">]</span><br><span class="line">this.products.push(new Product(6,&quot;第一个商品&quot;,1.99,5,&quot;这是六个商品&quot;,[&quot;电子产品&quot;，&quot;电脑&quot;]))//可以添加一个商品</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，产品组件建立好了，就得写一下产品组件的模板了(即html)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngFor=&quot;let product of products&quot; class=&quot;col-md-4 col-sm-4 col-lg-4&quot;&gt;</span><br><span class="line">&lt;div class=&quot;thumbnail&quot;&gt;</span><br><span class="line">&lt;img src=&quot;http://placehold.it/320x150&quot;&gt;</span><br><span class="line">&lt;div class=&quot;caption&quot;&gt;</span><br><span class="line">&lt;h4 class=&quot;pull-right&quot;&gt;&#123;&#123;product.price&#125;&#125;元&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;&lt;a&gt;&#123;&#123;product.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;product.desc&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;app-stars&gt;&lt;/app-stars&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h6 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngFor=&quot;let product of products&quot; class=&quot;col-md-4 col-sm-4 col-lg-4&quot;&gt;</span><br><span class="line">//第一个学习的指令*ngFor</span><br></pre></td></tr></table></figure><h4 id="星级评价组件"><a href="#星级评价组件" class="headerlink" title="星级评价组件"></a>星级评价组件</h4><ol><li><p>如何显示一颗空心星星</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在html文件</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;span *ngFor=&quot;let star of stars&quot; class=&quot;glyphicon glyphicon-star glyphicon-star-empty&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>如何显示5颗星星</p><p>在ts文件中添加一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export class StarsComponent implements OnInit&#123;</span><br><span class="line">private stars:boolean[];</span><br><span class="line">onOnInit()&#123;</span><br><span class="line">this.stars=[true,ture,true,true,true];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>如何有星星亮其余不亮</p><p><strong>属性绑定</strong></p><p>用[属性]，将属性和控制器属性做绑定</p><p>比如讲img的src内容写到控制器，命名为imgUrl，然后在html中用[src]=”imgUrl”调用</p><p>为了让星星亮，可以采用属性绑定的特例，<strong>样式绑定</strong></p><p>先把空心星星的样式提出来，绑定到ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">&lt;span *ngFor=&quot;let star of stars&quot; class=&quot;glyphicon glyphicon-star&quot; [class. glyphicon-star-empty=&quot;star&quot;&gt;&lt;/span&gt;</span><br><span class="line">//这是表示，这是一个css样式，值要绑定到名为star变量</span><br><span class="line">//即，span标签是否拥有这个样式，是由star决定的，如果star是true就拥有样式</span><br><span class="line">&lt;span&gt;&#123;&#123;rating&#125;&#125;星&lt;/span&gt;//用于下一步测试</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>如何将星级评价数值，传递给组件ts</p><p>此时需要用到组件的另一个概念，<strong>输入属性</strong></p><p>即可以将外部商品组件的评分传递到星级评价组件来，从而实现星星亮的数量的判别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class StartsComponent implements OnInit&#123;</span><br><span class="line">@Input() private rating:number=0;//用来接收产品组件传来的评分数值</span><br><span class="line">private stars:boolean[];</span><br><span class="line">constructor()&#123; &#125;</span><br><span class="line">onOnInit()&#123;</span><br><span class="line">this.stars=[true,ture,true,true,true];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在产品组件模板使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngFor=&quot;let product of products&quot; class=&quot;col-md-4 col-sm-4 col-lg-4&quot;&gt;</span><br><span class="line">&lt;div class=&quot;thumbnail&quot;&gt;</span><br><span class="line">&lt;img src=&quot;http://placehold.it/320x150&quot;&gt;</span><br><span class="line">&lt;div class=&quot;caption&quot;&gt;</span><br><span class="line">&lt;h4 class=&quot;pull-right&quot;&gt;&#123;&#123;product.price&#125;&#125;元&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;&lt;a&gt;&#123;&#123;product.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;product.desc&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">//在这里使用属性绑定,app-stars的rating属性，是由product的rating属性传过去</span><br><span class="line">&lt;app-stars [rating]=&quot;product.rating&quot;&gt;&lt;/app-stars&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><p>5.如何根据商品的星级来决定星星是不是亮的</p><p>那就把星星初始化的值不写死，而是由传过来的rating来判断是ture还是false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export class StarsComponent implements OnInit&#123;</span><br><span class="line">private stars:boolean[];</span><br><span class="line">onOnInit()&#123;</span><br><span class="line">this.stars=[];</span><br><span class="line">for(let i=1;i&lt;=5;i++)&#123;</span><br><span class="line">this.stars.push(i&gt;this.rating)</span><br><span class="line">&#125;//这个好，直接使用数组的方式和数值比较的方式做判断</span><br><span class="line">//this.stars=[true,ture,true,true,true];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="这个组件涉及三个知识点"><a href="#这个组件涉及三个知识点" class="headerlink" title="这个组件涉及三个知识点"></a>这个组件涉及三个知识点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*ngFor</span><br><span class="line">属性绑定[src]、样式绑定[class.样式名]=&quot;变量&quot;//该变量为Boolean值，由后台传</span><br><span class="line">输入属性@Input(),由父组件将数据传到子组件</span><br></pre></td></tr></table></figure><h2 id="Angular路由"><a href="#Angular路由" class="headerlink" title="Angular路由"></a>Angular路由</h2><p>关键词：单页应用、视图状态、URL</p><p>每个应用都拥有路由器，为每一个页面分配URL，由路由器来分配</p><p><img src="C:\Users\28715\AppData\Local\Temp\1552970696547.png" alt="1552970696547"></p><p>在指定区域显示不同的组件</p><h3 id="路由知识小案例"><a href="#路由知识小案例" class="headerlink" title="路由知识小案例"></a>路由知识小案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建一个项目</span><br><span class="line">&gt;ng new router --routing</span><br></pre></td></tr></table></figure><ol><li>Routes:路由配置，保存哪个URL展示哪个组件，以及在哪个RouterOutlet展示组件</li><li>RouterOutlet:在hrml中标记路由内容呈现位置的占位符指令</li><li>Router：负责在运行时执行路由的对象，可以调用其navigate()和navigaeByUrl()方法来指向一个指定的路由</li><li>RouterLink:在html声明路由用的指令，用在模板的a标签，点a标签指向路由</li><li>ActivatedRoute当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数。</li></ol><h5 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h5><ol><li>angular应用是由多个组件组成的</li><li>每个组件都有控制器和模板，应用启动后，先展示APPcomponent组件的模板，所有的这些组件都会封装在一个模块</li><li>路由的配置也就是<strong>Routers</strong>对象就是存在模块，Routers对象由一组配置信息组成，path:用来表示url，component，用来指所展示的组件</li><li>而需要展示的组件放置的位置，就要是在需要的位置放置<strong>RouterOutlet</strong>指令，若想显示其余组件可以在模板放置链接地址（<strong>使用RouteLink</strong>)</li><li>在控制器调用<strong>Router</strong>的navigate方法来改变浏览器的地址，实现路由的转换</li><li>在url也可以传递数据，这些数据会保存在<strong>ActivatedRoute</strong></li></ol><p><img src="C:\Users\28715\AppData\Local\Temp\1552971865812.png" alt="1552971865812"></p><h4 id="使用新建项目"><a href="#使用新建项目" class="headerlink" title="使用新建项目"></a>使用新建项目</h4><p>当使用–router来新建项目的时候多一个名为app-routing-module.ts,在这个文件对这个应用配置路由</p><p>在这个文件中拥有一个AppRoutingModule模块，这个模块已经放到了app.module.ts的imports属性，也就是说，在新文件的路由配置都会直接放在app.module.ts，那么这个app就知道该使用什么样的路由配置来路由了</p><h5 id="新建两个组件"><a href="#新建两个组件" class="headerlink" title="新建两个组件"></a>新建两个组件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ng g c home</span><br><span class="line">ng g c product</span><br></pre></td></tr></table></figure><p>当点主页的链接时显示home组件</p><p>当点击商品详情链接时显示商品信息组件</p><p>然后分别在两个组件的模板写点结点去测试，现在测试肯定是没有效果的，因为没有添加路由配置</p><h5 id="添加路由配置"><a href="#添加路由配置" class="headerlink" title="添加路由配置"></a>添加路由配置</h5><p>在app-routing-module.ts文件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123;NgModule&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;Routes,RouterModule&#125; from &apos;@angular/router&apos;;</span><br><span class="line">import &#123;HomeComponent&#125; from &quot;./home/home.component&quot;;</span><br><span class="line">import &#123;ProductComponent&#125; from &quot;./product/product.component&quot;;</span><br><span class="line"></span><br><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">imports:[RouterModule.forRoot(routes)],</span><br><span class="line">exports:[RouterModule],</span><br><span class="line">providers:[]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppRoutingModule&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样路由的配置就结束</p><h5 id="这个时候看app-component-html的模板"><a href="#这个时候看app-component-html的模板" class="headerlink" title="这个时候看app.component.html的模板"></a>这个时候看app.component.html的模板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会发现有一个&lt;router-outlet&gt;&lt;/router-outlet&gt;标签//这就是一个指示路由组件显示位置的占位符</span><br></pre></td></tr></table></figure><h5 id="指向路由"><a href="#指向路由" class="headerlink" title="指向路由"></a>指向路由</h5><h6 id="方法一：使用routerLink来指向"><a href="#方法一：使用routerLink来指向" class="headerlink" title="方法一：使用routerLink来指向"></a>方法一：使用routerLink来指向</h6><p>在模板写两个a标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt;//这里就需要用/</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;]&quot;&gt;商品详情&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>这个时候使用这个项目</p><p>当直接使用localhost：4200时，url是空，那就是显示首页</p><p>当点击商品详情时，url跳转到product，那就是商品详情信息组件显示。</p><p>所有的组件内容只显示到router-outlet标签后面</p><p>这就是路由的基本策略</p><h5 id="routerLink的参数为何是一个数组而不是一个字符串"><a href="#routerLink的参数为何是一个数组而不是一个字符串" class="headerlink" title="routerLink的参数为何是一个数组而不是一个字符串"></a>routerLink的参数为何是一个数组而不是一个字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样可以在路由的时候传递参数，如[&apos;/product&apos;,&apos;&apos;]</span><br></pre></td></tr></table></figure><h6 id="方法二-使用Router对象"><a href="#方法二-使用Router对象" class="headerlink" title="方法二:使用Router对象"></a>方法二:使用Router对象</h6><p>在模板添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;商品详情&quot; (click)=&quot;toProductDetails()&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>这使用了数据绑定的第三种方式事件绑定，前面分别是差值表达式方式和属性绑定方式</code></p><p>之后需要在app.component.ts的class对象写一个函数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(private router:Router)&#123;//记得将包引到头部，一般自动引了</span><br><span class="line">//这个方法将在之后介绍</span><br><span class="line">&#125;</span><br><span class="line">toProductDetails()&#123;</span><br><span class="line">//这个方法需要用到Router对象</span><br><span class="line">this.router.navigate([&apos;/product&apos;]);//这样效果和方法一 一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="当用户点一个不存在的路径"><a href="#当用户点一个不存在的路径" class="headerlink" title="当用户点一个不存在的路径"></a>当用户点一个不存在的路径</h5><p>此时显示异常，界面没有内容</p><p><strong>解决办法</strong></p><p>需要一个通配符</p><p>再建一个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c code404//这个组件是当url不存在的地址的时候调用的组件</span><br></pre></td></tr></table></figure><p>在组件的模板写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">页面不存在</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>然后在app-routing-module.ts添加一个路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,&#123;//这个路由不能放到前面</span><br><span class="line">        path:&apos;**&apos;;</span><br><span class="line">        component:Code404Component</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>此时，当拥有不存在的url时会显示这个组件</p><h4 id="在路由时传递数据"><a href="#在路由时传递数据" class="headerlink" title="在路由时传递数据"></a>在路由时传递数据</h4><ol><li><p>在查询参数时传递数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:/product?id=1&amp;name=2 =&gt; ActivatedRoute.queryParams[id]</span><br><span class="line">这里是参数这里是在目标组件获取参数的方式</span><br></pre></td></tr></table></figure><p>修改之前的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt;//这里就需要用/</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;]&quot; [queryParams]=&quot;&#123;id=1&#125;&quot;&gt;商品详情&lt;/a&gt;</span><br><span class="line">//这个queryParams属性指向一个对象，然后在这个对象写参数，这时再点击这个链接时url就会显示参数了</span><br></pre></td></tr></table></figure><p>在product组件使用这个参数</p><p>在product.component.ts文件的class的构造器写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private routeInfo:ActivatedRoute)&#123;&#125;//记得引包</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productId = this.routeInfo.snapshot.queryParams[&quot;id&quot;];</span><br><span class="line">&#125;</span><br><span class="line">//然后将productId属性以&#123;&#123;&#125;&#125;的形式放在模板测试</span><br></pre></td></tr></table></figure></li><li><p>在路由的路径传递数据，即在url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg:&#123;path:/product/:id&#125; =&gt;/product/1 =&gt;ActivatedRoute.params[id]</span><br></pre></td></tr></table></figure><ul><li><p>需要修改路由构造函数的path属性，使得其可以传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product/:id&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import了</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>在app.component.html修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt;//这里就需要用/</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;/product&apos;,1]&quot;&gt;商品详情&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>此时若要取数据需要从url取则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private routeInfo:ActivatedRoute)&#123;&#125;//记得引包</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productId = this.routeInfo.snapshot.Params[&quot;id&quot;];//即可</span><br><span class="line">&#125;</span><br><span class="line">//然后将productId属性以&#123;&#123;&#125;&#125;的形式放在模板测试</span><br></pre></td></tr></table></figure><p>参数快照，参数订阅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructor(private routeInfo:ActivatedRoute)&#123;&#125;//记得引包</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.productId = this.routeInfo.snapshot.Params[&quot;id&quot;];//即可</span><br><span class="line">&#125;</span><br><span class="line">//然后将productId属性以&#123;&#123;&#125;&#125;的形式放在模板测试</span><br><span class="line">//这样效果和刚刚在链接那传一样，但是如果同一个参数在ngOnInit定义，那么只会赋值一次，只有从home组件开始再点击才能ngOnInit，其他的给取到的参数再次赋值，这称为参数快照</span><br><span class="line">而如果想要解决这个问题，就需要使用参数订阅的方法</span><br><span class="line">this.routeInfo.params.subscribe((params:Params)=&gt;this.productId=params[&quot;id&quot;]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在路由配置传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eg:&#123;</span><br><span class="line">path:/product,</span><br><span class="line">component:ProductComponent,</span><br><span class="line">data:[&#123;</span><br><span class="line">       isProd:true </span><br><span class="line">&#125;];</span><br><span class="line">&#125; =&gt; ActivatedRoute.data[0][isProd]</span><br></pre></td></tr></table></figure></li></ol><h4 id="重定向路由"><a href="#重定向路由" class="headerlink" title="重定向路由"></a>重定向路由</h4><p>是指在用户访问一个特定的地址时，将其重定向到另一个指定的地址</p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.aaa.com=&gt;www.aaa.com/products</span><br><span class="line">www.aaa.com/x=&gt;www.aaa.com/y</span><br></pre></td></tr></table></figure><p>使用，如：一般我们的第一个为空的指向首页，但是规范化的还是需要将空字符串写上home</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[</span><br><span class="line">    &#123;</span><br><span class="line">//path:&apos;&apos;,</span><br><span class="line">path:&apos;home&apos;,//记得绑定路由的a标签也要改</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product/:id&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import了</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的话，那么直接访问localhost:4200不会跳转到首页，而是页面不存在，只有点链接使用路由，才能显示组件</p><p>为了解决这个问题，就要使用重定向路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const routes:Routes=[//添加一个新的路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;&apos;,</span><br><span class="line">redirectTo:&apos;/home&apos;,</span><br><span class="line">pathMatch:&apos;full&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#123;</span><br><span class="line">//path:&apos;&apos;,</span><br><span class="line">path:&apos;home&apos;,//记得绑定路由的a标签也要改</span><br><span class="line">component：HomeComponent,//需要把HomeComponent给import到头部</span><br><span class="line">//children:[]//用来配子路由的目前不用</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在访问localhost：4200就会跳到localhost：4200/home</p><h4 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h4><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;//这是一个普通路由</span><br><span class="line">path:&apos;home&apos;,</span><br><span class="line">component：HomeComponent,</span><br><span class="line">&#125;</span><br><span class="line">//子路由</span><br><span class="line">&#123;//这是一个普通路由</span><br><span class="line">path:&apos;home&apos;,</span><br><span class="line">component:HomeComponent,</span><br><span class="line">children:[//写子路由后，访问home组件路由会显示HomeComponent组件模板，在outlet位置会显示子路由1</span><br><span class="line">        &#123;</span><br><span class="line">            path:&apos;&apos;,</span><br><span class="line">            component:子路由组件1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">path:&apos;/yyy&apos;,//当访问home/yyy路径的时候显示子路由组件2</span><br><span class="line">component:子路由组件2</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现子路由"><a href="#实现子路由" class="headerlink" title="实现子路由"></a>实现子路由</h5><ol><li><p>新建两个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ng g c product-desc</span><br><span class="line">ng g c seller-info</span><br></pre></td></tr></table></figure></li><li><p>在这两个组件的html模板添加一些标签测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:在一个组件写//seller-info</span><br><span class="line">&lt;p&gt;</span><br><span class="line">销售员ID是:&#123;&#123;sellerId&#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>然后在seller-info组件的ts文件写代码，为了使得sellerId能够获得参数id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在类写</span><br><span class="line">private sellerId:number;</span><br><span class="line">constructor(private routeInfo:ActivateRoute)&#123; &#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.sellerId=this.routeInfo.snapshot.params[&quot;id&quot;]//稍后以url方式传参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改路由配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//添加子路由</span><br><span class="line">&#123;</span><br><span class="line">path:&apos;product&apos;,//一般不写成/product</span><br><span class="line">component：ProductComponent,//需要把HomeComponent给import到头部</span><br><span class="line">children:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;&apos;,</span><br><span class="line">                component:ProductDescComponent</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path:&apos;seller/:id&apos;,</span><br><span class="line">                component:SellerInfoComponent</span><br><span class="line">            &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改ProductComponent的模板，因为这个子路由是在ProductComponent组件的，所以占位符需要放在ProductComponent的html模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在这个模板这放一个占位符</span><br><span class="line">//加两个链接拥有调用路由，使用组件</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;./&apos;]&quot;&gt;商品描述&lt;/a&gt;//./是用来表示当前路由的子路由的默认路由</span><br><span class="line">&lt;a [routerLink]=&quot;[&apos;./seller&apos;,99]&quot;&gt;销售员信息&lt;/a&gt;</span><br><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br></pre></td></tr></table></figure><p>写到这路由就写好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.第一个&lt;router-outlet&gt;&lt;/router-outlet&gt;是写在appcomponent的</span><br><span class="line">2.在商品详情组件又显示一个&lt;router-outlet&gt;&lt;/router-outlet&gt;这属于占位符的父子关系，当然你也可以在子路由的模板再写&lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br><span class="line">3.谁是谁的父组件啥啥啥的都是在app-routing-module.ts配置的，路由信息都是在模块层，组件本身不知道路由相关信息</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular精讲1</title>
      <link href="/2019/03/18/angular%E7%B2%BE%E8%AE%B21/"/>
      <url>/2019/03/18/angular%E7%B2%BE%E8%AE%B21/</url>
      
        <content type="html"><![CDATA[<h1 id="angular精讲1"><a href="#angular精讲1" class="headerlink" title="angular精讲1"></a>angular精讲1</h1><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">组件：是angular应用的基本构建块，你可以把一个组件理解为一段带有业务逻辑和数据的html</span><br><span class="line">服务：组件可以调用服务，服务是用来封装可以重用的业务逻辑，服务也可以互相调用</span><br><span class="line">指令：允许你想html元素添加自定义行为。</span><br><span class="line">模块：用来将应用中不同的部分组织成一个angular框架可以理解的单元。即包括组件、服务、指令</span><br></pre></td></tr></table></figure><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先下载node.js</span><br><span class="line">命令行输入</span><br><span class="line">&gt;npm install -g @angular/cli</span><br><span class="line">&gt;ng -v</span><br></pre></td></tr></table></figure><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new my-project</span><br></pre></td></tr></table></figure><h4 id="目录结构-部分重要的"><a href="#目录结构-部分重要的" class="headerlink" title="目录结构//部分重要的"></a>目录结构//部分重要的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e2e:基本的测试目录</span><br><span class="line">src:写代码的位置</span><br><span class="line">angular-cli.json:angular命令行工具的配置文件，引入jquery等包时需要修改</span><br><span class="line">karma.conf.js：执行自动化测试</span><br><span class="line">package.json:项目所需要的依赖包</span><br><span class="line">node_modules:都是项目的依赖包，不用自己写</span><br></pre></td></tr></table></figure><h5 id="src目录"><a href="#src目录" class="headerlink" title="src目录"></a>src目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app:用来写我们的代码</span><br><span class="line">assets:用来存静态资源</span><br><span class="line">environment:配置开发环境或别的环境</span><br><span class="line">index.html：总的html</span><br><span class="line">main.ts:脚本执行的大门</span><br><span class="line">polyfills.ts:添加库</span><br><span class="line">style.css:放全局的样式</span><br></pre></td></tr></table></figure><h6 id="app-component-ts"><a href="#app-component-ts" class="headerlink" title="app.component.ts"></a>app.component.ts</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.component.ts:整个项目的基础</span><br><span class="line">@component()：装饰器告知angular框架如何整这个类</span><br><span class="line">Template：模板</span><br><span class="line">Controller：包含组件的属性和方法，业务逻辑写在控制器中</span><br><span class="line">控制器通过数据绑定与模板通讯，模板展现控制器数据，控制器处理模板的事件</span><br><span class="line">import &#123;Component&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">selector:&apos;app-root,//选择器，可以通过命名的标签来调用，显示组件的内容</span><br><span class="line">templateUrl:&apos;./app.component.html&apos;,//模板，组件的内容</span><br><span class="line">styleUrls:[&apos;./app.component.css]//组件模板中需要使用的样式</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent&#123;//typescript类</span><br><span class="line">title=&apos;app works&apos;;</span><br><span class="line">/*</span><br><span class="line">模板相关的属性和方法，以及业务逻辑都放在这里</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="app-module-ts"><a href="#app-module-ts" class="headerlink" title="app.module.ts"></a>app.module.ts</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">模块</span><br><span class="line">也是带着装饰器的typescript类@NgModule装饰器，以装饰器让angular把类当成模块</span><br><span class="line">import引模块需要的东西</span><br><span class="line">在装饰器的declarations:声明组件、指令和管道</span><br><span class="line">在装饰器的imports:声明需要的其他模块如BrowserModule浏览器模块</span><br><span class="line">在装饰器的providers:[]：用来声明模块提供的服务，服务声明在这</span><br><span class="line">在装饰器的bootstrap：声明模块的主要组件是什么</span><br></pre></td></tr></table></figure><h4 id="事件绑定方式"><a href="#事件绑定方式" class="headerlink" title="事件绑定方式"></a>事件绑定方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性绑定</span><br><span class="line">事件绑定</span><br><span class="line">双向绑定</span><br></pre></td></tr></table></figure><h4 id="组件中元素"><a href="#组件中元素" class="headerlink" title="组件中元素"></a>组件中元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">必备元素：@component//装饰器 Template//模板  Controller//控制器</span><br><span class="line">可选注入对象：</span><br><span class="line">@inputs()//输入属性  接收外部传的数据，父组件可以直接传递数据给子组件</span><br><span class="line">providers//提供器  用来做依赖注入</span><br><span class="line">Lifecycle Hook//生命周期钩子 用来触发执行业务逻辑，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可选的输出对象</span><br><span class="line">Lifecycle Hook//生命周期钩子 用来触发执行业务逻辑</span><br><span class="line">styles:样式表</span><br><span class="line">Animations:动画包</span><br><span class="line">@Outputs:在组件之间传递数据</span><br></pre></td></tr></table></figure><h4 id="angular的启动过程"><a href="#angular的启动过程" class="headerlink" title="angular的启动过程"></a>angular的启动过程</h4><ol><li><p>angular启动时加载了哪个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在angular-cli.json中有一个&quot;apps&quot;拥有一个index属性和main属性，index属性一般指向src/index.html,main执行src/main.ts这是angular项目的起点脚本</span><br></pre></td></tr></table></figure><ul><li><p>main.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import是加载一些必要的库</span><br><span class="line">if(environment.production)这是根据项目当前的环境，来确定项目的模式</span><br><span class="line">platformBrowserDynamic.bootstrapModule(AppModule)让appModule作为项目起点，然后加载模块需要什么模块，然后像是原型链一样去找模块，加载完所有模块后，在index.html找启动项目时所需要的主要组件appModule指定的主要组件的selector,然后用template的内容去替换掉调用的标签。</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>   2.app文件夹任何改变都会让angular自动刷新</p><h4 id="在angular项目使用第三方类库"><a href="#在angular项目使用第三方类库" class="headerlink" title="在angular项目使用第三方类库"></a>在angular项目使用第三方类库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用命令行安装</span><br><span class="line">&gt;npm install jquery --save是为了引到package.json</span><br><span class="line">&gt;npm install bootstrap@3 --save</span><br><span class="line">//安装过程是首先将包放到node_module库然后将包引到package.json</span><br><span class="line">之后需要修改angular-cli</span><br><span class="line">把jquery和bootstrap的js和js/css分别添加到scripts属性和styles属性</span><br><span class="line"></span><br><span class="line">把类型描述文件添加到项目</span><br><span class="line">命令行</span><br><span class="line">npm install @types/jquery --save-dev</span><br><span class="line">npm install @types/bootstrap --save-dev</span><br></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>在app.component.ts的class添加一个test方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test()&#123;</span><br><span class="line">$(&quot;ada&quot;).show();</span><br><span class="line">&#125;//这样就可以使用jquery了</span><br></pre></td></tr></table></figure><h3 id="用组件化的思路来写项目"><a href="#用组件化的思路来写项目" class="headerlink" title="用组件化的思路来写项目"></a>用组件化的思路来写项目</h3><p>一个项目需要多个组件，情景，一个页面，需要页头，需要搜索组件，展示组件，商品列表组件，评价组件，页脚组件，做出一个项目来</p><p><img src="C:\Users\28715\AppData\Local\Temp\1552908485415.png" alt="1552908485415"></p><h5 id="组件新建方法-建立项目所需组件"><a href="#组件新建方法-建立项目所需组件" class="headerlink" title="组件新建方法//建立项目所需组件"></a>组件新建方法//建立项目所需组件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ng g component navbar</span><br><span class="line">ng g component footer</span><br><span class="line">ng g component search</span><br><span class="line">ng g component carousel</span><br><span class="line">ng g component product</span><br><span class="line">ng g component stars</span><br></pre></td></tr></table></figure><p>新建组件后，会自动更新app.module.ts,这些组件全都在app模块</p><h4 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h4><ol><li><p>从最基础的app组件来写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-navbar&gt;&lt;/app-navbar&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-md-3&quot;&gt;//左右布局，左边占1/4</span><br><span class="line">&lt;app-search&gt;&lt;/app-search&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;col-md-9&quot;&gt;//这片区域占3/4</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;//这片区域分成两个行</span><br><span class="line">&lt;app-carousel&gt;&lt;/app-carousel&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;app-product&gt;&lt;/app-product&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;app-footer&gt;&lt;/app-footer&gt;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1552909148495.png" alt="1552909148495"></p></li></ol><p>当前的效果肯定是不好看的，所以继续写</p><h4 id="先写头部吧-响应式"><a href="#先写头部吧-响应式" class="headerlink" title="先写头部吧//响应式"></a>先写头部吧//响应式</h4><p>在头部的组件的html文件写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav class=&quot;navbar navbar-inverse navbar-fiexed&quot;&gt;</span><br><span class="line">//这句话的意思是，我需要一个导航条，黑底白字，固定在头部</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;nav-header&quot;&gt;</span><br><span class="line">//添加一个按钮用来显示相应后隐藏的三个元素</span><br><span class="line">&lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-ex1-collapse&quot;&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;//在button加三个横线</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;在线竞拍&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;collapse navbar-collapse navbar-ex1-collapse&quot;&gt;//这个div是为了响应式布局用的</span><br><span class="line">&lt;ul class=&quot;nav navbar-nav&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站地址&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/nav&gt;</span><br><span class="line">//说明，要让按钮的点开下拉能起作用的话，就要给需要下拉的div元素设置同样的样式,其中navbar-ex1-collapse是随便取的名字，只是为了能够关联，下拉框</span><br><span class="line">//这样设置完之后就可以实现响应式的效果，点击按钮之后三个元素显示</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1552909994729.png" alt="1552909994729"></p><p>这时可以发现，部分内容被挡住了，这个时候可以在全局样式中做修改</p><p>在style.css加一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">padding-top:70px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写一下页脚"><a href="#写一下页脚" class="headerlink" title="写一下页脚"></a>写一下页脚</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;footer&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-lg-12&quot;&gt;//占据整屏幕宽</span><br><span class="line">&lt;p&gt;测试页面底部&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\28715\AppData\Local\Temp\1552910331671.png" alt="1552910331671"></p><p>前面两个组件不涉及业务逻辑</p><h4 id="写搜索表单组件"><a href="#写搜索表单组件" class="headerlink" title="写搜索表单组件"></a>写搜索表单组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=&quot;search&quot; role=&quot;form&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;label for=&quot;productTitle&quot;&gt;商品名称:&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;productTitle&quot; placeholder=&quot;商品名称&quot; class=&quot;form-control&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">&lt;label for=&quot;productPrice&quot;&gt;商品价格:&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;number&quot; id=&quot;productPrice&quot; placeholder=&quot;商品价格&quot; class=&quot;form-control&quot;&gt;</span><br><span class="line">&lt;/div class=&quot;form-group&quot;&gt;</span><br><span class="line">&lt;label for=&quot;productCategory&quot;&gt;商品类别:&lt;/label&gt;</span><br><span class="line">&lt;select id=&quot;productCategory&quot; class=&quot;form-control&quot;&gt;&lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;form-control&quot;&gt;</span><br><span class="line">&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block&quot;&gt;搜索&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础_02</title>
      <link href="/2019/03/15/javascript%E5%9F%BA%E7%A1%80-02/"/>
      <url>/2019/03/15/javascript%E5%9F%BA%E7%A1%80-02/</url>
      
        <content type="html"><![CDATA[<p>重温JavaScript02</p><a id="more"></a><h3 id="javascript基础01-02"><a href="#javascript基础01-02" class="headerlink" title="javascript基础01_02"></a>javascript基础01_02</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h5><ol><li><p>JavaScript，number数值类型最值的表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1+0.2!=0.3//不要用小数去验证小数</span><br></pre></td></tr></table></figure></li><li><p>验证结果是不是NaN，使用方法isNaN();//不是一个数字吗？若要验证num,num=10;则返回结果为false；</p></li></ol><h5 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h5><ol><li><p>字符串可以使用单引号也可以使用双引号。</p></li><li><p>求字符串的个数 ，即求字符串的长度为多少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure></li><li><p>相关转义符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">html的转义符</span><br><span class="line">&lt;   &amp;lt</span><br><span class="line">&gt;   &amp;gt</span><br><span class="line">空格   &amp;nbsp</span><br><span class="line">js的转义符</span><br><span class="line">table键   \t</span><br><span class="line">退格键   \b</span><br><span class="line">\   \\</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>字符串的拼接</p><ul><li>用+号即可</li><li>只要有一个是字符串，其它是数字，那么也是拼接</li><li>如果有一个是字符串，另一个不是，使用-、*、/号，那么此时会发生计算”10”-5=5</li></ul></li></ol><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><h5 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h5><ol><li><p>变量声明未赋值是undefined</p></li><li><p>变量如果是null，只能自己赋值，要喝NaN区分开</p></li></ol><h5 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h5><ol><li><p>其它类型转数字类型</p><ul><li>parseInt()//转整数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10a"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"g10"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1fds0"</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10.98"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"10.98dasda"</span>));<span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>parseFloat()//转小数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10a"</span>));<span class="comment">//10//别的语言无法转化</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"g10"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"1fds0"</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.98"</span>));<span class="comment">//10.98</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"10.98dasda"</span>));<span class="comment">//10.98</span></span><br></pre></td></tr></table></figure><ul><li>Number()//转数字——更加严格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10"</span>));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10a"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"g10"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"1fds0"</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10.98"</span>));<span class="comment">//10.98</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"10.98dasda"</span>));<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li><li><p>其它类型转字符串类型</p><ul><li>toString</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());</span><br></pre></td></tr></table></figure><ul><li>String()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(num));</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>其它类型转布尔类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"1"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"0"</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"11"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"-10"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"嘎嘎"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">""</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"null"</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"undefined"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="通过构造函数创建数组"><a href="#通过构造函数创建数组" class="headerlink" title="通过构造函数创建数组"></a>通过构造函数创建数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var 数组名=new Array();</span><br><span class="line"></span><br><span class="line">var array=new Array();</span><br><span class="line">//数组的名字如果直接输出，那么直接就可以把数组中的数据显示出来，如果没有数据，就看不到数据。</span><br><span class="line">var array=new Array(5);//规定数组大小,此时数组的每个值就是undefined</span><br></pre></td></tr></table></figure><h3 id="通过字面量的方式创建数组"><a href="#通过字面量的方式创建数组" class="headerlink" title="通过字面量的方式创建数组"></a>通过字面量的方式创建数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var 数组名=[];</span><br><span class="line">var arr=[];</span><br></pre></td></tr></table></figure><ul><li><p>不管是构造函数的方式还是字面量的方式，如果定义了大小，那么数据默认为undefined</p></li><li><p>构造函数的方式创建数组的时候，如果在Array()写一个数字，则表示数组的长度，若在括号写多个值，那么数组就有数据了，数组的长度就是这些值的个数。</p></li><li><p>设置数组某个位置的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 [下标]=值；</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>数组的长度-1就是最大的索引值</p></li><li><p>字面量创建的方式更简单</p></li><li><p>arr.length数组大小</p></li></ul><h3 id="数组的注意问题"><a href="#数组的注意问题" class="headerlink" title="数组的注意问题"></a>数组的注意问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,2,3,4,1];</span><br><span class="line">alert(arr);//输出的逗号是浏览器自己加的</span><br></pre></td></tr></table></figure><h3 id="数组存储的类型一定是一样的吗"><a href="#数组存储的类型一定是一样的吗" class="headerlink" title="数组存储的类型一定是一样的吗"></a>数组存储的类型一定是一样的吗</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr=[10,&apos;嘎嘎&apos;，true,&apos;undefined&apos;,new object];//可以输出结果</span><br><span class="line">//但是一般使用都使用同样的数据类型</span><br></pre></td></tr></table></figure><h3 id="数据的长度是否可以改变"><a href="#数据的长度是否可以改变" class="headerlink" title="数据的长度是否可以改变"></a>数据的长度是否可以改变</h3><p>可以</p>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular路由</title>
      <link href="/2019/03/13/angular%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/03/13/angular%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="angular路由"><a href="#angular路由" class="headerlink" title="angular路由"></a>angular路由</h2><a id="more"></a><ol><li>我有三个组件需要作为页面显示，设置路由</li><li>使用路由，需要在app.module.ts文件的import下面添加然后将Routes引入到头部</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const appRoutes:Routes=[</span><br><span class="line">    &#123;path:&apos;&apos;,component:HomeComponent&#125;//建立第一个路由</span><br><span class="line">    &#123;path:&apos;users&apos;,component:UsersComponent&#125;//建立第一个路由</span><br><span class="line">    &#123;path:&apos;servers&apos;,component:ServersComponent&#125;//建立第一个路由</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol><li><p>在app.module.ts文件的@NgModule模块的imports数组添加RouterModule，然后将RouterModule添加到头部Routes的引入模块，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RouterModule。forRoot(appRoutes);//注册路由</span><br><span class="line">import &#123;Routes,RouterModule&#125; from &apos;@angular/router&apos;;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>至此，算是添加了路由功能了，基本模块结束了。angular知道了这个路由</p></li><li><p>在app.component.html模板中，你需要知道要把路由带来的页面添加到哪里，类似于模板引擎的原理。保留一个模板。在加载页面的html位置，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet&gt;&lt;/router-outlet&gt;//这是一个指令</span><br></pre></td></tr></table></figure></li><li><p>若使用某个a标签使得页面刷新到另外的页面，则删掉a标签的href属性添加routerLink属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li role=&quot;presentation&quot; class=&quot;active&quot;&gt;&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li role=&quot;presentation&quot;&gt;&lt;a routerLink=&quot;/servers&quot;&gt;Servers&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li role=&quot;presentation&quot;&gt;&lt;a [routerLink]=&quot;[&apos;/users&apos;]&quot;&gt;Users&lt;/a&gt;&lt;/li&gt;//添加多个页面或参数时使用</span><br></pre></td></tr></table></figure></li><li><p>注意上面的class=”active”是引用的css样式当点击时是选中的样式，在路由修改成如下,添加指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li role=&quot;presentation&quot; routerLinkActive=&quot;active&quot;&gt;&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>也可以将这个指令添加到a标签,bootstrap还是放到li标签好点</p><p>将这个属性添加到6的每个li标签就可以实现点击样式，但是起初的默认选中样式却没有删掉。此时可以如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li role=&quot;presentation&quot; routerLinkActive=&quot;active&quot; [routeLinkActionOptions]=&quot;&#123;exact:true&#125;&quot;&gt;&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>在某个组件，若想要当点击某个按钮时使用router则如下</p><ul><li><p>在组件的ts文件的constructor括号里写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private router:Router//头部文件引用</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>当点击按钮后执行函数事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.router.navigate([&apos;/servers&apos;]);</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:&apos;users/:id&apos;,component:UsersComponent&#125;//传值选择某个数据</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础01_01</title>
      <link href="/2019/03/12/javascript%E5%9F%BA%E7%A1%8001-01/"/>
      <url>/2019/03/12/javascript%E5%9F%BA%E7%A1%8001-01/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript基础01"><a href="#javascript基础01" class="headerlink" title="javascript基础01"></a>javascript基础01</h1><a id="more"></a><h3 id="js分为三个部分"><a href="#js分为三个部分" class="headerlink" title="js分为三个部分"></a>js分为三个部分</h3><ul><li>ECMAScript</li><li>DOM</li><li>BOM</li></ul><h3 id="JavaScript是什么"><a href="#JavaScript是什么" class="headerlink" title="JavaScript是什么"></a>JavaScript是什么</h3><ul><li><p>是一门脚本语言</p></li><li><p>是一门解释性语言</p></li><li><p>是一门动态类型的语言</p></li><li><p>是一门基于对象的语言</p></li></ul><h3 id="编译语言与脚本语言的区别"><a href="#编译语言与脚本语言的区别" class="headerlink" title="编译语言与脚本语言的区别"></a>编译语言与脚本语言的区别</h3><p>编译语言：需要把代码翻译成计算机语言才能执行</p><p>脚本语言：不需要编译就可以直接执行</p><p>常用的脚本语言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-sql、cmd</span><br></pre></td></tr></table></figure><h3 id="js的作用"><a href="#js的作用" class="headerlink" title="js的作用"></a>js的作用</h3><p>js解决用户和浏览器之间的问题</p><h3 id="js写法"><a href="#js写法" class="headerlink" title="js写法"></a>js写法</h3><ul><li>js可以写在外部文件中，但是要引到html文件</li><li>js的代码可以写在html标签中写</li><li>在一对script标签有错误的js代码，那么错误代码后面的js代码不会执行</li><li>但是第一个script标签中的代码错了，后面script标签中的正确js代码都看看呀执行</li><li>script标签中可以写type=”text/javascript”和language=”javascript”,也可以两个标签都写，解决浏览器解析时可能出错的问题</li><li>script标签在页面可以出现多次</li><li>script标签一般是放在body标签的最后，也可以放在头部（需要别的方式）</li><li>js每一行后面都要加分号，不容易出错。</li><li>js区分大小写</li><li>js字符串可以使用单引号也可以使用双引号</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>操作的数据都是在内存中操作</p></li><li><p>js中存储数据使用变量的方式（名字，值—&gt;数据）</p></li><li><p>js中声明变量都用var，数据需要拥有数据类型</p></li><li><p>没有赋值的变量为undefined(没有返回值的函数也为undefined)</p></li><li><p>undefined+一个数字为NaN</p></li></ul><h3 id="变量的交换"><a href="#变量的交换" class="headerlink" title="变量的交换"></a>变量的交换</h3><h4 id="方法一-第三方变量"><a href="#方法一-第三方变量" class="headerlink" title="方法一:第三方变量"></a>方法一:第三方变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1=10;</span><br><span class="line">var num2=20;</span><br><span class="line">var temp = num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br></pre></td></tr></table></figure><h4 id="方法二-用于数字的交换"><a href="#方法二-用于数字的交换" class="headerlink" title="方法二:用于数字的交换"></a>方法二:用于数字的交换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1=10;</span><br><span class="line">var num2=20;</span><br><span class="line">num1=num1+num2;//30</span><br><span class="line">num2=num1-num2;//10</span><br><span class="line">num1=num1-num2;//20</span><br></pre></td></tr></table></figure><h3 id="方法三：异或的方式"><a href="#方法三：异或的方式" class="headerlink" title="方法三：异或的方式"></a>方法三：异或的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num1=10;</span><br><span class="line">var num2=20;</span><br><span class="line">num1 = num1^num2;</span><br><span class="line">num2 = num1^num2;</span><br><span class="line">num1 = num1^num2;</span><br></pre></td></tr></table></figure><h3 id="代码格式规范化"><a href="#代码格式规范化" class="headerlink" title="代码格式规范化"></a>代码格式规范化</h3><p>webStorm:Ctrl+Alt+L</p><h3 id="获取变量的数据类型"><a href="#获取变量的数据类型" class="headerlink" title="获取变量的数据类型"></a>获取变量的数据类型</h3><h4 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number</span><br><span class="line">string</span><br><span class="line">boolean</span><br><span class="line">null//对象为空，赋值为null//为对象类型</span><br><span class="line">undefined</span><br><span class="line">object</span><br></pre></td></tr></table></figure><h4 id="typeof获取js变量数据类型"><a href="#typeof获取js变量数据类型" class="headerlink" title="typeof获取js变量数据类型"></a>typeof获取js变量数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeof 变量名</span></span><br><span class="line"><span class="comment">//typeof(变量名)</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="built_in">String</span>(<span class="literal">null</span>))结果为<span class="literal">null</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular服务的依赖注入</title>
      <link href="/2019/03/11/angular%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/03/11/angular%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="服务和依赖注入"><a href="#服务和依赖注入" class="headerlink" title="服务和依赖注入"></a>服务和依赖注入</h1><a id="more"></a><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ol><li><p>建立一个服务能够让多个组件同时使用，相当于封装外部函数，别的html文件可以引用这个函数，提高代码复用性。‘</p></li><li><p>服务是用来替代@Output和@Input的</p></li><li><p>情景：在一个APP中包含两个组件，要让这两个组件都能使用这个服务</p></li><li><p>首先在APP建立一个组件命名为logging.service.ts</p></li><li><p>文件中代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class LoggingService&#123;</span><br><span class="line">logStatusChange(status:string)&#123;</span><br><span class="line">console.log(&apos;A server status changed,new status:&apos;+status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在组件使用</p><ul><li>方法一(不推荐)</li></ul><p>在相应组件ts文件中写以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;LoggingService&#125; from &apos;../logging.service&apos;;</span><br></pre></td></tr></table></figure><p>在需要执行服务的地方输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const service = new LoggingService();</span><br><span class="line">service.logStatusChange(accountStatus);</span><br></pre></td></tr></table></figure><ul><li><p>方法二（angular提供）——依赖注入</p><ul><li><p>在需要使用服务的组件ts文件的class模块写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor（private loggingService:LoggingService)&#123;//服务的名称</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在头部引入LoggingService</p></li><li><p>在@component添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider：[LoggingService]</span><br></pre></td></tr></table></figure></li><li><p>在需要执行服务的地方执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.loggingService.logStatusChange(accountStatus)//传入的参数，本次执行是在一个事件之后执行的，所以添加this</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>管理和存储数据的服务</p><p>新建服务命名为：accounts.service.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export class AccountsService&#123;</span><br><span class="line">accounts=[</span><br><span class="line">&#123;</span><br><span class="line">name:&apos;master&apos;,</span><br><span class="line">status:&apos;active&apos;</span><br><span class="line">&#125;</span><br><span class="line">accounts=[</span><br><span class="line">&#123;</span><br><span class="line">name:&apos;master&apos;,</span><br><span class="line">status:&apos;active&apos;</span><br><span class="line">&#125;</span><br><span class="line">accounts=[</span><br><span class="line">&#123;</span><br><span class="line">name:&apos;master&apos;,</span><br><span class="line">status:&apos;active&apos;</span><br><span class="line">&#125;</span><br><span class="line">addAccount(name:string,status:string)&#123;//不同函数传参不同</span><br><span class="line">this.accounts.push(&#123;name:name,status:status&#125;);</span><br><span class="line">&#125;</span><br><span class="line">updataStatus(id:number,status:string)&#123;</span><br><span class="line">this.accounts[id].status = status;</span><br><span class="line">&#125;</span><br><span class="line">&#125;//这样的结构</span><br></pre></td></tr></table></figure><p>在app的ts文件写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accounts:&#123;name:string,status:string&#125;[]=[];</span><br><span class="line">//剩下的代码和上面的代码一样</span><br></pre></td></tr></table></figure><p>可以在export后添加implements OnInit</p><p>然后在模块中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngOnInit()&#123;</span><br><span class="line">this.accounts = this.accountsService.accounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><ol><li><p>放在app.moudule.ts的，全局都可以使用的服务</p></li><li><p>放在别的地方的，只能其子组件才能使用这个服务</p></li><li><p>放在最底层的，只有自己才能访问</p><ul><li>对于子组件来说，如果父级服务添加到了子组件，那么子组件就不能再添加服务了，不然就会覆盖掉，这个时候只需要将provider的服务名称保留一个即可。</li></ul></li><li><p>也可将子组件中provider的服务删掉，将服务添加到app.module.ts的@NgModule{}模块，添加provider:[],将服务添加。</p><p>如果要把服务引到同级的服务(注意是服务)，那要在服务中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular/core&apos;</span><br></pre></td></tr></table></figure><p>其他代码相同</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular 指令</title>
      <link href="/2019/03/10/angular-%E6%8C%87%E4%BB%A4%E7%AE%80%E8%BF%B0/"/>
      <url>/2019/03/10/angular-%E6%8C%87%E4%BB%A4%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="angular指令"><a href="#angular指令" class="headerlink" title="angular指令"></a>angular指令</h2><a id="more"></a><h3 id="一、在APP中建立指令文件夹"><a href="#一、在APP中建立指令文件夹" class="headerlink" title="一、在APP中建立指令文件夹"></a>一、在APP中建立指令文件夹</h3><ul><li><p>类似于建立组件文件</p></li><li><p>首先建立文件夹例如basic-heightlight</p></li><li><p>在文件夹中建立basic-height.directive.ts文件</p></li><li><p>文件中需要做的是(本指令主要是为了改变元素的北京燕山)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,ElementRef&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBasicHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BasicHightDirective implements OnInit&#123;</span><br><span class="line">constructor（private elementRef:ElementRef）&#123;//前面的elementRef名字自己选，但是后面的类型要确定</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.elementRef.nativeElement.style.backgroundColor=&quot;green&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="此处是组件的建立代码做对比"><a href="#此处是组件的建立代码做对比" class="headerlink" title="此处是组件的建立代码做对比"></a>此处是组件的建立代码做对比</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component&#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;app-shopping-edit&apos;,</span><br><span class="line">  templateUrl: &apos;./shopping-edit.component.html&apos;,</span><br><span class="line">  styleUrls: [&apos;./shopping-edit.component.css&apos;]</span><br><span class="line">&#125;)</span><br><span class="line">export class ShoppingEditComponent implements OnInit &#123;</span><br><span class="line">constructor() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二、将指令添加到app-module-ts，像组件一样"><a href="#二、将指令添加到app-module-ts，像组件一样" class="headerlink" title="二、将指令添加到app.module.ts，像组件一样"></a>二、将指令添加到app.module.ts，像组件一样</h3><p>在declarations里添加指令BasicHighLightDirective</p><p>同时在头部添加import {BasicHighLightDirective} from ‘路径’</p><h3 id="三、在html中使用这个指令"><a href="#三、在html中使用这个指令" class="headerlink" title="三、在html中使用这个指令"></a>三、在html中使用这个指令</h3><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p appBasicHighyLight&gt;test&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>就像是给p添加一个属性一样，这样就可以改变p元素的背景颜色了。</p><h3 id="四、another-way-推荐"><a href="#四、another-way-推荐" class="headerlink" title="四、another way(推荐)"></a>四、another way(推荐)</h3><p>使用命令行新建指令 ng g d better-hightlight</p><p>将会在app中新建两个ts文件，删掉其中一个spec.ts文件没什么用</p><p>可以将ts文件放到一个文件夹当中，之后要把app.module.ts文件中头部指令引入的路径修改了。</p><p>ts文件中同样需要这些代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.renderer.setStyle(this.elRef.nativeElement,&apos;backgroundColor&apos;,&apos;blue&apos;,false,false)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后再app的html文件中相应元素添加属性即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p appBetterHighyLight&gt;test&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="五、响应式样式变化"><a href="#五、响应式样式变化" class="headerlink" title="五、响应式样式变化"></a>五、响应式样式变化</h3><h4 id="使用-HostListener"><a href="#使用-HostListener" class="headerlink" title="使用@HostListener"></a>使用@HostListener</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef,HostListener&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line"></span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@HostListener(mouseenter) mouseover(eventData:Event)&#123;</span><br><span class="line">this.renderer.setStyle(this.elRef.nativeElement,&apos;backgroundColor&apos;,&apos;blue&apos;,false,false)</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(mouseleave) mouseleave(eventData:Event)&#123;</span><br><span class="line">this.renderer.setStyle(this.elRef.nativeElement,&apos;backgroundColor&apos;,&apos;transparent&apos;,false,false)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hostBinding使用"><a href="#hostBinding使用" class="headerlink" title="@hostBinding使用"></a>@hostBinding使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef,HostListener,hostBinding&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line">@hostBinding(&apos;style.backgroundColor&apos;) backgroundColor:string=&apos;transparent&apos;;</span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseenter&apos;) mouseover(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=&apos;blue&apos;</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseleave&apos;) mouseleave(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=&apos;transparent&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自己决定鼠标hover的颜色"><a href="#自己决定鼠标hover的颜色" class="headerlink" title="自己决定鼠标hover的颜色"></a>自己决定鼠标hover的颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,OnInit,Render2,ElementRef,HostListener,hostBinding,Input&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appBetterHightLight]&apos;//指令主要面向元素</span><br><span class="line">&#125;)</span><br><span class="line">export class BetterHightDirective implements OnInit&#123;</span><br><span class="line">@Input() defaultColor:string=&apos;transparent&apos;;</span><br><span class="line">@Input() highlightColor:string=&apos;blue&apos;</span><br><span class="line">@hostBinding(&apos;style.backgroundColor&apos;) backgroundColor:string;</span><br><span class="line">constructor（private elRef:ElementRef,private renderer:Render2）&#123;</span><br><span class="line">&#125;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.backgroundColor=&quot;defaultColor&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseenter&apos;) mouseover(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=this.highlightColor;</span><br><span class="line">&#125;</span><br><span class="line">@HostListener(&apos;mouseleave&apos;) mouseleave(eventData:Event)&#123;</span><br><span class="line">this.backgroundColor=this.defaultColor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在p标签中添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p appBetterHighyLight [defaultColor]=&quot;&apos;yellow&apos;&quot; [highlightColor]=&quot;&apos;red&apos;&quot;&gt;test&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果将上述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Input() highlightColor:string=&apos;blue&apos;修改为</span><br><span class="line">@Input(&apos;appBetterHightLight&apos;) highlightColor:string=&apos;blue&apos;;那么html文件中就应该这样修改</span><br><span class="line">&lt;p [appBetterHighyLight]=&quot;&apos;red&apos;&quot; [defaultColor]=&quot;&apos;yellow&apos;&quot;&gt;test&lt;/p&gt;这里的&quot;&apos;red&apos;&quot;也可以改为&quot;red&quot;</span><br></pre></td></tr></table></figure><h3 id="六、structural-directives"><a href="#六、structural-directives" class="headerlink" title="六、structural directives"></a>六、structural directives</h3><p>命令行创建一个structural directives，使用ts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive,Input,TemplateRef&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Directive(&#123;</span><br><span class="line">selector:&apos;[appUnless]&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class UnlessDirective&#123;</span><br><span class="line">@Input() set appUnless(condition:boolean)&#123;</span><br><span class="line">if(!condition)&#123;</span><br><span class="line">this.vcRef.creatEmbeddedView(this.templateRef);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">this.vcRef.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor（private templateRef:TemplateRef&lt;any&gt;,private vcRef:ViewContainerRef）&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得将这个组件添加到moudule.ts文件</p><p>在html中使用这个指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *appUnless=&quot;onlyOdd&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="ngSwitch"><a href="#ngSwitch" class="headerlink" title="ngSwitch"></a>ngSwitch</h4><p>如果在app.ts复制value=10</p><p>在html中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div [ngSwitch]=&quot;value&quot;&gt;</span><br><span class="line">&lt;p *ngSwitchCase=&quot;5&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p *ngSwitchCase=&quot;10&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p *ngSwitchCase=&quot;100&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p *ngSwitchDefault&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular Component$databinding</title>
      <link href="/2019/03/09/Angular-Component-databinding/"/>
      <url>/2019/03/09/Angular-Component-databinding/</url>
      
        <content type="html"><![CDATA[<h1 id="Components-amp-Databinding详解"><a href="#Components-amp-Databinding详解" class="headerlink" title="Components&amp;Databinding详解"></a>Components&amp;Databinding详解</h1><a id="more"></a><h3 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h3><p>​    可以将一个大的组件划分成多个小的组件，直接将大组件中的代码剪切到小组件中</p><p>​    然后将大组件的ts文件中为这段代码所定义的模块剪切到小组件的ts文件中。</p><h3 id="父组件引用子组件中的内容（属性）"><a href="#父组件引用子组件中的内容（属性）" class="headerlink" title="父组件引用子组件中的内容（属性）"></a>父组件引用子组件中的内容（属性）</h3><p>需要在子组件的OnInit的定义使用@Input()，例如</p><blockquote><p>@Input() element:{name:string};</p><p>可以坐在Input（）加入’name’，定义外部组件访问此组件时的名称</p><p>然后将Input添加到子组件头部的import当中</p></blockquote><h3 id="如何通知父组件子组件有更新（比如新创建了按钮）（事件）"><a href="#如何通知父组件子组件有更新（比如新创建了按钮）（事件）" class="headerlink" title="如何通知父组件子组件有更新（比如新创建了按钮）（事件）"></a>如何通知父组件子组件有更新（比如新创建了按钮）（事件）</h3><ol><li><p>将子组件调用的方法放置到父组件当中如onServerAdded(serverData:{name:string}){<br>}</p></li><li><p>在父组件的html文件中引入子组件，例如在app中放入<app-cockpiy (servercreated)="onServerAdded($event)"></app-cockpiy></p></li><li><p>将</p><blockquote><p>@Output（） serverCreated = new EventEmitter\&lt;{name:string}>()定义到子组件的OnInit中</p><p>同时将output放置到头部的import中，括号内也可以分配别名</p></blockquote></li><li><p>将onServerAdded方法在子组件中定义，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onAddServer()&#123;</span><br><span class="line">this.serverCreated.emit(&#123;name:this.newServerName&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>angular默认将css封装在其自身组件之中，但是外部组件却不能用。这是angular提供的，不是浏览器提供的。</p><p>在某一组件的name.component.ts文件中的@Component模块中，可以添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encapsulation:ViewEncapsulation.Native或者None或者Emulated(默认的)</span><br></pre></td></tr></table></figure><p>None:样式为全局</p><p>Native：类似于Emulated</p><h3 id="在模板中使用本地参数-代替ngmodel"><a href="#在模板中使用本地参数-代替ngmodel" class="headerlink" title="在模板中使用本地参数(代替ngmodel)"></a>在模板中使用本地参数(代替ngmodel)</h3><p>eg:在input中添加#serverNameInput,然后在所调用的函数之中传入serverNameInput参数，console.log可以打印输入的内容再做调整</p><h3 id="ViewChild-代替ngmodel"><a href="#ViewChild-代替ngmodel" class="headerlink" title="ViewChild(代替ngmodel)"></a>ViewChild(代替ngmodel)</h3><p>eg:在input中添加#serverContentInput,在ts文件中添加@ViewChild(‘serverContentInput’) serverContentInput:ElementtRef;然后在头部文件添加ViewChild</p><p>console.log(this.serverContentInput.nativeElement.value)</p><p>可以直接给this.serverContentInput.nativeElement.value赋值，（是一个点击事件）那么点击按钮之后值就会直接显示在输入框。&lt;不推荐&gt;</p><h3 id="constructor和ngOnInit"><a href="#constructor和ngOnInit" class="headerlink" title="constructor和ngOnInit"></a>constructor和ngOnInit</h3><p>eg:每次创建都会执行这两个代码</p><p>在constructor代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;constructor&apos;);</span><br></pre></td></tr></table></figure><p>在ngOnInit代码块输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;ngOninit&apos;);</span><br></pre></td></tr></table></figure><p>在OnInit中创建代码，同时将onChanges添加到OnInit后面,将SimpleChanges添加到头部文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngOnChanges(changes:SimpleChanges)&#123;</span><br><span class="line">console.log(&apos;ngOnChanges&apos;);</span><br><span class="line">console.log(changes);//打印一个改变的状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在OnInit中创建代码，同时将doCheck添加到OnInit后面,将doCheck添加到头部文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngDoCheck()&#123;</span><br><span class="line">console.log(&quot;Check&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>survey.js</title>
      <link href="/2019/03/08/survey.js/"/>
      <url>/2019/03/08/survey.js/</url>
      
        <content type="html"><![CDATA[<p>学习一下survey.js</p><a id="more"></a><h3 id="一、首先需要在电脑中安装了node-js以及npm"><a href="#一、首先需要在电脑中安装了node-js以及npm" class="headerlink" title="一、首先需要在电脑中安装了node.js以及npm"></a>一、首先需要在电脑中安装了node.js以及npm</h3><p>可以用过在cmd命令行下输入node -v以及npm -v检查自己是否安装</p><h3 id="二、新建一个文件夹"><a href="#二、新建一个文件夹" class="headerlink" title="二、新建一个文件夹"></a>二、新建一个文件夹</h3><p>在命令行下cd到这个文件夹，然后输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/surveyjs/quickstart  my-proj</span><br><span class="line">cd my-proj</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>server.js建立成功</p><h3 id="三、做自己的demo问卷"><a href="#三、做自己的demo问卷" class="headerlink" title="三、做自己的demo问卷"></a>三、做自己的demo问卷</h3><p>找到my-proj文件夹，到达如下路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/app/app.component.ts</span><br></pre></td></tr></table></figure><p>查看前几行的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// If you want to show survey, uncomment the line below</span><br><span class="line">如果想要查看模板问卷就将下面的代码取消注释</span><br><span class="line">// template: `&lt;h1&gt;Survey&lt;/h1&gt;&lt;survey [json]=&quot;json&quot;&gt;&lt;/survey&gt;`</span><br><span class="line">// If you want to show survey editor, uncomment the line below</span><br><span class="line">如果想要编辑一份问卷就将下面的代码取消注释</span><br><span class="line">// template: `&lt;h1&gt;Survey JS Editor&lt;/h1&gt;&lt;survey-editor&gt;&lt;/survey-editor&gt;`</span><br></pre></td></tr></table></figure><h3 id="四、利用工具"><a href="#四、利用工具" class="headerlink" title="四、利用工具"></a>四、利用工具</h3><p>当我们想要建立自己的问卷时，就要利用server-editor工具即将上面的第四条代码取消注释后的工具，也可以直接通过网址使用</p><blockquote><blockquote><p><a href="https://surveyjs.io/Editor/Editor/" target="_blank" rel="noopener">https://surveyjs.io/Editor/Editor/</a></p></blockquote></blockquote><p>可以使用这个工具将所需要的问卷组件拖拽到空白区域</p><p>接着点击JSON Editor(左上角)将其中的代码除掉最外层的大括号，复制。</p><p>将app.component.ts中json数据块当中的pages删掉</p><p>将复制的内容粘贴，再打开浏览器就可以看到你制作的问卷了。</p><h3 id="五、查看提交数据格式"><a href="#五、查看提交数据格式" class="headerlink" title="五、查看提交数据格式"></a>五、查看提交数据格式</h3><blockquote><p><a href="https://surveyjs.io/Examples/Library/?id=real-productfeedback&amp;platform=Angular2#" target="_blank" rel="noopener">https://surveyjs.io/Examples/Library/?id=real-productfeedback&amp;platform=Angular2#</a></p></blockquote><p>通过网址点击侧边栏的SurveyJs Service中的Get Survey Result</p><p>填写数据，点击提交，就可以看到输出的数据格式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Survey.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular新建组件方法</title>
      <link href="/2019/03/06/angular%E6%96%B0%E5%BB%BA%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/06/angular%E6%96%B0%E5%BB%BA%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="angular新建组件方法"><a href="#angular新建组件方法" class="headerlink" title="angular新建组件方法"></a>angular新建组件方法</h1><a id="more"></a><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>工具</strong>：vs code</p><p><strong>项目名</strong>：project-app</p><h6 id="我的组件名为header"><a href="#我的组件名为header" class="headerlink" title="我的组件名为header"></a>我的组件名为header</h6><p><strong>步骤</strong>：</p><ul><li><p>vs code打开project-app项目</p></li><li><p>打开src文件夹</p></li><li><p>进入app文件夹</p></li><li><p>在app文件夹中新建一个文件夹作为组件文件夹</p></li><li><p>在文件夹中创建两个文件命名为 name.component.ts(name为你的组件名称)、name.component.html</p></li></ul><ul><li><p>在name.component.ts文件中数据以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Template &#125; from &apos;@angular/compiler/src/render3/r3_ast&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line"></span><br><span class="line">    selector:&apos;app-name&apos;,(name为你的组件名称)</span><br><span class="line"></span><br><span class="line">    templateUrl:&apos;./name.component.html&apos;此处为你的组建中新建的html文件的路径</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class HeaderComponent&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  示例代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Template &#125; from &apos;@angular/compiler/src/render3/r3_ast&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line"></span><br><span class="line">    selector:&apos;app-header&apos;,</span><br><span class="line"></span><br><span class="line">    templateUrl:&apos;./header.component.html&apos;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class HeaderComponent&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>找到app.module.ts文件，将nameCompontent添加到@NgModule中，同时在文件头部添加import { NameComponent } from ‘./header/header.compoment’; <code>此处是你组件的路径</code></p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">import &#123; AppComponent &#125; from &apos;./app.component&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; HeaderComponent &#125; from &apos;./header/header.compoment&apos;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line"></span><br><span class="line">  declarations: [</span><br><span class="line"></span><br><span class="line">    AppComponent,</span><br><span class="line"></span><br><span class="line">    HeaderComponent,</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  imports: [</span><br><span class="line"></span><br><span class="line">    BrowserModule</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  providers: [],</span><br><span class="line"></span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件新建成功，可以开始在组件中添加内容了"><a href="#组件新建成功，可以开始在组件中添加内容了" class="headerlink" title="组件新建成功，可以开始在组件中添加内容了"></a>组件新建成功，可以开始在组件中添加内容了</h3><h2 id="方法二：命令行方式"><a href="#方法二：命令行方式" class="headerlink" title="方法二：命令行方式"></a>方法二：命令行方式</h2><ul><li>在cmd中cd到project-app文件夹</li><li>输入ng g c header即可创建组件，自动完成了以上步骤</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
